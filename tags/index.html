<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"}>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1b" />

    <link rel="alternate" type="application/rss+xml" href="http://zhaoguibin.me/tags/index.xml" title="个人笔记" />
    
        <title>Tags | 个人笔记</title>
    

    
    <style>
        :root {
          --background: #ffffff;
        }
        @media (prefers-color-scheme: dark) {
          :root {
            --background: #1b1b1b;
          }
        }
        html {
            background-color: var(--background);
        }
        body {
            background-color: var(--background);
        }
    </style>

    
    <link href="/fonts/Inter-Regular.woff2?v=4.0" rel="preload" type="font/woff2" as="font" crossorigin="">
    <link href="/fonts/Inter-Italic.woff2?v=4.0" rel="preload" type="font/woff2" as="font" crossorigin="">
    <link href="/fonts/Inter-Bold.woff2?v=4.0" rel="preload" type="font/woff2" as="font" crossorigin="">
    <link href="/fonts/iosevka-regular.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
    <link href="/fonts/iosevka-extended.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">

    
    <link rel="stylesheet" type="text/css" href="/style.min.533c3a91112542f3f4713efea7f3fdbf11df91c1be825af035e47668932d69b8.css" media="all">
  </head>

  <body>
        
        <nav>
          <ul class="menu">
            
          </ul>
        </nav>
        



<h1>Tags</h1>

<ul class="terms">
  
  <li>
    <a href="/tags/centos/">centos</a> - 17
  </li>
  
  <li>
    <a href="/tags/crontab/">crontab</a> - 1
  </li>
  
  <li>
    <a href="/tags/docker/">docker</a> - 2
  </li>
  
  <li>
    <a href="/tags/firewalld/">firewalld</a> - 1
  </li>
  
  <li>
    <a href="/tags/ftp/">ftp</a> - 1
  </li>
  
  <li>
    <a href="/tags/gcc/">gcc</a> - 1
  </li>
  
  <li>
    <a href="/tags/git/">git</a> - 2
  </li>
  
  <li>
    <a href="/tags/golang/">golang</a> - 4
  </li>
  
  <li>
    <a href="/tags/iptables/">iptables</a> - 1
  </li>
  
  <li>
    <a href="/tags/jdk/">jdk</a> - 1
  </li>
  
  <li>
    <a href="/tags/kafka/">kafka</a> - 1
  </li>
  
  <li>
    <a href="/tags/laravel/">laravel</a> - 2
  </li>
  
  <li>
    <a href="/tags/linux/">linux</a> - 41
  </li>
  
  <li>
    <a href="/tags/lnmp/">LNMP</a> - 2
  </li>
  
  <li>
    <a href="/tags/lsyncd/">lsyncd</a> - 1
  </li>
  
  <li>
    <a href="/tags/mysql/">mysql</a> - 26
  </li>
  
  <li>
    <a href="/tags/nginx/">nginx</a> - 9
  </li>
  
  <li>
    <a href="/tags/nss/">nss</a> - 1
  </li>
  
  <li>
    <a href="/tags/php/">php</a> - 33
  </li>
  
  <li>
    <a href="/tags/php-fpm/">php-fpm</a> - 1
  </li>
  
  <li>
    <a href="/tags/phpstorm/">phpstorm</a> - 1
  </li>
  
  <li>
    <a href="/tags/python/">python</a> - 1
  </li>
  
  <li>
    <a href="/tags/redis/">redis</a> - 1
  </li>
  
  <li>
    <a href="/tags/samba/">samba</a> - 2
  </li>
  
  <li>
    <a href="/tags/socket/">socket</a> - 1
  </li>
  
  <li>
    <a href="/tags/sqlserver/">SQLserver</a> - 1
  </li>
  
  <li>
    <a href="/tags/ss/">ss</a> - 1
  </li>
  
  <li>
    <a href="/tags/ssh/">ssh</a> - 2
  </li>
  
  <li>
    <a href="/tags/surge/">surge</a> - 1
  </li>
  
  <li>
    <a href="/tags/ubuntu/">ubuntu</a> - 4
  </li>
  
  <li>
    <a href="/tags/vim/">vim</a> - 1
  </li>
  
  <li>
    <a href="/tags/virtualbox/">virtualbox</a> - 3
  </li>
  
  <li>
    <a href="/tags/windows/">windows</a> - 1
  </li>
  
  <li>
    <a href="/tags/yum/">yum</a> - 3
  </li>
  
  <li>
    <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a> - 1
  </li>
  
  <li>
    <a href="/tags/%E6%AD%A3%E5%88%99/">正则</a> - 2
  </li>
  
  <li>
    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> - 13
  </li>
  
</ul>

<br>



<footer>

<script defer>
  document.addEventListener("keydown", function (e) {
    if (document.activeElement.isContentEditable) {
      return false;
    }
    if (document.activeElement.tagName == "INPUT") {
      return false;
    }
    if (e.altKey || e.ctrlKey || e.shiftKey) {
      return false;
    }
    var key = e.key;
    if (key === "h") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/";
    } else if (key === "t") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/tags";
    } else if (key === "i") {
      e.preventDefault();
      e.stopPropagation();
      const inputs = document.querySelectorAll("input");
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].offsetParent !== null) {
          inputs[i].selectionStart = inputs[i].selectionEnd =
            inputs[i].value.length;
          inputs[i].focus();
          break;
        }
      }
    }
    return false;
  });
</script>


<script defer>
  function scrollHandler() {
    const anchors = Array.from(document.querySelectorAll("body h2, body h3"));

    window.addEventListener("scroll", function () {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      
      for (var i = 0; i < anchors.length; i++) {
        var anchorId = anchors[i].getAttribute("id");
        var link = document.querySelector(
          'nav ul li a[href="#' + anchorId + '"]'
        );
        if (link) {
          link.classList.remove("active-toc");
        }
      }

      
      for (var i = anchors.length - 1; i >= 0; i--) {
        var offsetTop = anchors[i].offsetTop;
        if (scrollTop > offsetTop - 75) {
          var anchorId = anchors[i].getAttribute("id");
          var link = document.querySelector(
            'nav ul li a[href="#' + anchorId + '"]'
          );
          if (link) {
            link.classList.add("active-toc");
            break;
          }
        }
      }
    });
  }
  setTimeout(scrollHandler, 100)
</script>

<script defer>
  function addCopyButtonToCodeBlocks() {
    
    const codeBlocks = document.querySelectorAll('code[class^="language-"]');

    codeBlocks.forEach((codeBlock) => {
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-code-button");
      copyButton.innerHTML = "copy";

      
      copyButton.addEventListener("click", () => {
        
        const elements = codeBlock.querySelectorAll(".cl");
        let codeToCopy = "";
        elements.forEach((element) => {
          codeToCopy += element.innerText;
        });
        navigator.clipboard.writeText(codeToCopy);

        
        copyButton.innerHTML = "copied!";
        setTimeout(() => {
          copyButton.innerHTML = "copy";
        }, 1500);
      });

      
      codeBlock.parentNode.before(copyButton);
    });
  }
  setTimeout(function () {
    addCopyButtonToCodeBlocks();
  }, 100);
</script>

<script>
window.store = {
    
    "http:\/\/zhaoguibin.me\/tags\/php\/": {
        "title": "php",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/php\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/": {
        "title": "Posts",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/posts\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/": {
        "title": "Tags",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/"
    },
    
    "http:\/\/zhaoguibin.me\/": {
        "title": "个人笔记",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E5%9B%BE%E7%89%87%E8%BD%ACbase64\/": {
        "title": "图片转base64",
        "tags": ["php",],
        "content": "\u0026lt;?php /** * Describe: 图片转base64 * 使用方法: php imgtobase64.php path=/www/projects/test/20220623171931.png * Author: ZhaoGuibin * Date: 2022-06-23 */ class ImgToBase64 { static private $instance; private function __construct() { } static public function getInstance() { if (!self::$instance instanceof self) { self::$instance = new self(); } return self::$instance; } /** * 获取命令行输入参数 * @return array */ function getClientArgs() { global $argv; array_shift($argv); $args = array(); array_walk($argv, function ($v, $k) use (\u0026amp;$args) { @list($key, $value) = @explode(\u0026#39;=\u0026#39;, $v); $args[$key] = $value; }); return $args; } /** * 图片转为base64 * @param $img_path * @return string|void */ function imgToBase64($img_path = \u0026#39;\u0026#39;) { $img = isset($img_path[\u0026#39;path\u0026#39;]) ? $img_path[\u0026#39;path\u0026#39;] : \u0026#39;\u0026#39;; if (!$img) { return \u0026#39;图片不存在或图片路径不正确\u0026#39;; } if ($fp = fopen($img, \u0026#34;rb\u0026#34;, 0)) { $image = fread($fp, filesize($img)); fclose($fp); $base64 = chunk_split(base64_encode($image)); // 输出 $encode = \u0026#39;data:image/jpg/png/gif;base64,\u0026#39; . $base64; echo $encode; } } private function __clone() { } } $img_path = ImgToBase64::getInstance()-\u0026gt;getClientArgs(); ImgToBase64::getInstance()-\u0026gt;imgToBase64($img_path); ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E5%9B%BE%E7%89%87%E8%BD%ACbase64\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\/": {
        "title": "设计模式",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F\/": {
        "title": "迭代器模式",
        "tags": ["php","设计模式",],
        "content": " 概念\n迭代器模式是遍历集合的成熟模式，迭代器模式的关键是将遍历集合的任务交给一个叫做迭代器的对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该集合序列底层的结构。\n说明\n迭代器模式（Iterator），又叫做游标（Cursor）模式，提供一种方法访问一个容器（Container）对象中各个元素，而又不需要暴露该对象的内部细节。 当你需要访问一个聚合对象，而且不管这些对象是什么都需要遍历的时候，就应该考虑使用迭代器模式。另外，当需要对聚集有多种方式遍历时，可以考虑去使用迭代器模式。迭代器模式为遍历不同的聚合结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。 作用 我们想要像遍历数组那样，遍历对象，或是遍历一个容器。 迭代器模式可以隐藏遍历元素所需的操作 应用场景 访问一个聚合对象的内容而无需暴露它的内部表示 支持对聚合对象的多种遍历 为遍历不同的聚合结构提供一个统一的接口。 角色 Iterator（迭代器）：迭代器定义访问和遍历元素的接口 ConcreteIterator（具体迭代器）：具体迭代器实现迭代接口，对该聚合遍历时跟踪当前位置 Aggregate（聚合）：聚合定义创建相应迭代器对象的接口。 ConcreteAggregate（具体聚合）：具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。 \u0026lt;?php //自定义迭代器实现系统定义迭代器接口 class MyIterator implements Iterator { protected $data = []; protected $index; public function __construct($data) { $this-\u0026gt;data = $data; $this-\u0026gt;index = 0; } //返回第一个元素 public function rewind() { $this-\u0026gt;index = 0; } //下一个元素 public function next() { $this-\u0026gt;index++; } //验证是否继续 public function valid() { return $this-\u0026gt;index \u0026lt; count($this-\u0026gt;data); } //返回key值 public function key() { return $this-\u0026gt;index; } //返回当前元素 public function current() { return $this-\u0026gt;data[$this-\u0026gt;index]; } } $arr = [1, 2, 3, 4, 5, 6]; $iterate = new MyIterator($arr); foreach ($iterate as $dynasty) { echo \u0026#39;the obj == \u0026#39; . $dynasty; } ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\/": {
        "title": "命令模式",
        "tags": ["php","设计模式",],
        "content": " 概念 将一个请求封装（命令的封装）为一个对象，从而使用你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分隔开，委派给不同的对象。 请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。 角色 命令（command）角色：声明了一个给所有具体命令类的抽象接口。这是一个抽象角色。 具体命令（ConcreteCommand）角色：定义一个接收者和行为之间的弱耦合；实现Execute()方法，负责调用接收到的相应操作。Execute()方法通常叫做执行方法。 客户（client）角色：创建了一个具体命令（ConcreteCommand）对象并确定其接收者。 请求者（Invoker）角色：负责调用命令对象执行请求，相关的方法叫做行动方法。 接收者（Receiver）角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。 优点和缺点 优点： 命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分离开。 命令类与其他任何别的类一样，可以修改和推广。 可以把命令对象聚合在一起，合成为合成命令。 可以很容易的加入新的命令类。 缺点： 可能会导致某些系统有过多的具体命令类。 应用场景 抽象出待执行的动作以参数化对象。Command模式是回调机制的一个面向对象的替代品。 在不同的时刻指定、排列和执行请求。 支持取消操作 支持修改日志 用构建在原语操作上的高层操作构建一个系统。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。 \u0026lt;?php //抽象命令接口 interface Command { //命令执行 public function execute(); } //宏命令（命令的组合） //宏命令接口 interface MacroCommand extends Command { //宏命令聚集管理方法，可以删除一个命令 public function remove(Command $command); //宏命令聚集管理方法，可以添加一个命令 public function add(Command $command); } //命令的实现 //复制命令 class CopyCommand implements Command { private $receiver; public function __construct(Receiver $receiver) { $this-\u0026gt;receiver = $receiver; } public function execute() { $this-\u0026gt;receiver-\u0026gt;copy(); } } //粘贴命令 class PasteCommand implements Command { private $receiver; public function __construct(Receiver $receiver) { $this-\u0026gt;receiver = $receiver; } public function execute() { $this-\u0026gt;receiver-\u0026gt;paste(); } } //命令接收者执行命令 class Receiver { private $name; public function __construct($name) { $this-\u0026gt;name = $name; } public function copy() { echo $this-\u0026gt;name . \u0026#39;执行copy命令\u0026#39;; } public function paste() { echo $this-\u0026gt;name . \u0026#39;执行paste命令\u0026#39;; } } //命令请求者，用于发送请求 class Invoker { private $command; public function __construct(Command $command) { $this-\u0026gt;command = $command; } public function action() { $this-\u0026gt;command-\u0026gt;execute(); } } //实现宏命令 class TestMacroCommand implements MacroCommand { private $commands; public function __construct() { $this-\u0026gt;commands = []; } //宏命令聚集管理方法，可以删除一个命令 public function remove(Command $command) { $index = array_search($command, $this-\u0026gt;commands); if ($index === false) { return false; } else { unset($this-\u0026gt;commands[$index]); return true; } } //宏命令聚集管理方法，可以添加一个命令 public function add(Command $command) { return array_push($this-\u0026gt;commands, $command); } public function execute() { if (!is_array($this-\u0026gt;commands)) { return false; } else { foreach ($this-\u0026gt;commands as $command) { //通知改变 $command-\u0026gt;execute(); } } return true; } } //客户端 $receiver = new Receiver(\u0026#39;gd\u0026#39;); $copy_command = new CopyCommand($receiver); $paste_command = new PasteCommand($receiver); //添加命令到宏命令 $macro_command = new TestMacroCommand(); $macro_command-\u0026gt;add($copy_command); $macro_command-\u0026gt;add($paste_command); $invoker = new Invoker($macro_command); $invoker-\u0026gt;action(); ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\/": {
        "title": "观察者模式",
        "tags": ["php","设计模式",],
        "content": " 概念 观察者模式属于行为模式，是定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。 当一个对象状态发生改变后，会影响到其他几个对象的改变，这时候可以用观察者模式。 观察者模式符合接口隔离原则，实现了对象之间的松散耦合。 角色 抽象主题（subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。 具体主题（ConcreteSubjest）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。 抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。 具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。 \u0026lt;?php //抽象主题 interface Subject { //新增观察者 public function attach(Observer $observer); //移除观察者 public function detach(Observer $observer); //通知观察者 public function notifyObserver(); } //具体主题 class ConcreteSubjest implements Subject { //储存观察者 private $observers; public function __construct() { $this-\u0026gt;observers = []; } //新增观察者 public function attach(Observer $observer) { return array_push($this-\u0026gt;observers, $observer); } //移除观察者 public function detach(Observer $observer) { //检查观察者是否存在观察者数组中，返回索引值 $index = array_search($observer, $this-\u0026gt;observers); if ($index === false) { return false; } else { unset($this-\u0026gt;observers[$index]); return true; } } //通知观察者 public function notifyObserver() { if (!is_array($this-\u0026gt;observers)) { return false; } else { foreach ($this-\u0026gt;observers as $observer) { //通知改变 $observer-\u0026gt;update(); } } return true; } } //抽象观察者 interface Observer { //观察者状态改变 public function update(); } //具体观察者 class ConcreteServer implements Observer { private $name; public function __construct($name) { $this-\u0026gt;name = $name; } public function update() { echo \u0026#34;观察者\u0026#34; . $this-\u0026gt;name . \u0026#39;已经通知\u0026#39;; } } //注册观察者、监听 $subject = new ConcreteSubjest(); $subject-\u0026gt;attach(new ConcreteServer(\u0026#39;one\u0026#39;)); $subject-\u0026gt;attach(new ConcreteServer(\u0026#39;two\u0026#39;)); $subject-\u0026gt;attach(new ConcreteServer(\u0026#39;three\u0026#39;)); $subject-\u0026gt;notifyObserver(); ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\/": {
        "title": "策略模式",
        "tags": ["php","设计模式",],
        "content": " 概念 将一组特定的行为和算法封装成类，以适应某些特定的上下文环境，并让它们可以相互替换，这种模式就是策略模式。 简单理解就是 有n个做法供你选择，根据你的需要选择某个策略得到结果 优点 使用设计模式之后，我们的代码冗余和耦合度变低，每个策略模块完成对应的功能。 当然缺点就是一个功能我们就要响应制作一个策略类，但是我们统观MVC架构当中（Thinkphp，Yii2），一个控制器对应一个视图，其实也是策略模式的体现了。 \u0026lt;?php interface UserInterface { public function showAd(); public function showCategory(); } //男性用户实现接口 class MaleUser implements UserInterface { public function showAd() { echo \u0026#39;电子产品\u0026#39;; } public function showCategory() { echo \u0026#34;PS5,PC,Switch\u0026#34;; } } //女性用户实现接口 class FemaleUser implements UserInterface { public function showAd() { echo \u0026#39;化妆品\u0026#39;; } public function showCategory() { echo \u0026#34;口红,面膜\u0026#34;; } } //客户端实现，根据性别不同推荐不同内容 $sex = \u0026#39;male\u0026#39;; if ($sex == \u0026#39;male\u0026#39;) { $user = new MaleUser(); } else { $user = new FemaleUser(); } $user-\u0026gt;showAd(); $user-\u0026gt;showCategory(); ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F\/": {
        "title": "装饰器模式",
        "tags": ["php","设计模式",],
        "content": " 概念\n装饰器模式又叫装饰者模式。装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。\n实例\n组件对象的接口：可以给这些对象动态的添加职责 所有装饰器的父类：需要定义一个与组件接口一直的接口，并持有一个component对象，该对象其实就是被装饰的对象。 具体的装饰器类：实现具体要向被装饰对象添加的功能。用来装饰具体的组件对象或者另外一个具体的装饰器对象。 使用场景\n需要动态的给一个对象添加功能，这些功能可以再动态的撤销 需要添加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。 \u0026lt;?php //组件对象接口 interface IComponent { //动态给对象添加功能 public function display(); } //待装饰的对象 class Person implements IComponent { protected $name; public function __construct($name) { $this-\u0026gt;name = $name; } public function display() { echo \u0026#39;装饰的\u0026#39; . $this-\u0026gt;name; } } //所有装饰器的父类 class Clothes implements IComponent { protected $component; public function Decorate(IComponent $component) { $this-\u0026gt;component = $component; } public function display() { if (!empty($this-\u0026gt;component)) { $this-\u0026gt;component-\u0026gt;display(); } } } //具体的装饰器 class Pixie extends Clothes { public function display() { echo \u0026#39;皮鞋\u0026#39;; parent::display(); } } class Waitao extends Clothes { public function display() { echo \u0026#39;外套\u0026#39;; parent::display(); } } //客户端 $gd = new Person(\u0026#39;狗蛋\u0026#39;); $px = new Pixie(); $px-\u0026gt;Decorate($gd); $px-\u0026gt;display(); $wt = new Waitao(); $wt-\u0026gt;Decorate($gd); $wt-\u0026gt;display(); ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E6%B3%A8%E5%86%8C%E6%A0%91%E6%A8%A1%E5%BC%8F\/": {
        "title": "注册树模式",
        "tags": ["php","设计模式",],
        "content": " 概念\n注册树模式也叫注册模式或注册器模式，顾名思义，注册树就是把对象实例注册到一棵全局的对象树上，需要对象的时候就从树上取下来，就好比树上长的果子，需要的时候就摘一个下来，只是这个对象树果子是摘不完的。\n作用\n不管是单例模式还是工厂模式建立的对象，都没有得到很好的管理，用了注册树模式，就可以把创建出来的对象注册到全局树上，需要的时候取下来用，可以很好的管理创建的对象。\n\u0026lt;?php class DbMysql { public function conn() { echo \u0026#39;mysql conn\u0026#39;; } } class DbSqlite { public function conn() { echo \u0026#39;sqlite conn\u0026#39;; } } class MysqlFactory { public static function getIns() { return new DbMysql(); } } class SqliteFactory { public static function getIns() { return new DbSqlite(); } } //注册树实现存储对象（IOC控制反转思想） class RegisterTree { protected static $objects; //添加对象到注册树中 public static function set($alias, $object) { self::$objects[$alias] = $object; } //从注册树中获取对象 public static function get($alias) { return self::$objects[$alias]; } //销毁注册树上的对象 public static function _unset($alias) { unset(self::$objects[$alias]); } } //注册 RegisterTree::set(\u0026#39;mysql\u0026#39;, MysqlFactory::getIns()); RegisterTree::set(\u0026#39;sqlite\u0026#39;, SqliteFactory::getIns()); //客户端 // $mysql = RegisterTree::get(\u0026#39;mysql\u0026#39;); // $mysql-\u0026gt;conn(); // $sqlite = RegisterTree::get(\u0026#39;sqlite\u0026#39;); // $sqlite-\u0026gt;conn(); class Facade { public static $mysql; public static $sqlite; public function __construct() { self::$mysql = RegisterTree::get(\u0026#39;mysql\u0026#39;); self::$sqlite = RegisterTree::get(\u0026#39;sqlite\u0026#39;); } } new Facade(); Facade::$mysql-\u0026gt;conn(); Facade::$sqlite-\u0026gt;conn(); ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E6%B3%A8%E5%86%8C%E6%A0%91%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F\/": {
        "title": "门面模式",
        "tags": ["php","设计模式",],
        "content": " 概念\n门面模式（facade）又称外观模式，用于为子系统中的一组接口提供一个一致的界面。门面模式定义了一个高层接口，这个接口使得子系统更加容易使用；引入门面角色之后，用户只需要直接与门面角色交互，用户与子系统之间的复杂关系由门面角色来实现，从而降低了系统的耦合度。\n作用\n为一些复杂的子系统提供一组接口。 提高子系统的独立性 在层次化结构中，可以使用门面模式定义系统的每一层的接口 优点\n它对于客户屏蔽了子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。 实现了子系统与客户之间的松耦合关系。 如果应用需要，它并不限制它们使用子系统类。因此可以在系统易用性与能用性之间加以选择。 \u0026lt;?php class Camera { public function turnOn() { echo \u0026#39;turn on camera\u0026#39;; } public function turnOff() { echo \u0026#39;turn off camera\u0026#39;; } } class Light { public function turnOn() { echo \u0026#39;turn on light\u0026#39;; } public function turnOff() { echo \u0026#39;turn off light\u0026#39;; } } //门面类 class Facade { private $camera; private $light; public function __construct() { $this-\u0026gt;camera = new Camera(); $this-\u0026gt;light = new Light(); } //启动接口 public function activate() { $this-\u0026gt;camera-\u0026gt;turnOn(); $this-\u0026gt;light-\u0026gt;turnOn(); } //关闭接口 public function deactivate() { $this-\u0026gt;camera-\u0026gt;turnOff(); $this-\u0026gt;light-\u0026gt;turnOff(); } } //客户端 class Client { private static $securit; public static function main() { self::$securit = new Facade(); self::$securit-\u0026gt;activate(); self::$securit-\u0026gt;deactivate(); } } Client::main(); ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F\/": {
        "title": "管道模式",
        "tags": ["php","设计模式",],
        "content": " 概念\n管道（pipeline）设计模式流水线模式就是将数据传递到一个任务序列中，管道扮演着流水线的角色，数据在这里被处理然后传递到下一个步骤\n释义\n管道，顾名思义，就是一个长长的流水管道，只不过加了许多阀门。所以管道模式大致需要三个角色：管道、阀门、载荷（流水）。\n目的是在管道中对载荷进行一系列的处理。因为可以对过滤器进行动态的添加，所以对载荷的处理可以变得更加灵活。但同时带来的问题是，在过滤器过多时，很难把握整体的处理逻辑。而且在某一个过滤器对载荷处理后，因为载荷改变，会造成下一个过滤器中的逻辑出错。\n\u0026lt;?php //管道接口 interface PipelineBuilder { public function __construct($payload); //$payload载荷 public function pipe(StageBuilder $stage); //管道与阀门 public function process(); //过程 } //实现管道接口 class Pipeline implements PipelineBuilder { protected $payload; protected $pipes = []; public function __construct($payload) { $this-\u0026gt;payload = $payload; } public function pipe(StageBuilder $stage) { $this-\u0026gt;pipes[] = $stage; return $this; } public function process() { foreach ($this-\u0026gt;pipes as $pipe) { call_user_func([$pipe, \u0026#39;handle\u0026#39;], $this-\u0026gt;payload); } } } //阀门类 interface StageBuilder { public function handle($payload); } //实现 class StageOneBuilder implements StageBuilder { public function handle($payload) { echo \u0026#39;one-\u0026#39;; } } class StageTwoBuilder implements StageBuilder { public function handle($payload) { echo \u0026#39;two-\u0026#39;; } } //客户端使用 $pipeline = new PipeLine(\u0026#39;step\u0026#39;); $pipeline-\u0026gt;pipe(new StageOneBuilder())-\u0026gt;pipe(new StageTwoBuilder())-\u0026gt;process(); ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\/": {
        "title": "代理模式",
        "tags": ["php","设计模式",],
        "content": " 概念\n构建了透明置于两个不同对象之内的一个对象，从而能够截取或代理这两个对象间的通信或访问。\n应用场景\n远程代理：也就是为了一个对象在不同地址空间提供局部代表。隐藏一个对象存在于不同地址空间的事实。 虚拟代理：根据需求来创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象。 安全代理：用来控制真实对象的访问对象。 智能指引：当调用真实对象的时候，代理处理一些事情。 \u0026lt;?php //真实类 interface Subject { public function request(); } class RealSubject implements Subject { public function request() { echo \u0026#39;真实的操作\u0026#39;; } } //代理模式代理真实类 class Proxy implements Subject { protected $realSubject; public function __construct() { $this-\u0026gt;realSubject = new RealSubject(); } public function request() { echo \u0026#39;代理操作\u0026#39;; $this-\u0026gt;realSubject-\u0026gt;request(); } } //客户端 $proxy = new Proxy(); $proxy-\u0026gt;request(); 注意事项 代理模式的实现其实非常简单，或许你在不经意间经常会用到 请注意代理模式与装饰器、适配器的区别 装饰器：一般是对对象进行装饰，其中的方法行为会有增加，以修饰对象为主 适配器：一般会改变方法行为，目的是保持接口的统一但得到不同的实现 代理模式有几种形式：远程代理（例如：第三方接口SDK）、虚代理（例如：异步加载图片）、保护代理\u0026amp;智能指引（例如：权限保护），而我们代码实现的最普通的代理，其实就是让代理类来代替真实类的操作 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\/": {
        "title": "适配器模式",
        "tags": ["php","设计模式",],
        "content": " 概念\n将某个类的接口转换成与另一个接口兼容。适配器通过将原始接口进行转换，给用户提供一个兼容接口，使得原来因为接口不同而无法一起使用的类可以得到兼容。\n应用场景\n老代码接口不适应新的接口需求，或者代码很多很乱不便于继续修改，或者使用第三方类库。\n\u0026lt;?php interface Weather { public function show(); } class PhpWeather implements Weather { public function show() { $weatherInfo = [\u0026#39;weather\u0026#39; =\u0026gt; \u0026#39;雨\u0026#39;, \u0026#39;tep\u0026#39; =\u0026gt; 6, \u0026#39;wind\u0026#39; =\u0026gt; 3]; return serialize($weatherInfo); } } //兼容模式 使得java能够直接使用 interface WeatherA { public function getWeather(); } class JavaWeather implements WeatherA { protected $weather; public function __construct(Weather $weather) { $this-\u0026gt;weather = $weather; } public function getWeather() { $info = unserialize($this-\u0026gt;weather-\u0026gt;show()); return json_encode($info); } } $weather = new PhpWeather(); // $info = unserialize($weather); // var_dump($info); $java_weather = new JavaWeather($weather); $info = json_decode($java_weather-\u0026gt;getWeather()); var_dump($info); ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\/": {
        "title": "工厂模式",
        "tags": ["php","设计模式",],
        "content": " 概念\n工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。\n好处\n使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需要更改该工厂方法内容即可，不需要逐一寻找代码中具体实例化的地方（new 处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。\n分类\n简单工厂模式 工厂方法模式 抽象工厂模式 简单工厂模式\n简单工厂模式又称静态工厂模式，之所以可以这么说，是因为简单工厂模式是通过一个静态方法来创建对象的\n\u0026lt;?php class DbMysql { public function conn() { echo \u0026#34;连接MySQL\u0026#34;; } } class DbSqlite { public function conn() { echo \u0026#34;连接SQLite\u0026#34;; } } class DbFactory { public static function createIns($type) { switch ($type) { case \u0026#39;mysql\u0026#39;: return DbMysql(); break; case \u0026#39;sqlite\u0026#39;: return new DbSqlite(); break; default: throw new ErrorException(\u0026#39;类型错误\u0026#39;); } } } $mysql = DbFactory::createIns(\u0026#39;mysql\u0026#39;); $mysql-\u0026gt;conn(); $sqlite = DbFactory::createIns(\u0026#39;sqlite\u0026#39;); $sqlite-\u0026gt;conn(); 工厂方法模式\n简单工厂模式实现了产品类的代码跟客户端代码的分离，但会有一个问题，优秀的代码是符合“开闭原则”如果你要加一个C类产品，你就要修改工厂类里面的代码，也就是说要增加条件语句如：switch\u0026ndash;case。对于这个问题，接下来的工厂方法模式可以解决这个问题。\n概念\n工厂方法就是为配一个产品提供一个独立的工厂类，通过不同的工厂实例来创建不同的产品实例。\n优点\n拥有良好的封装性，代码结构清晰，对于每一个对象的创建都是有条件约束的。如：调用一个具体的产品对象，只需要知道这个产品的类名和约束参数就可以了，不用知道创建对象自身的复杂过程。降低模块之间的耦合度。 拥有良好的扩展性，新增一个产品类，只需要适当的增加工厂类或者扩展一个工厂类，如下面的例子中，当需要增加一个数据库Oracle的操作，则只需要增加一个Oracle类，工厂类不用修改任务就可完成系统扩展。 屏蔽产品类，这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。 使用场景\n支付宝、微信、银联的连接方式（connectMode），支付方式（payMode）。使用工厂模式，“客户”就不需要知道具体的链接方式和支付方式了，只需要调用connectMode和payMode即可。 MySQL、SQL Server、Oracle等数据库的连接方式（connectMode）、查询方式（selectMode）等操作可以使用工厂模式进行封装。 \u0026lt;?php //数据库操作接口 interface Db { public function conn(); } class DbMysql implements Db { public function conn() { echo \u0026#34;链接MySQL\u0026#34;; } } class DbSqlite implements Db { public function conn() { echo \u0026#34;连接SQLite\u0026#34;; } } //工厂接口 interface Factory { public static function createIns(); } class MysqlFactory implements Factory { public static function createIns() { return new DbMysql(); } } class SqliteFactory implements Factory { public static function createIns() { return new DbSqlite(); } } //客户端 $mysql = MysqlFactory::createIns(); $mysql-\u0026gt;conn(); $sqlite = SqliteFactory::createIns(); $sqlite-\u0026gt;conn(); 抽象工厂模式\n概念\n抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象，而且使用抽象工厂模式还要满足以下条件：\n系统中有多个产品族，而系统一次只可能消费其中一族产品 同属于同一产品族的产品可以使用 产品族：位于不同产品等级结构中，功能相关联的产品组成的家族。下面例子的汽车和空调就是两个产品树，奔驰C200+格力某型号空调就是一个产品族，同理，奥迪A4+海尔某型号空调也是一个产品族。 \u0026lt;?php //汽车（抽象产品接口） interface AutoProduct { public function dirve(); } class AudiA4Product implements AutoProduct { public function dirve() { echo \u0026#39;奥迪A4\u0026#39;; } } class BenzC200Product implements AutoProduct { public function dirve() { echo \u0026#39;奔驰C200\u0026#39;; } } //空调(抽象产品接口) interface AirCondition { public function blow(); } class GreeAirCondition implements AirCondition { public function blow() { echo \u0026#39;格力\u0026#39;; } } class HaierAirCondition implements AirCondition { public function blow() { echo \u0026#39;海尔\u0026#39;; } } //工厂接口 interface Factory { public static function getAuto(); public static function getAirCondition(); } //工厂A 奥迪A4+海尔空调 class AFactory implements Factory { public static function getAuto() { return new AudiA4Product(); } public static function getAirCondition() { return new HaierAirCondition(); } } //工厂B 奔驰+格力 class BFactory implements Factory { public static function getAuto() { return new BenzC200Product(); } public static function getAirCondition() { return new GreeAirCondition(); } } //客户端 //A工厂制作车 $auto_carA = AFactory::getAuto(); $auto_airA = AFactory::getAirCondition(); //奥迪+空调 $auto_carA-\u0026gt;dirve(); $auto_airA-\u0026gt;blow(); 三种工厂模式的比较\n简单工厂：用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力） 工厂方法：用来生产同一等级结构中的固定产品。（支持增加任意产品） 抽象工厂：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族） ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\/": {
        "title": "单例模式",
        "tags": ["php","设计模式",],
        "content": " 概念\n是一种类的设计只会最多产生一个对象的设计思想\n作用\nphp的应用主要在于数据库应用，所以一个应用中会存在大量的数据库操作，使用单例模式，则可以避免大量的new操作消耗的资源。 如果系统中需要有一个类来全局控制某些配置信息，那么使用单例模式可以很方便的实现。 再一次页面请求中，便于进行调试，因为所有的代码都会集中在一个类里面，我们可以在类中设置钩子，输出日志，从而避免到处var_dump，echo。 应用场景\n数据库连接，缓存操作，分布式储存\n单例模式的要点\n构造函数需要标记为private（访问控制：防止外部代码使用new操作符创建对象），单例类不能在其他类中实例化，只能被其自身实例化。 拥有一个保存类的实例的静态成员变量。 拥有一个访问这个实例的公共的静态方法（常用getInstance()方法进行实例化单例类，通过instanceof操作符可以检测到类是否已经被实例化） 简称 三私一公： 私有化构造方法：不让在外部产生多个对象 私有化克隆方法：不允许对象被克隆产生新对象 私有化静态属性：运行进入类内部产生对象 公有化静态方法：保存已经产生的对象 \u0026lt;?php //单例 class Uni{ //创建静态私有的变量保存该类对象 static private $instance; //参数 private $config; //防止直接创建对象 private function __construct($config){ $this -\u0026gt; config = $config; echo \u0026#34;我被实例化了\u0026#34;; } //防止克隆对象 private function __clone(){ } static public function getInstance($config){ //判断$instance是否是Uni的对象 //没有则创建 if (!self::$instance instanceof self) { self::$instance = new self($config); } return self::$instance; } public function getName(){ echo $this -\u0026gt; config; } } $db1 = Uni::getInstance(1); $db1 -\u0026gt; getName(); echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; $db2 = Uni::getInstance(4); $db2 -\u0026gt; getName(); /** *运行结果： *我被实例化了1 *1 *$db1创建对象后，参数是1 *$db2没有创建对象，而是直接使用$instance保存的唯一对象，所以输出的参数并没有变为4； */ ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\/": {
        "title": "什么是设计模式",
        "tags": ["php","设计模式",],
        "content": " 什么是设计模式\n设计模式是一套被反复使用、容易被他人理解的、可靠的代码设计经验的总结。\n那么我们常说的架构、框架和设计模式有什么关系呢？\n架构是一套体系结构，是项目的整体解决方案； 框架是可供复用的半成品软件，是具体程序代码。 架构一般会涉及到采用什么样的框架来加速和优化某部分问题的解决，而好的框架代码里合理使用了很多设计模式。 比如：laravel框架中就使用到了很多的设计模式。其中包括单例模式，门面模式，注册树模式（DI/IOC），适配器模式，观察者模式等多种设计模式。\n设计模式的目的是为了更好的代码重用性，可读性，可靠性，可维护性。\n设计模式的作用\n设计模式能解决：\n替换杂乱无章的代码，形成良好的代码风格 代码易读，工程师们都能很容易理解 增加新功能时不用修改接口，可扩展性强 稳定性好，一般不会出现未知的问题 设计模式不能解决：\n设计模式是用来组织你的代码的模板，而不是直接调用的库 设计模式并非最高效，但是代码的可读性和可维护性更重要 不要一味追求并套用设计模式，重构时多考虑 设计模式\u0026ndash;六大原则\n单一职责原则\n定义\n不要存在多于一个导致类变更的原因。既一个类只负责一项职责。\n场景\n类T负责两个不同的职责；职责P1，职责P2，当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。\n\u0026lt;?php class Animal { public function bre($animal) { echo $animal.\u0026#34;呼吸空气\u0026#34;; } } class Program { public function main() { $animal = new Animal(); $animal-\u0026gt;bre(\u0026#39;猫\u0026#39;); $animal-\u0026gt;bre(\u0026#39;狗\u0026#39;); $animal-\u0026gt;bre(\u0026#39;鱼\u0026#39;); } } 修正\n遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。\n\u0026lt;?php class Ter { public function bre($animal) { echo $animal.\u0026#34;呼吸空气\u0026#34;; } } class Aqu { public function bre($animal) { echo $animal.\u0026#34;呼吸水\u0026#34;; } } class Program { public function main() { $ter = new Ter(); $ter-\u0026gt;bre(\u0026#39;猫\u0026#39;); $ter-\u0026gt;bre(\u0026#39;狗\u0026#39;); $aqu = new Aqu(); $aqu-\u0026gt;bre(\u0026#39;鱼\u0026#39;); } } 优点\n可以降低类的复杂度，一个类只负责一项职责，逻辑简单； 提高类的可读性，提高系统的可维护性 变更引起的风险降低，变更时必然的。 里氏替换原则\n定义\n所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类可以扩展父类的功能，但不能改变父类原有的功能\n场景\n有一个功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。\n\u0026lt;?php class A { public function sub($a, $b) { return $a-$b; } } class B { public function main() { $class = new C(); echo $class-\u0026gt;sub(100,50); echo $class-\u0026gt;sub(90,40); } } class C extends A { public function sub($a, $b) { return $a+$b; } public function qua($a, $b) { return $this-\u0026gt;sub($a, $b)*100; } } $b = new B(); $b-\u0026gt;main(); \u0026lt;?php //修正 abstract class D { public abstract function sub($a, $b); public abstract function qua($a, $b) { return $this-\u0026gt;sub($a, $b)*100; } } //通过子类继承实现抽象方法达到扩展目的 class A extends D { public function sub($a, $b) { return $a - $b; } } class B extends D { public function sub($a, $b) { return $a + $b; } } 依赖倒置原则\n定义\n高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。\n场景\n类A（高层模块）直接依赖类B（低层模块），假如要将类A改为依赖类C（低层模块），则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。\n修正\n将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。\n\u0026lt;?php class Book { public function getContent() { return \u0026#39;hello world\u0026#39;; } } class NewsPaper { public function getContent() { return \u0026#39;new day\u0026#39;; } } class Mother { public function narrate(Book $book) { echo $book-\u0026gt;getContent(); } } $m = new Mother(); $m-\u0026gt;narrate(new Book()); //修正 interface IReader { public function getContent(); } class Book1 implements IReader { public function getContent() { return \u0026#39;hello world\u0026#39;; } } class NewsPaper1 implements IReader { public function getContent() { return \u0026#39;new day\u0026#39;; } } class Mother1 { public function narrate(IReader $ireader) { echo $ireader-\u0026gt;getContent(); } } $m1 = new Mother1(); $m1-\u0026gt;narrate(new Book1()); $m1-\u0026gt;narrate(new NewsPaper1()); 优点\n低层模块尽量都要有抽象类或者接口，或者两者都有 变量的声明类型尽量是抽象类或接口 使用继承时遵循里氏替换原则 接口隔离原则\n定义\n客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。\n场景\n类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须趣实现他们不需要的方法。\n修正\n将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。\n\u0026lt;?php interface I { public function method1(); public function method2(); public function method3(); public function method4(); public function method5(); } class A { public function depend1(I $i) { $i-\u0026gt;method1(); } public function depend2(I $i) { $i-\u0026gt;method2(); } public function depend3(I $i) { $i-\u0026gt;method3(); } } class C { public function depend1(I $i) { $i-\u0026gt;method4(); } public function depend2(I $i) { $i-\u0026gt;method5(); } } class B implements I { public function method1() { } public function method2() { } public function method3() { } public function method4() { } public function method5() { } } class D implements I { public function method1() { } public function method2() { } public function method3() { } public function method4() { } public function method5() { } } $a = new A(); $b = new B(); $c = new C(); $d = new D(); $a-\u0026gt;depend1($b); $a-\u0026gt;depend2($b); $a-\u0026gt;depend3($b); $c-\u0026gt;depend1($d); $c-\u0026gt;depend2($d); #----------------------修正--------------------- class A1 { public function depend1(IA $ia) { $ia-\u0026gt;method1(); } public function depend2(IA $ia) { $ia-\u0026gt;method2(); } public function depend3(IA $ia) { $ia-\u0026gt;method3(); } } class C1 { public function depend1(IC $ic) { $ic-\u0026gt;method4(); } public function depend2(IC $ic) { $ic-\u0026gt;method5(); } } interface IA { public function method1(); public function method2(); public function method3(); } interface IC { public function method4(); public function method5(); } class B1 implements IA { public function method1() { } public function method2() { } public function method3() { } } class D1 implements IC { public function method4() { } public function method5() { } } $a1 = new A1(); $b1 = new B1(); $c1 = new C1(); $d1 = new D1(); $a1-\u0026gt;depend1($b1); $a1-\u0026gt;depend2($b1); $a1-\u0026gt;depend3($b1); $c1-\u0026gt;depend1($d1); $c1-\u0026gt;depend2($d1); 接口隔离原则和单一职责原则的区别\n单一职责原则是注重这个类的职责，而接口隔离原则注重对接口依赖的隔离 单一职责约束的是类，其次是方法，针对的是程序中的实现和细节，而接口隔离原则约束的是接口，是抽象，是程序框架整体的构建。 迪米特原则\n定义\n一个对象应该对其他对象保持最少的了解。（最少知道原则）\n场景\n类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 简单的理解就是高内聚低耦合，一个类尽量减少对其他对象的依赖，并且这个类的方法和属性能用私有的就尽量私有化。 说明： 高内聚：尽可能类的每个成员方法只完成一件事（最大限度的聚合） 低耦合：减少类内部，一个成员方法调用另一个成员方法（包括对其他类的调用） \u0026lt;?php class Test { public function getAll() { $arr = []; for($i = 0; $i \u0026lt; 10; $i++){ $arr[] = $i; } return $arr; } } class Dev { public function getAll(Test $test) { for($i = 0; $i \u0026lt; 10; $i++){ echo $i.\u0026#39;dev\u0026#39;; } $arr = $test-\u0026gt;getAll(); foreach($arr as $val){ echo $val.\u0026#39;test\u0026#39;; } } } $dev = new Dev(); $dev-\u0026gt;getAll(new Test()); #----------------修正----------------- class Test { public function getAll() { $arr = []; for($i = 0; $i \u0026lt; 10; $i++){ $arr[] = $i; } foreach($arr as $val){ echo $val.\u0026#39;test\u0026#39;; } } } class Dev { public function getAll(Test $test) { for($i = 0; $i \u0026lt; 10; $i++){ echo $i.\u0026#39;dev\u0026#39;; } $arr = $test-\u0026gt;getAll(); } } $dev = new Dev(); $dev-\u0026gt;getAll(new Test()); 开闭原则\n定义\n一个软件实例如类、模块和函数应该对扩展开放，对修改关闭。\n场景\n在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。\n这六大原则任何面向对象的语言都应该遵守\n设计模式分类\n创建型模式：\n概念：创建型模式的一个总要的思想其实就是封装，利用封装，把直接获得一个对象改为通过一个接口获得一个对象。\n单例模式、工厂模式（简单工厂、工厂方法、抽象工厂）\n结构型模式：\n概念：解析类和对象的内部结构和外部组合，通过优化程序结构解决模块之间的耦合问题。\n适配器模式、门面模式、装饰器模式、注册树模式(IOC/DI)、代理模式、管道模式\n行为型模式：\n概念：行为型模式用于描述程序在运行时复杂的流程控制，既描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。\n策略模式、观察者模式、命令模式、迭代器模式\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/%E6%A0%91%E8%8E%93%E6%B4%BE\/": {
        "title": "树莓派",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/%E6%A0%91%E8%8E%93%E6%B4%BE\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%A1%AC%E7%9B%98%E5%B9%B6%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD\/": {
        "title": "树莓派格式化硬盘并自动挂载",
        "tags": ["树莓派",],
        "content": "输入 fdisk -l查看你U盘的具体分区 fdisk -l 先取消树莓派自动挂载取消挂载 sudo umount /dev/sdb1 将/dev/sdb1分区格式化成ext4文件系统 sudo mkfs.ext4 /dev/sdb1 挂载硬盘 sudo mount /dev/sdb1 /data/hardDisk/linkEase/musics 开机自动挂载硬盘 查看硬盘UUID ls -l /dev/disk/by-uuid/ 通过UUID挂载硬盘 #编辑/etc/fstab sudo vim /etc/fstab #添加以下命令到/etc/fstab UUID=601788b2-96aa-4975-a6c2-7b90b128a7e5 /data/hardDisk/linkEase/musics ext4 defaults 0 0 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%A1%AC%E7%9B%98%E5%B9%B6%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/rsa%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86\/": {
        "title": "RSA数据加密解密",
        "tags": ["php",],
        "content": "RSA数据加密解密 \u0026lt;?php //定义常量 define(\u0026#34;INVOICE_PRINT_URL\u0026#34;, \u0026#39;\u0026#39;); define(\u0026#34;MERCHANT_ID\u0026#34;, \u0026#39;\u0026#39;); define(\u0026#34;MERCHANT_SECRET\u0026#34;, \u0026#39;\u0026#39;); define(\u0026#34;PLATFORM_PUBLIC_KEY\u0026#34;, \u0026#39;\u0026#39;); define(\u0026#34;MERCHANT_PUBLIC_KEY\u0026#34;, \u0026#39;\u0026#39;); define(\u0026#34;MERCHANT_PRIVATE_KEY\u0026#34;, $\u0026#39;\u0026#39;); define(\u0026#34;ACCOUNT_VALUE\u0026#34;, \u0026#39;\u0026#39;); const KEYSIZE = 2048;//密钥长度 \u0026lt;?php /** * @FuncName:getPlatformPublicKey * @Description 获取平台公钥 * @User ZHaoGuiBin * @Date 2020-08-17 8:29 * @return false|resource */ private static function getPlatformPublicKey() { return openssl_pkey_get_public(PLATFORM_PUBLIC_KEY); } /** * @FuncName:getMerchantPrivateKey * @Description 获取商户私钥 * @User ZHaoGuiBin * @Date 2020-08-17 8:29 * @return false|resource */ private static function getMerchantPrivateKey() { return openssl_pkey_get_private(MERCHANT_PRIVATE_KEY); } /** * @FuncName:getMerchantPublicKey * @Description 获取商户公钥 * @User ZHaoGuiBin * @Date 2020-08-17 8:29 * @return false|resource */ private static function getMerchantPublicKey() { return openssl_pkey_get_public(MERCHANT_PUBLIC_KEY); } /** * @FuncName:sslPublicEncrypt * @Description 公钥加密数据 * @User ZHaoGuiBin * @Date 2020-08-14 10:42 * @param $source_data * @return array */ private static function sslPublicEncrypt($source_data) { if (!$source_data) { return [\u0026#39;code\u0026#39; =\u0026gt; 500, \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;加密数据为空\u0026#39;]; } $data = \u0026#34;\u0026#34;; $key = self::getPlatformPublicKey(); if (!$key) { return [\u0026#39;code\u0026#39; =\u0026gt; 500, \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;平台密钥不正确，请检查平台密钥配置\u0026#39;]; } $dataArray = str_split($source_data, self::KEYSIZE / 8 - 11); //加密最长长度为(self::KEYSIZE / 8 - 11) foreach ($dataArray as $value) { $res = openssl_public_encrypt($value, $encryptedTemp, $key); if (!$res) { return [\u0026#39;code\u0026#39; =\u0026gt; 500, \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;加密失败，请重试\u0026#39;]; } $data .= $encryptedTemp; } openssl_free_key($key); return [\u0026#39;code\u0026#39; =\u0026gt; 200, \u0026#39;message\u0026#39; =\u0026gt; base64_encode($data)]; } /** * @FuncName:sslPrivateDecrypt * @Description 私钥解密 * @User ZHaoGuiBin * @Date 2020-08-14 10:56 * @param $encryptData * @return array */ private static function sslPrivateDecrypt($encryptData) { if (!$encryptData) { return [\u0026#39;code\u0026#39; =\u0026gt; 500, \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;没有解密数据\u0026#39;]; } $decrypted = \u0026#34;\u0026#34;; $decodeStr = base64_decode($encryptData); $key = self::getMerchantPrivateKey(); if (!$key) { return [\u0026#39;code\u0026#39; =\u0026gt; 500, \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;获取密钥失败，请联系管理员处理\u0026#39;]; } $enArray = str_split($decodeStr, self::KEYSIZE / 8); foreach ($enArray as $va) { $decryptedTemp = \u0026#34;\u0026#34;; $res = openssl_private_decrypt($va, $decryptedTemp, $key, OPENSSL_PKCS1_PADDING); if (!$res) { return [\u0026#39;code\u0026#39; =\u0026gt; 500, \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;加密失败，请联系管理员处理\u0026#39;]; } $decrypted .= $decryptedTemp; } openssl_free_key($key); return [\u0026#39;code\u0026#39; =\u0026gt; 200, \u0026#39;message\u0026#39; =\u0026gt; $decrypted]; } ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/rsa%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8B%BC%E6%8E%A5%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2\/": {
        "title": "多维数组拼接成字符串",
        "tags": ["php",],
        "content": "多维数组拼接成字符串 /** * @FuncName:arrayToString * @Description 数组拼接成字符串 * @User ZHaoGuiBin * @Date 2020-08-14 9:17 * @param $data * @param string $keys * @param string $key_1 //多维数组主key * @param string $string * @return string */ private static function arrayToString($data, $keys = \u0026#39;\u0026#39;, $string = \u0026#39;\u0026#39;, $key_1 = \u0026#39;\u0026#39;) { $temp = 0; foreach ($data as $key =\u0026gt; $value) { if (is_array($value)) { if (!is_numeric($key)) { $key_1 = $key; $string .= $key_1 . \u0026#39;=\u0026#39;; } $string .= self::arrayToString($value, $key, \u0026#39;\u0026#39;, $key_1); } else { if ($keys) { if (is_numeric($key)) { if ($temp == 0) { $string .= $keys . \u0026#39;=\u0026#39; . $value; $temp++; } else { $string .= \u0026#39;\u0026amp;\u0026#39; . $value . \u0026#39;\u0026amp;\u0026#39;; } } else { if ($temp == 0) { if (!is_numeric($keys)) { $string .= $keys . \u0026#39;=\u0026#39; . $key . \u0026#39;=\u0026#39; . $value . \u0026#39;\u0026amp;\u0026#39;; $temp++; } else { $string .= $key . \u0026#39;=\u0026#39; . $value . \u0026#39;\u0026amp;\u0026#39;; $temp++; } } else { $string .= $key . \u0026#39;=\u0026#39; . $value . \u0026#39;\u0026amp;\u0026#39;; } } } else { $string .= $key . \u0026#39;=\u0026#39; . $value . \u0026#39;\u0026amp;\u0026#39;; } } } return $string; } ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8B%BC%E6%8E%A5%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E6%95%B0%E7%BB%84key%E6%8C%89%E7%85%A7alphabet%E5%BA%8F%E6%8E%92%E5%BA%8F\/": {
        "title": "数组按照alphabet序排序",
        "tags": ["php",],
        "content": "数组key按照alphabet序排序 /** * @FuncName:arraySoft * @Description 数组key按照alphabet序排序 * @User ZHaoGuiBin * @Date 2020-08-13 15:45 * @param $data * @return mixed */ private static function arraySoft($data) { ksort($data); foreach ($data as $key =\u0026gt; $value) { if (is_array($value)) { $data[$key] = self::arraySoft($value); } } return $data; } ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E6%95%B0%E7%BB%84key%E6%8C%89%E7%85%A7alphabet%E5%BA%8F%E6%8E%92%E5%BA%8F\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/surge\/": {
        "title": "surge",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/surge\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/surge%E8%84%9A%E6%9C%AC-dsu%E6%AF%8F%E6%97%A5%E7%AD%BE%E5%88%B0\/": {
        "title": "surge脚本-【DSU】每日签到",
        "tags": ["surge",],
        "content": "surge签到脚本 代码github地址 https://raw.githubusercontent.com/zhaoguibin/surge/master/script/RNB_daily_bonus.js /************************* [Script] mixrnb签到.js = type=cron,cronexp=35 8 * * *,wake-system=1,timeout=20,script-path=https://raw.githubusercontent.com/zhaoguibin/surge/master/script/RNB_daily_bonus.js 获取mixrnb的cookie = type=http-request,pattern=http:\\/\\/www.mixrnb.com\\/plugin\\.php\\?id=dsu_paulsign:sign,tag=获取mixrnb的cookie,script-path=https://raw.githubusercontent.com/zhaoguibin/surge/master/script/RNB_daily_bonus.js,script-update-interval=0 签到页面获取到cookie，http://www.mixrnb.com/plugin.php?id=dsu_paulsign:sign *************************/ var error, response, body; var set_cookies = new Array(); const isRequest = typeof $request != \u0026#34;undefined\u0026#34; if (isRequest) { $cookie = $request.headers.Cookie; const saltkey_regex = /(R5nb_c8f5_saltkey=\\S*)/gm; const auth_regex = /(R5nb_c8f5_auth=(\\S*));/gm; const R5nb_c8f5_saltkey = saltkey_regex.exec($cookie); const R5nb_c8f5_auth = auth_regex.exec($cookie); if (!R5nb_c8f5_saltkey) { $notification.post(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;获取R5nb_c8f5_saltkey失败\u0026#39;); $done(); } if (!R5nb_c8f5_auth) { $notification.post(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;获取R5nb_c8f5_auth失败\u0026#39;); $done(); } $persistentStore.write(R5nb_c8f5_saltkey[1], \u0026#39;R5nb_c8f5_saltkey\u0026#39;); if (!$persistentStore.read(\u0026#39;R5nb_c8f5_saltkey\u0026#39;)) { $notification.post(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;保存R5nb_c8f5_saltkey失败\u0026#39;); $done(); } $persistentStore.write(R5nb_c8f5_auth[1], \u0026#39;R5nb_c8f5_auth\u0026#39;); if (!$persistentStore.read(\u0026#39;R5nb_c8f5_auth\u0026#39;)) { $notification.post(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;保存R5nb_c8f5_auth失败\u0026#39;); $done(); } $notification.post(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;获取cookie成功，请禁用此脚本\u0026#39;); $done(); } // Modified from yichahucha function gabeX() { const get = (options, callback) =\u0026gt; { $httpClient.get(options, (error, response, body) =\u0026gt; { callback(error, response, body) }) } const post = (options, callback) =\u0026gt; { $httpClient.post(options, (error, response, body) =\u0026gt; { callback(error, response, body) }) } const write = (value, key) =\u0026gt; { return $persistentStore.write(value, key) } const read = (key) =\u0026gt; { return $persistentStore.read(key) } const notify = (title, subtitle, message) =\u0026gt; { $notification.post(title, subtitle, message) $done(); } return { get, post, write, read, notify } } var $gabeX = gabeX(); //cookie const R5nb_c8f5_auth = $persistentStore.read(\u0026#39;R5nb_c8f5_auth\u0026#39;); const saltkey = $persistentStore.read(\u0026#39;R5nb_c8f5_saltkey\u0026#39;); if (!saltkey) { $gabeX.notify(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;读取R5nb_c8f5_saltkey失败，请先访问个人空间【http://www.mixrnb.com/space-uid-*.html】获取\u0026#39;); } if (!R5nb_c8f5_auth) { $gabeX.notify(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;读取R5nb_c8f5_auth失败，请先访问个人空间【http://www.mixrnb.com/space-uid-*.html】获取\u0026#39;); } var options = { url: \u0026#34;http://www.mixrnb.com/plugin.php?id=dsu_paulsign:sign\u0026#34;, headers: { \u0026#39;Cookie\u0026#39;: R5nb_c8f5_auth + \u0026#39;;\u0026#39; + saltkey, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.64\u0026#39;, }, body: {} } function getSecuritySessionVerify(error, response, body) { set_cookie = response[\u0026#39;headers\u0026#39;][\u0026#39;Set-Cookie\u0026#39;]; set_cookies = set_cookie.split(\u0026#34;;\u0026#34;); //字符分割 if (!set_cookies) { $gabeX.notify(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;获取SecuritySessionVerify失败\u0026#39;); } options.headers.Cookie += \u0026#39;;\u0026#39; + set_cookies[0]; options.url += \u0026#39;\u0026amp;security_verify_data=313932302c31303830\u0026#39;; } function getSecuritySessionMidVerify(error, response, body) { set_cookie = response[\u0026#39;headers\u0026#39;][\u0026#39;Set-Cookie\u0026#39;]; set_cookies = set_cookie.split(\u0026#34;;\u0026#34;); //字符分割 if (!set_cookies) { $gabeX.notify(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;获取SecuritySessionMidVerify失败\u0026#39;); } options.headers.Cookie += \u0026#39;;\u0026#39; + set_cookies[0]; } function getFormHash(error, response, body) { const regex = /^\u0026lt;li\u0026gt;\u0026lt;a\\shref=\\\u0026#34;member\\.php\\?mod=logging\u0026amp;amp;action=logout\u0026amp;amp;formhash=(\\w*)\\\u0026#34;\u0026gt;.*\u0026lt;\\/a\u0026gt;\u0026lt;\\/li\u0026gt;$/gmi; const formhash = regex.exec(body)[1]; if (!formhash) { $gabeX.notify(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;获取formhash失败\u0026#39;); } options.url = \u0026#39;http://www.mixrnb.com/plugin.php?id=dsu_paulsign:sign\u0026amp;operation=qiandao\u0026amp;infloat=1\u0026amp;inajax=1\u0026#39;; options.body = \u0026#39;formhash=\u0026#39; + formhash + \u0026#39;\u0026amp;qdxq=kx\u0026#39; options[\u0026#39;headers\u0026#39;][\u0026#39;Content-Type\u0026#39;] = \u0026#39;application/x-www-form-urlencoded\u0026#39; } function decodeXml(error, response, body) { //查看是否登录过期或者没登录 var message = \u0026#39;签到出错，请查看日志\u0026#39;; if (body.match(\u0026#39;ÄúÐèÒªÏÈµÇÂ¼²ÅÄÜ¼ÌÐø±¾²Ù×÷\u0026#39;)) { message = \u0026#39;未登录或者cookie失效，请重新获取cookie\u0026#39;; } if (body.match(\u0026#39;¹§Ï²ÄãÇ©µ½³É¹¦!\u0026#39;)) { message = \u0026#39;恭喜你签到成功!\u0026#39;; } if (body.match(\u0026#39;Äú½ñÈÕÒÑ¾­Ç©µ½£¬ÇëÃ÷ÌìÔÙÀ´£¡ \u0026#39;)) { message = \u0026#39;您今日已经签到，请明天再来！\u0026#39;; } console.log(body); $gabeX.notify(\u0026#39;mixrnb签到提醒\u0026#39;, \u0026#39;\u0026#39;, message); } $gabeX.get(options, getSecuritySessionVerify); setTimeout(function () { $gabeX.get(options, getSecuritySessionMidVerify); }, 1000); setTimeout(function () { $gabeX.get(options, getFormHash); }, 2000); setTimeout(function () { $gabeX.post(options, decodeXml); }, 3500); $done(); ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/surge%E8%84%9A%E6%9C%AC-dsu%E6%AF%8F%E6%97%A5%E7%AD%BE%E5%88%B0\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/linux\/": {
        "title": "linux",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/linux\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/mysql\/": {
        "title": "mysql",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/mysql\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/php%E4%BD%BF%E7%94%A8linux%E5%91%BD%E4%BB%A4%E5%AF%BC%E5%87%BAmysql%E6%95%B0%E6%8D%AE%E5%88%B0csv\/": {
        "title": "php使用Linux命令导出MySQL数据到csv",
        "tags": ["php","mysql","linux",],
        "content": "PS :使用这个导出功能需要的条件： 1\u0026ndash;服务器需要安装mysql客户端：yum install mysql 2\u0026ndash;php需要开启exec函数(disable_functions exec)\n/** * @FILE_NAME:ExcelExport.php * @Description 数据导出excel,从数据库导出再下载，数据库配置 * [mysqld] * secure_file_priv= \u0026#39;\u0026#39; * @User ZHaoGuiBin * @Date 2019-12-04 13:52:58 */ class ExcelExport { /** * @FuncName:exportExcel * @Description * @User ZHaoGuiBin * @Date 2019-12-24 13:42:11 * @param string $title * @param $sql * @param $data * @return bool */ public static function exportExcel($title = \u0026#39;报表导出\u0026#39;, $sql, $data) { $data_dir = getcwd() . \u0026#34;/data_export/\u0026#34;; //去除sql语句里的`,要不然执行shell命令报错 $sql = str_replace(\u0026#39;`\u0026#39;, \u0026#39;\u0026#39;, $sql); $sql = str_replace(\u0026#39;\u0026#34;\u0026#39;, \u0026#34;\u0026#39;\u0026#34;, $sql); //删除历史表格 self::deleteExcel(); if (!file_exists($data_dir) || !is_writable($data_dir)) { if (!@mkdir($data_dir, 0755, TRUE)) { Tools::dieJs(\u0026#34;alert(\u0026#39;导出失败，请联系管理员处理\u0026#39;);history.go(-1);\u0026#34;); } } $file_name = $title . time() . \u0026#34;.csv\u0026#34;; $temp_file_name = $title . time() . \u0026#34;_temp.csv\u0026#34;; $file_path = $data_dir . $file_name; $temp_file_path = $data_dir . $temp_file_name; //拼接sql $fields = \u0026#39;\u0026#39;; $title_fields = \u0026#39;\u0026#39;; $temp_key = 0; $fields_count = count($data); foreach ($data as $key =\u0026gt; $field) { $temp_key += 1; $fields .= \u0026#34;ifnull({$field},\u0026#39;\u0026#39;) as {$field}\u0026#34; . ($temp_key \u0026lt; $fields_count ? \u0026#39;,\u0026#39; : \u0026#39;\u0026#39;); $title_fields .= \u0026#34;\u0026#39;{$key}\u0026#39;\u0026#34; . ($temp_key \u0026lt; $fields_count ? \u0026#39;,\u0026#39; : \u0026#39;\u0026#39;); } $sql_str = \u0026#34;SELECT {$title_fields} UNION SELECT {$fields} FROM ({$sql}) as t\u0026#34;; $mysql_config = Yaf_Application::app()-\u0026gt;getConfig()-\u0026gt;toArray(); $mysql_config = $mysql_config[\u0026#39;database\u0026#39;][\u0026#39;config\u0026#39;]; // 2\u0026gt;\u0026amp;1 为了输出shell执行错误 $export_shell = \u0026#39;mysql -h \u0026#39; . $mysql_config[\u0026#39;host\u0026#39;] . \u0026#39; -P\u0026#39; . $mysql_config[\u0026#39;port\u0026#39;] . \u0026#39; -u\u0026#39; . $mysql_config[\u0026#39;username\u0026#39;] . \u0026#39; -p\u0026#39; . \u0026#39;\u0026#34;\u0026#39; . $mysql_config[\u0026#39;password\u0026#39;] . \u0026#39;\u0026#34;\u0026#39; . \u0026#39; \u0026#39; . $mysql_config[\u0026#39;dbname\u0026#39;] . \u0026#39; --default-character-set=utf8 -e \u0026#34;\u0026#39; . $sql_str . \u0026#39;\u0026#34; | sed \u0026#39; . \u0026#34;\u0026#39;\u0026#34; . \u0026#39;s/\\t/\u0026#34;,\u0026#34;/g;s/^/\u0026#34;/;s/$/\u0026#34;/;s/\\n//g\u0026#39; . \u0026#34;\u0026#39;\u0026#34; . \u0026#39; \u0026gt; \u0026#39; . $temp_file_path . \u0026#39; 2\u0026gt;\u0026amp;1\u0026#39;; //文件转码 $iconv_shell = \u0026#34;iconv -f UTF-8 -t GB18030 {$temp_file_path} \u0026gt; {$file_path} 2\u0026gt;\u0026amp;1\u0026#34;; // dd($export_shell); exec($export_shell, $output, $return_var); exec($iconv_shell, $i_output, $i_return_var); unlink($temp_file_path); self::downloadExcel($file_path, $file_name); return true; } /** * @FuncName:downloadExcel * @Description * @User ZHaoGuiBin * @Date 2019-12-24 14:25:10 * @param $file_path 文件地址 * @param $file_name 文件名称 * @return void */ public static function downloadExcel($file_path, $file_name) { ob_end_clean(); if (!file_exists($file_path)) { Tools::dieJs(\u0026#34;alert(\u0026#39;文件不存在，请联系管理员处理\u0026#39;);history.go(-1);\u0026#34;); } $fp = fopen($file_path, \u0026#34;r\u0026#34;); $file_size = filesize($file_path); //下载文件需要用到的头 header(\u0026#34;Content-type:text/html;charset=utf-8\u0026#34;); Header(\u0026#34;Content-type: application/octet-stream\u0026#34;); Header(\u0026#34;Accept-Ranges: bytes\u0026#34;); Header(\u0026#34;Accept-Length:\u0026#34; . $file_size); Header(\u0026#34;Content-Disposition: attachment; filename=\u0026#34; . $file_name); $buffer = 1024; $file_count = 0; while (!feof($fp) \u0026amp;\u0026amp; $file_count \u0026lt; $file_size) { $file_con = fread($fp, $buffer); $file_count += $buffer; echo $file_con; } fclose($fp); } /** * @FuncName:deleteExcel * @Description 删除没用的表格 * @User ZHaoGuiBin * @Date 2019-12-24 15:05:01 * @return bool */ public static function deleteExcel() { //几分钟前的时间戳 $delete_time = strtotime(\u0026#34;-5 minute\u0026#34;); $data_dir = getcwd() . \u0026#34;/data_export/*.csv\u0026#34;; $data_dir = glob($data_dir); if (empty($data_dir)) { return true; } foreach ($data_dir as $key =\u0026gt; $file_path) { $temp_time = self::findNum($file_path); if ($temp_time \u0026lt; $delete_time) { unlink($file_path); } } return true; } /** * @FuncName:findNum * @Description * @User ZHaoGuiBin * @Date 2019-12-24 14:54:11 * @param string $str * @return string */ public static function findNum($str = \u0026#39;\u0026#39;) { $str = trim($str); if (empty($str)) { return \u0026#39;\u0026#39;; } $temp = array(\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;0\u0026#39;); $result = \u0026#39;\u0026#39;; for ($i = 0; $i \u0026lt; strlen($str); $i++) { if (in_array($str[$i], $temp)) { $result .= $str[$i]; } } return $result; } } ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/php%E4%BD%BF%E7%94%A8linux%E5%91%BD%E4%BB%A4%E5%AF%BC%E5%87%BAmysql%E6%95%B0%E6%8D%AE%E5%88%B0csv\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/mysql_outfile%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE\/": {
        "title": "MySQL_OUTFILE导出数据",
        "tags": ["php","mysql",],
        "content": "PS : mysql 需要开启grant FILE on . to newerp; 权限\n/** * @FILE_NAME:ExcelExport.php * @Description 数据导出excel,从数据库导出再下载，数据库配置 * [mysqld] * secure_file_priv= \u0026#39;\u0026#39; * @User ZHaoGuiBin * @Date 2019-12-04 13:52:58 */ class ExcelExport { /** * @FuncName:exportExcel * @Description * @User ZHaoGuiBin * @Date 2019-12-24 13:42:11 * @param string $title * @param $sql * @param $data * @return bool */ public static function exportExcel($title = \u0026#39;报表导出\u0026#39;, $sql, $data) { $data_dir = getcwd() . \u0026#34;/data_export/\u0026#34;; $sys = new SysModel(); $db = $sys-\u0026gt;getAdapter(); //删除历史表格 self::deleteExcel(); if (!file_exists($data_dir) || !is_writable($data_dir)) { if (!@mkdir($data_dir, 0755, TRUE)) { Tools::dieJs(\u0026#34;alert(\u0026#39;导出失败，请联系管理员处理\u0026#39;);history.go(-1);\u0026#34;); } } $file_name = $title . time() . \u0026#34;.csv\u0026#34;; $file_path = $data_dir . $file_name; //拼接sql $convert_fields = \u0026#34;\u0026#34;; $title_fields = \u0026#34;\u0026#34;; $fields = \u0026#39;\u0026#39;; $temp_key = 0; $fields_count = count($data); foreach ($data as $key =\u0026gt; $field) { $temp_key += 1; $convert_fields .= \u0026#34;ifnull(CONVERT (( `{$key}` ) USING gb2312 ),\u0026#39;\u0026#39;)\u0026#34; . ($temp_key \u0026lt; $fields_count ? \u0026#39;,\u0026#39; : \u0026#39;\u0026#39;); $title_fields .= \u0026#34;\u0026#39;{$key}\u0026#39;\u0026#34; . ($temp_key \u0026lt; $fields_count ? \u0026#39;,\u0026#39; : \u0026#39;\u0026#39;); $fields .= \u0026#34;`{$field}`\u0026#34; . ($temp_key \u0026lt; $fields_count ? \u0026#39;,\u0026#39; : \u0026#39;\u0026#39;); } $sql_str = \u0026#34;SELECT {$convert_fields} INTO OUTFILE \u0026#39;{$file_path}\u0026#39; FIELDS TERMINATED BY \u0026#39;,\u0026#39; OPTIONALLY ENCLOSED BY \u0026#39;\\\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\n\u0026#39; FROM ( SELECT {$title_fields} UNION SELECT {$fields} FROM ({$sql}) as t ) temp\u0026#34;; $db-\u0026gt;query($sql_str); self::downloadExcel($file_path, $file_name); return true; } /** * @FuncName:downloadExcel * @Description * @User ZHaoGuiBin * @Date 2019-12-24 14:25:10 * @param $file_path 文件地址 * @param $file_name 文件名称 * @return void */ public static function downloadExcel($file_path, $file_name) { ob_end_clean(); if (!file_exists($file_path)) { Tools::dieJs(\u0026#34;alert(\u0026#39;文件不存在，请联系管理员处理\u0026#39;);history.go(-1);\u0026#34;); } $fp = fopen($file_path, \u0026#34;r\u0026#34;); $file_size = filesize($file_path); //下载文件需要用到的头 header(\u0026#34;Content-type:text/html;charset=utf-8\u0026#34;); Header(\u0026#34;Content-type: application/octet-stream\u0026#34;); Header(\u0026#34;Accept-Ranges: bytes\u0026#34;); Header(\u0026#34;Accept-Length:\u0026#34; . $file_size); Header(\u0026#34;Content-Disposition: attachment; filename=\u0026#34; . $file_name); $buffer = 1024; $file_count = 0; while (!feof($fp) \u0026amp;\u0026amp; $file_count \u0026lt; $file_size) { $file_con = fread($fp, $buffer); $file_count += $buffer; echo $file_con; } fclose($fp); } /** * @FuncName:deleteExcel * @Description 删除没用的表格 * @User ZHaoGuiBin * @Date 2019-12-24 15:05:01 * @return bool */ public static function deleteExcel() { //几分钟前的时间戳 $delete_time = strtotime(\u0026#34;-5 minute\u0026#34;); $data_dir = getcwd() . \u0026#34;/data_export/*.csv\u0026#34;; $data_dir = glob($data_dir); if (empty($data_dir)) { return true; } foreach ($data_dir as $key =\u0026gt; $file_path) { $temp_time = self::findNum($file_path); if ($temp_time \u0026lt; $delete_time) { unlink($file_path); } } return true; } /** * @FuncName:findNum * @Description * @User ZHaoGuiBin * @Date 2019-12-24 14:54:11 * @param string $str * @return string */ public static function findNum($str = \u0026#39;\u0026#39;) { $str = trim($str); if (empty($str)) { return \u0026#39;\u0026#39;; } $temp = array(\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;0\u0026#39;); $result = \u0026#39;\u0026#39;; for ($i = 0; $i \u0026lt; strlen($str); $i++) { if (in_array($str[$i], $temp)) { $result .= $str[$i]; } } return $result; } } ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/mysql_outfile%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/php%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8\/": {
        "title": "PHP导出数据报表",
        "tags": ["php",],
        "content": "/** * @FILE_NAME:ExcelExport.php * @Description csv导出数据 * @User ZHaoGuiBin * @Date 2019-12-04 13:52:58 */ class ExcelExport { /** * @FuncName:sqlQuery * @Description 生成器模式返回数据 * @User ZHaoGuiBin * @Date 2020-01-08 16:43 * @param $sql * @return Generator */ public static function sqlQuery($sql) { $sys = new SysModel(); $db = $sys-\u0026gt;getAdapter(); foreach ($db-\u0026gt;fetchAll($sql) as $key =\u0026gt; $val) { yield $val; //生成器返回数据，避免内存溢出 } } /** * @FuncName:exportExcel * @Description * @User ZHaoGuiBin * @Date 2020-01-09 09:23 * @param string $title * @param string $sql * @param array $data example : [\u0026#34;单号\u0026#34; =\u0026gt; \u0026#39;order_key\u0026#39;],[\u0026#39;报表title名称\u0026#39;=\u0026gt;\u0026#39;mysql语句字段名\u0026#39;] * @return bool */ public static function exportExcel($title = \u0026#39;报表导出\u0026#39;, $sql = \u0026#39;\u0026#39;, $data = []) { $data_dir = getcwd() . \u0026#34;/data_export/\u0026#34;; //删除历史表格 self::deleteExcel(); if (!file_exists($data_dir) || !is_writable($data_dir)) { if (!@mkdir($data_dir, 0755, TRUE)) { Tools::dieJs(\u0026#34;alert(\u0026#39;导出失败，请联系管理员处理\u0026#39;);history.go(-1);\u0026#34;); } } $file_name = $title . time() . \u0026#34;.csv\u0026#34;; $file_path = $data_dir . $file_name; //拼接sql $fields = \u0026#39;\u0026#39;; $title_fields = []; $temp_key = 0; $fields_count = count($data); foreach ($data as $key =\u0026gt; $field) { $temp_key += 1; $fields .= \u0026#34;ifnull({$field},\u0026#39;\u0026#39;) as {$field}\u0026#34; . ($temp_key \u0026lt; $fields_count ? \u0026#39;,\u0026#39; : \u0026#39;\u0026#39;); array_push($title_fields, $key); } $fp = fopen($file_path, \u0026#39;w\u0026#39;); //生成临时文件 fwrite($fp, chr(0xEF) . chr(0xBB) . chr(0xBF));//转码,防止乱码 fputcsv($fp, $title_fields);//插入标题 foreach (self::sqlQuery(\u0026#34;SELECT {$fields} FROM ({$sql}) as t\u0026#34;) as $key =\u0026gt; $value) { fputcsv($fp, $value); } fclose($fp); self::downloadExcel($file_path, $file_name); return true; } /** * @FuncName:downloadExcel * @Description * @User ZHaoGuiBin * @Date 2020-01-08 16:46 * @param string $file_path * @param string $file_name * @return void */ public static function downloadExcel($file_path = \u0026#39;\u0026#39;, $file_name = \u0026#39;\u0026#39;) { ob_end_clean(); if (!file_exists($file_path)) { Tools::dieJs(\u0026#34;alert(\u0026#39;文件不存在，请联系管理员处理\u0026#39;);history.go(-1);\u0026#34;); } $fp = fopen($file_path, \u0026#34;r\u0026#34;); $file_size = filesize($file_path); //下载文件需要用到的头 header(\u0026#34;Content-type:text/html;charset=utf-8\u0026#34;); Header(\u0026#34;Content-type: application/octet-stream\u0026#34;); Header(\u0026#34;Accept-Ranges: bytes\u0026#34;); Header(\u0026#34;Accept-Length:\u0026#34; . $file_size); Header(\u0026#34;Content-Disposition: attachment; filename=\u0026#34; . $file_name); $buffer = 1024; $file_count = 0; while (!feof($fp) \u0026amp;\u0026amp; $file_count \u0026lt; $file_size) { $file_con = fread($fp, $buffer); $file_count += $buffer; echo $file_con; } fclose($fp); } /** * @FuncName:deleteExcel * @Description 删除没用的表格 * @User ZHaoGuiBin * @Date 2019-12-24 15:05:01 * @return bool */ public static function deleteExcel() { //几分钟前的时间戳 $delete_time = strtotime(\u0026#34;-5 minute\u0026#34;); $data_dir = getcwd() . \u0026#34;/data_export/*.csv\u0026#34;; $data_dir = glob($data_dir); if (empty($data_dir)) { return true; } foreach ($data_dir as $key =\u0026gt; $file_path) { $temp_time = self::findNum($file_path); if ($temp_time \u0026lt; $delete_time) { unlink($file_path); } } return true; } /** * @FuncName:findNum * @Description * @User ZHaoGuiBin * @Date 2019-12-24 14:54:11 * @param string $str * @return string */ public static function findNum($str = \u0026#39;\u0026#39;) { $str = trim($str); if (empty($str)) { return \u0026#39;\u0026#39;; } $temp = array(\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;0\u0026#39;); $result = \u0026#39;\u0026#39;; for ($i = 0; $i \u0026lt; strlen($str); $i++) { if (in_array($str[$i], $temp)) { $result .= $str[$i]; } } return $result; } } ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/php%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/virtualbox\/": {
        "title": "virtualbox",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/virtualbox\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/virtualbox%E5%AE%89%E8%A3%85%E5%A2%9E%E5%BC%BA%E5%8A%9F%E8%83%BD%E6%8A%A5%E9%94%99\/": {
        "title": "virtualbox安装增强功能报错",
        "tags": ["linux","virtualbox",],
        "content": " 在virtualbox安装目录找到VBoxGuestAdditions.iso复制到虚拟机里面，可以放到任意一个目录 sudo mkdir /media/GuestAdditionsISO sudo mount -o loop VBoxGuestAdditions.iso所在目录/VBoxGuestAdditions.iso /media/GuestAdditionsISO 这时候你会看到一条信息，the ISO has been mounted as READ-ONLY cd /media/GuestAdditionsISO ./VBoxLinuxAdditions.run 搞定 愿答案\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/virtualbox%E5%AE%89%E8%A3%85%E5%A2%9E%E5%BC%BA%E5%8A%9F%E8%83%BD%E6%8A%A5%E9%94%99\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/golang\/": {
        "title": "golang",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/golang\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/golang%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100%E7%9A%84%E5%A5%87%E6%95%B0%E5%81%B6%E6%95%B0\/": {
        "title": "golang两个线程交替打印1-100的奇数偶数",
        "tags": ["golang",],
        "content": "启动两个线程, 一个输出 1,3,5,7…99, 另一个输出 2,4,6,8…100 最后 STDOUT 中按序输出 1,2,3,4,5…100\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) var pool = 100 //奇数 func oddNum(c chan int) { for i := 1; i \u0026lt;= pool; i++ { c \u0026lt;- i if i%2 == 1 { fmt.Println(i) } } } //偶数 func even(c chan int) { for i := 1; i \u0026lt;= pool; i++ { \u0026lt;-c if i%2 == 0 { fmt.Println(i) } } } func main() { c := make(chan int) go oddNum(c) go even(c) time.Sleep(time.Second * 1) } ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/golang%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100%E7%9A%84%E5%A5%87%E6%95%B0%E5%81%B6%E6%95%B0\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/golang%E6%8A%93%E5%8F%96%E7%9F%A5%E4%B9%8E%E5%9B%BE%E7%89%87\/": {
        "title": "golang抓取知乎图片",
        "tags": ["golang",],
        "content": "代码github地址 https://github.com/zhaoguibin/zhihu_pic 需要安装 gjson go get -u github.com/tidwall/gjson package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;regexp\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/tidwall/gjson\u0026#34; \u0026#34;bufio\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) var quit = make(chan int) func main() { url := urlExists() dirName := strconv.FormatInt(time.Now().Unix(), 10) imgDir := \u0026#34;./\u0026#34; + dirName + \u0026#34;/\u0026#34; _, errs := pathExists(imgDir) if errs != nil { fmt.Printf(\u0026#34;创建文件失败\u0026#34;) return } getImgURL(url, imgDir) } //获取图片地址 func getImgURL(url, imgDir string) { //提交请求 reqest, err := http.NewRequest(\u0026#34;GET\u0026#34;, url, nil) //增加header选项 reqest.Header.Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json; charset=utf-8\u0026#34;) //这里似乎不需要cookie，先注释掉 //reqest.Header.Add(\u0026#34;Cookie\u0026#34;, \u0026#34;_zap=97a733fe-7d3e-45e0-9fe8-c138f01b6fc9; d_c0=\\\u0026#34;AEBjiMYYoA2PTo-4jA6iymyc8bkORSrQyVg=|1526862212\\\u0026#34;; _xsrf=rSY6NLBWiJVpd3t779cxSpkzOCTNZfnn; z_c0=Mi4xTURUVEFRQUFBQUFBUUdPSXhoaWdEUmNBQUFCaEFsVk4xakhKWEFBcmtpS09jQUFoVWpJM2NXNG9LQjBtbWxuWm5B|1541137366|ad106a49adcbac59f43323b0d4f97ded81c4a08b; __utmv=51854390.100-1|2=registration_date=20150706=1^3=entry_date=20150706=1; _ga=GA1.2.632016254.1541137374; tst=r; q_c1=c7a254833a0146769ea4f47f755774ba|1547085195000|1527140571000; __utmc=51854390; __utma=51854390.632016254.1541137374.1547085197.1547112488.3; __utmz=51854390.1547112488.3.3.utmcsr=zhihu.com|utmccn=(referral)|utmcmd=referral|utmcct=/people/zhao-gui-bin-zero/following/collections; tgw_l7_route=66cb16bc7f45da64562a077714739c11; arp_scroll_position=192745\u0026#34;) reqest.Header.Add(\u0026#34;Host\u0026#34;, \u0026#34;www.zhihu.com\u0026#34;) reqest.Header.Add(\u0026#34;Referer\u0026#34;, \u0026#34;www.zhihu.com\u0026#34;) reqest.Header.Add(\u0026#34;User-Agent\u0026#34;, \u0026#34;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\u0026#34;) if err != nil { panic(err) } //生成client 参数为默认 client := \u0026amp;http.Client{} //处理返回结果 response, err := client.Do(reqest) if err != nil { fmt.Println(\u0026#34;图片地址不正确，请重试\u0026#34;) return } defer response.Body.Close() if response.StatusCode == 200 { body, _ := ioutil.ReadAll(response.Body) bodystr := string(body) //下一页数据 next := gjson.Get(bodystr, \u0026#34;paging.next\u0026#34;) fmt.Println(next.String() + \u0026#34;------------------------------------------------------\u0026#34;) for i := 0; i \u0026lt; 5; i++ { value := gjson.Get(bodystr, \u0026#34;data.\u0026#34;+strconv.Itoa(i)+\u0026#34;.content\u0026#34;) if len(value.String()) \u0026gt; 0 { var re = regexp.MustCompile(`(?m)\u0026lt;noscript\u0026gt;\u0026lt;img src=\u0026#34;(.\\S*)\u0026#34;`) for _, match := range re.FindAllStringSubmatch(value.String(), -1) { go downloadImg(match[1], imgDir) \u0026lt;-quit } } else { fmt.Println(\u0026#34;抓取结束\u0026#34;) return } } if len(next.String()) \u0026gt; 0 { getImgURL(next.String(), imgDir) } else { fmt.Println(\u0026#34;抓取结束，已到最后一页\u0026#34;) return } } else { fmt.Println(\u0026#34;获取数据错误，请重试\u0026#34;) return } } //下载图片 func downloadImg(url, imgDir string) (n int64, err error) { path := strings.Split(url, \u0026#34;/\u0026#34;) var name string if len(path) \u0026gt; 1 { name = path[len(path)-1] } fmt.Println(name) out, err := os.Create(imgDir + name) defer out.Close() resp, err := http.Get(url) if err != nil { fmt.Println(\u0026#34;图片下载失败\u0026#34;) quit \u0026lt;- 0 return } quit \u0026lt;- 0 defer resp.Body.Close() pix, err := ioutil.ReadAll(resp.Body) n, err = io.Copy(out, bytes.NewReader(pix)) return } func pathExists(path string) (bool, error) { _, err := os.Stat(path) if err != nil { err := os.Mkdir(path, os.ModePerm) if err != nil { return false, nil } } return true, nil } //判断URL是否为空 func urlExists() string { urls := bufio.NewReader(os.Stdin) fmt.Print(\u0026#34;输入Url:\u0026#34;) url, _, _ := urls.ReadLine() urlStr := string(url[:]) if len(url) == 0 { urlStr = urlExists() } return urlStr } ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/golang%E6%8A%93%E5%8F%96%E7%9F%A5%E4%B9%8E%E5%9B%BE%E7%89%87\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/linux%E6%8C%82%E8%BD%BDwindows%E4%B8%8B%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6\/": {
        "title": "linux挂载windows下的共享文件",
        "tags": ["windows","linux",],
        "content": "安装cifs-utils yum install cifs* -y 这条命令只可以读取Windows共享文件，不能创建文件 #user=Windows用户 #pass=Windows登录密码 #//192.168.10.64/APP Windows共享文件 #/opt/APP/ linux挂载目录 mount.cifs //192.168.10.64/APP /opt/APP/ -o user=Developer,pass=123456trewq 这条命令可以添加文件操作权限 #user=Windows用户 #pass=Windows登录密码 #//192.168.10.64/APP Windows共享文件 #/opt/APP/ linux挂载目录 #uid，gid，linux用户的id和用户组id，可以通过 id root 命令查看用户的id和用户组id #rw,dir_mode=0777,file_mode=0777这些是设置文件夹权限，可以根据自己的需求设置权限 mount.cifs //192.168.10.64/APP /opt/APP/ -o user=Developer,pass=123456trewq,rw,uid=0,gid=0,dir_mode=0777,file_mode=0777 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/linux%E6%8C%82%E8%BD%BDwindows%E4%B8%8B%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/windows\/": {
        "title": "windows",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/windows\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/php-fpm%E7%9A%84%E5%85%B3%E9%97%AD%E5%92%8C%E9%87%8D%E5%90%AF\/": {
        "title": "php-fpm的关闭和重启",
        "tags": ["php",],
        "content": "php-fpm 关闭： kill -INT `cat /usr/local/php/var/run/php-fpm.pid` killall php-fpm php-fpm启动 /usr/local/php/sbin/php-fpm php-fpm 重启 kill -USR2 `cat /usr/local/php/var/run/php-fpm.pid` 查看php-fpm进程数 ps aux | grep -c php-fpm ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/php-fpm%E7%9A%84%E5%85%B3%E9%97%AD%E5%92%8C%E9%87%8D%E5%90%AF\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/iptables\/": {
        "title": "iptables",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/iptables\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/linux%E4%B8%8Biptables%E5%B1%8F%E8%94%BDip%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7\/": {
        "title": "Linux下iptables屏蔽IP和端口号",
        "tags": ["linux","iptables",],
        "content": "#封单个IP的命令： iptables -I INPUT -s 192.168.10.66 -j DROP #封IP段的命令： iptables -I INPUT -s 192.168.0.0/16 -j DROP #封整个段的命令： iptables -I INPUT -s 192.168.0.0/8 -j DROP #封几个段的命令： iptables -I INPUT -s 192.168.10.0/24 -j DROP #只封80端口： iptables -I INPUT -p tcp –dport 80 -s 192.168.0.0/24 -j DROP #解封： iptables -F #清空： iptables -D INPUT 数字 #列出 INPUT链 所有的规则： iptables -L INPUT --line-numbers #删除某条规则，其中5代表序号（序号可用上面的命令查看）： iptables -D INPUT 5 #开放指定的端口： iptables -A INPUT -p tcp --dport 80 -j ACCEPT #禁止指定的端口： iptables -A INPUT -p tcp --dport 80 -j DROP #拒绝所有的端口： iptables -A INPUT -j DROP 以上都是针对INPUT链的操作，即是外面来访问本机的方向，配置完之后 需要保存，否则iptables 重启之后以上设置就失效\nservice iptables save iptables 对应的配置文件\n/etc/sysconfig/iptables 注意：iptables的规则匹配顺序上从上到下的，也就是说如果上下两条规则有冲突时，将会以上面的规则为准。\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/linux%E4%B8%8Biptables%E5%B1%8F%E8%94%BDip%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/centos\/": {
        "title": "centos",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/centos\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos%E4%BF%AE%E6%94%B9ip\/": {
        "title": "centos修改IP",
        "tags": ["centos","linux",],
        "content": "首先查看网络接口名称 ifconfig 临时修改IP ifconfig eth1 192.168.10.88 永久修改IP 修改对应的网络接口配置文件，文件路径是 /etc/sysconfig/network-scripts/ vim /etc/sysconfig/network-scripts/ifcfg-网络接口名称 修改以下配置 BOOTPROTO=static # 以下配置有就修改，没有就添加 IPADDR=192.168.10.88 #静态IP GATEWAY=192.168.10.1 #默认网关 NETMASK=255.255.255.0 #子网掩码 修改DNS vim /etc/resolv.conf nameserver 1.1.1.1 nameserver 8.8.8.8 重启网络服务 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos%E4%BF%AE%E6%94%B9ip\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/nginx\/": {
        "title": "nginx",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/nginx\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/nginx%E4%BD%BF%E7%94%A8brotli\/": {
        "title": "Nginx使用brotli",
        "tags": ["nginx",],
        "content": "首先下载brotli的nginx模块 cd /opt/local/src git clone https://github.com/google/ngx_brotli.git 接着下载brotli源代码 cd ngx_brotli cd deps/brotli git clone https://github.com/google/brotli.git 编译nginx源代码指定第三方模块 ./configure --prefix=/opt/local/nginx --without-http_memcached_module --user=www --group=www --with-http_stub_status_module --with-openssl=/usr/ --with-pcre=/opt/local/src/pcre-8.36 --add-module=/opt/local/src/ngx_brotli 可能会报错，提示你 ./configure: error: Brotli library is missing from the /opt/local/src/ngx_brotli/deps/brotli directory. Please make sure that the git submodule has been checked out: cd /opt/local/src/ngx_brotli \u0026amp;\u0026amp; git submodule update --init \u0026amp;\u0026amp; cd /opt/local/src/nginx-1.12.1 照着它的提示操作就好了,网络不好的话需要等很长时间，这时候就是展现技术的时候了，你懂得 cd /opt/local/src/ngx_brotli \u0026amp;\u0026amp; git submodule update --init \u0026amp;\u0026amp; cd /opt/local/src/nginx-1.12.1 操作完以后，再一次编译nginx源码 ./configure --prefix=/opt/local/nginx --without-http_memcached_module --user=www --group=www --with-http_stub_status_module --with-openssl=/usr/ --with-pcre=/opt/local/src/pcre-8.36 --add-module=/opt/local/src/ngx_brotli make 拷贝新的nginx bin文件 mv /opt/local/nginx/sbin/nginx /opt/local/nginx/sbin/nginx_bak cp objs/nginx /opt/local/nginx/sbin/ /opt/local/nginx/sbin/nginx -t 不报错的话，就修改配置文件去 brotli on; #brotli_types text/plain text/css text/xml application/xml application/json text/javascript application/javascript application/x-javascript brotli_types *; brotli_static off; brotli_comp_level 11; brotli_buffers 16 8k; brotli_window 512k; brotli_min_length 20; 反向代理禁用gzip proxy_set_header Accept-Encoding \u0026#34;\u0026#34;; 最后在Request Headers请求头和Response Headers响应头里可以看到 ngx_brotli定义了如下指令： brotli，是否允许动态压缩响应数据，可选值为on和off，默认值为off。 brotli on; brotli_types，动态压缩启用时，允许压缩的MIME types，默认值为text/html。 brotli_types text/plain text/css text/xml application/xml application/json text/javascript application/javascript application/x-javascript; brotli_static，是否允许查找预处理好的、以.br结尾的压缩文件，可选值为on、off和always，默认值为off。 brotli_static off; brotli_comp_level，压缩级别，可选值范围为0~11，默认值为6。 brotli_comp_level 11; brotli_buffers，压缩响应数据时使用的缓冲区的数量和大小。 brotli_buffers 16 8k; brotli_window，brotli使用的窗口值，默认值为512k。 brotli_window 512k; brotli_min_length，响应数据的最小长度，低于该值将不使用brotli算法执行压缩操作。brotli算法使用Content-Length来确定响应数据的长度。 brotli_min_length 20; ★★★ 最后，brotli只对https生效 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/nginx%E4%BD%BF%E7%94%A8brotli\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/mysql%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0\/": {
        "title": "MySQL保留两位小数",
        "tags": ["mysql",],
        "content": "round(x,d) :用于数据的四舍五入,round(x) ,其实就是round(x,0),也就是默认d为0； 这里有个值得注意的地方是，d可以是负数，这时是指定小数点左边的d位整数位为0,同时小数位均为0；\nSELECT ROUND(5000.56789,2),ROUND(5000,2),ROUND(0.56789,2),ROUND(115.56789,-1); SELECT ROUND(5000.12345,2),ROUND(5000,2),ROUND(0.12345,2),ROUND(114.12345,-1); TRUNCATE(x,d)：函数返回被舍去至小数点后d位的数字x。若d的值为0，则结果不带有小数点或不带有小数部分。若d设为负数，则截去（归零）x小数点左起第d位开始后面所有低位的值。 SELECT TRUNCATE(5000.56789,2),TRUNCATE(5000,2),TRUNCATE(0.56789,2),TRUNCATE(115.56789,-1); SELECT TRUNCATE(5000.12345,2),TRUNCATE(5000,2),TRUNCATE(0.12345,2),TRUNCATE(114.12345,-1); ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/mysql%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/kafka\/": {
        "title": "kafka",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/kafka\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/kafka%E5%AE%89%E8%A3%85\/": {
        "title": "Kafka安装",
        "tags": ["kafka",],
        "content": "1.去kafka官网下载到最新的kafka安装包，选择下载二进制版本的tgz文件\n2.环境需求：java运行环境\n3.配置 在kafka解压目录下下有一个config的文件夹，里面放置的是我们的配置文件\nconsumer.properites #消费者配置，这个配置文件用于配置于2.5节中开启的消费者，此处我们使用默认的即可 producer.properties #生产者配置，这个配置文件用于配置于2.5节中开启的生产者，此处我们使用默认的即可 server.properties #kafka服务器的配置，此配置文件用来配置kafka服务器，目前仅介绍几个最基础的配置 broker.id #申明当前kafka服务器在集群中的唯一ID，需配置为integer,并且集群中的每一个kafka服务器的id都应是唯一的，我们这里采用默认配置即可 listeners #申明此kafka服务器需要监听的端口号，如果是在本机上跑虚拟机运行可以不用配置本项，默认会使用localhost的地址，如果是在远程服务器上运行则必须配置，例如： #listeners=PLAINTEXT:// 192.168.180.128:9092。并确保服务器的9092端口能够访问 zookeeper.connect #申明kafka所连接的zookeeper的地址 ，需配置为zookeeper的地址，由于本次使用的是kafka高版本中自带zookeeper，使用默认配置即可 zookeeper.connect=localhost:2181 4.运行\n4.1 启动zookeeper cd进入kafka解压目录，输入\nbin/zookeeper-server-start.sh config/zookeeper.properties 启动zookeeper成功后会看到如下的输出\n4.2. 启动kafka cd进入kafka解压目录，输入\nbin/kafka-server-start.sh config/server.properties 启动kafka成功后会看到如下的输出 5.第一个消息 5.1 创建一个topic Kafka通过topic对同一类的数据进行管理，同一类的数据使用同一个topic可以在处理数据时更加的便捷 在kafka解压目录打开终端，输入\nbin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic beta 创建一个名为beta的topic 在创建topic后可以通过输入\nbin/kafka-topics.sh --list --zookeeper localhost:2181 来查看已经创建的topic 5.2 创建一个消息消费者 在kafka解压目录打开终端，输入\nbin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic beta --from-beginning 可以创建一个用于消费topic为beta的消费者 消费者创建完成之后，因为还没有发送任何数据，因此这里在执行后没有打印出任何数据不过别着急，不要关闭这个终端，打开一个新的终端，接下来我们创建第一个消息生产者\n5.3创建一个消息生产者\n在kafka解压目录打开一个新的终端，输入\nbin/kafka-console-producer.sh --broker-list localhost:9092 --topic beta 在执行完毕后会进入的编辑器页面 在发送完消息之后，可以回到我们的消息消费者终端中，可以看到，终端中已经打印出了我们刚才发送的消息\n转载自：cnblogs\u0026ndash;嘿123\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/kafka%E5%AE%89%E8%A3%85\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/jdk\/": {
        "title": "jdk",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/jdk\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/linux%E5%AE%89%E8%A3%85jdk\/": {
        "title": "Linux安装jdk",
        "tags": ["linux","jdk",],
        "content": "到oracle官网下载二进制压缩文件\n1.解压 2.编辑/etc/profile，添加以下配置 export JAVA_HOME=/opt/src/jdk1.8.0_171 export JRE_HOME=/opt/src/jdk1.8.0_171/jre export PATH=$PATH:/opt/src/jdk1.8.0_171/bin export CLASSPATH=./:/opt/src/jdk1.8.0_171/lib:/opt/src/jdk1.8.0_171/jre/lib 3.刷新配置 source /etc/profile 4.查看配置是否生效 java -version 5.出现以下信息就安装成功了 java version \u0026#34;1.8.0_171\u0026#34; Java(TM) SE Runtime Environment (build 1.8.0_171-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode) ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/linux%E5%AE%89%E8%A3%85jdk\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/docker\/": {
        "title": "docker",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/docker\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/docker%E4%BF%9D%E5%AD%98%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BF%AE%E6%94%B9\/": {
        "title": "docker保存对容器的修改",
        "tags": ["docker",],
        "content": "docker commit 容器ID 要保存的镜像名称 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/docker%E4%BF%9D%E5%AD%98%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BF%AE%E6%94%B9\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/docker-%E4%B8%8D%E8%83%BD%E8%BF%90%E8%A1%8C-systemctl\/": {
        "title": "docker 不能运行 systemctl",
        "tags": ["docker",],
        "content": "docker centos7运行systemctl start nginx 报错：\nFailed to get D-BUS connection: Operation no permitted 解决方法：\n在启动容器的时候添加上-d参数就可以了\ndocker run -itd --privileged -p 3306:3306 -v /opt/data/:/opt/mysql/data 镜像ID /usr/sbin/init docker exec -it 容器ID /bin/bash ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/docker-%E4%B8%8D%E8%83%BD%E8%BF%90%E8%A1%8C-systemctl\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/sql%E7%BA%B5%E5%90%91%E5%8F%98%E6%88%90%E6%A8%AA%E5%90%91%E6%A8%AA%E5%90%91%E5%8F%98%E6%88%90%E7%BA%B5%E5%90%91\/": {
        "title": "SQL纵向变成横向，横向变成纵向",
        "tags": ["mysql",],
        "content": "纵向变成横向 Name Subject Result 张三 语文 73 张三 数学 83 张三 物理 93 李四 语文 74 李四 数学 84 李四 物理 94 转换成\n| 姓名 | 语文 | 数学 | 物理 | | \u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash; | | 李四 | 74 | 84 | 94 | | 张三 | 73 | 83 | 93 |\n建表插入数据 CREATE TABLE students ( `Name` VARCHAR (50), `Subject` VARCHAR (50), `Result` INT (11) ); INSERT INTO students VALUES (\u0026#39;张三\u0026#39;, \u0026#39;语文\u0026#39;, \u0026#39;73\u0026#39;), (\u0026#39;张三\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;83\u0026#39;), (\u0026#39;张三\u0026#39;, \u0026#39;物理\u0026#39;, \u0026#39;93\u0026#39;), (\u0026#39;李四\u0026#39;, \u0026#39;语文\u0026#39;, \u0026#39;74\u0026#39;), (\u0026#39;李四\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;84\u0026#39;), (\u0026#39;李四\u0026#39;, \u0026#39;物理\u0026#39;, \u0026#39;94\u0026#39;); 转换语句 这里的SUM也可以用MAX替代，都是取一条数据\nSELECT `Name` AS 姓名, SUM( CASE `Subject` WHEN \u0026#39;语文\u0026#39; THEN `Result` ELSE 0 END ) AS \u0026#39;语文\u0026#39;, SUM( CASE `Subject` WHEN \u0026#39;数学\u0026#39; THEN `Result` ELSE 0 END ) AS \u0026#39;数学\u0026#39;, SUM( CASE `Subject` WHEN \u0026#39;物理\u0026#39; THEN `Result` ELSE 0 END ) AS \u0026#39;物理\u0026#39; FROM students GROUP BY NAME 横向变成纵向 | 姓名 | 语文 | 数学 | 物理 | | \u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash; | | 李四 | 74 | 84 | 94 | | 张三 | 73 | 83 | 93 |\n转换成\nName Subject Result 张三 语文 73 张三 数学 83 张三 物理 93 李四 语文 74 李四 数学 84 李四 物理 94 建表插入数据 CREATE TABLE students_1 ( `姓名` VARCHAR (50), `语文` VARCHAR (50), `数学` VARCHAR (50), `物理` VARCHAR (50) ); INSERT INTO `students_1` ( `姓名`, `语文`, `数学`, `物理` ) VALUES (\u0026#39;张三\u0026#39;, \u0026#39;73\u0026#39;, \u0026#39;83\u0026#39;, \u0026#39;93\u0026#39;), (\u0026#39;李四\u0026#39;, \u0026#39;74\u0026#39;, \u0026#39;84\u0026#39;, \u0026#39;94\u0026#39;); 转换语句 SELECT `姓名` AS \u0026#39;Name\u0026#39;, `语文` AS \u0026#39;Subject\u0026#39;, `语文` AS \u0026#39;Result\u0026#39; FROM students_1 UNION SELECT `姓名` AS \u0026#39;Name\u0026#39;, `数学` AS \u0026#39;Subject\u0026#39;, `数学` AS \u0026#39;Result\u0026#39; FROM students_1 UNION SELECT `姓名` AS \u0026#39;Name\u0026#39;, `物理` AS \u0026#39;Subject\u0026#39;, `物理` AS \u0026#39;Result\u0026#39; FROM students_1 ORDER BY `Name` DESC 参考自：CSDN-会飞的鱼online\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/sql%E7%BA%B5%E5%90%91%E5%8F%98%E6%88%90%E6%A8%AA%E5%90%91%E6%A8%AA%E5%90%91%E5%8F%98%E6%88%90%E7%BA%B5%E5%90%91\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/mysql%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5%E5%9C%A8%E5%93%AA%E4%B8%AA%E8%A1%A8\/": {
        "title": "MySQL查询字段在哪个表",
        "tags": ["mysql",],
        "content": "查询pwd字段在哪个数据库哪个表 SELECT TABLE_SCHEMA, TABLE_NAME FROM information_schema.`COLUMNS` WHERE COLUMN_NAME = \u0026#39;pwd\u0026#39; 查询pwd字段在ERP数据库的哪个表 SELECT TABLE_SCHEMA, TABLE_NAME FROM information_schema.`COLUMNS` WHERE COLUMN_NAME = \u0026#39;pwd\u0026#39; AND TABLE_SCHEMA = \u0026#39;ERP\u0026#39; ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/mysql%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5%E5%9C%A8%E5%93%AA%E4%B8%AA%E8%A1%A8\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/sqlserver\/": {
        "title": "SQLserver",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/sqlserver\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E5%8D%B8%E8%BD%BDsql-server-2017-%E5%87%BA%E7%8E%B0%E8%AD%A6%E5%91%8A26003\/": {
        "title": "卸载SQL Server 2017 出现警告26003",
        "tags": ["SQLserver",],
        "content": "卸载SQLserver出现以下问题，把解决方法记录下来，留着以后备用 提示信息： 解决方法：\n可以使用：WMIC（windows Management Instrumentation Command-line） 列出当前系统上安装的应用程序，最后使用MSIEXEC /X 将其卸载\n打开 CMD(命令提示符) 输入命令：\nWMIC Product list msiexec /x {IdentifyingNumbe} ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E5%8D%B8%E8%BD%BDsql-server-2017-%E5%87%BA%E7%8E%B0%E8%AD%A6%E5%91%8A26003\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/php%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\/": {
        "title": "php排序实现方法",
        "tags": ["php",],
        "content": "直接插入排序 /* * 直接插入排序,插入排序的思想是：当前插入位置之前的元素有序， * 若插入当前位置的元素比有序元素最后一个元素大，则什么也不做， * 否则在有序序列中找到插入的位置，并插入 */ function insertSort($arr) { $len = count($arr); for($i = 1; $i \u0026lt; $len; $i++) { if($arr[$i-1] \u0026gt; $arr[i]) { for($j = $i - 1;$j \u0026gt;= 0; $j-- ) { $tmp = $arr[$j+1]; if($tmp \u0026lt; $arr[$j]) { $arr[$j+1] = $arr[$j]; $arr[$j] = $tmp; }else{ break; } } } } return $arr; } 冒泡排序 /* 冒泡排序,冒泡排序思想：进行 n-1 趟冒泡排序， 每趟两两比较调整最大值到数组（子数组）末尾 */ function bubbleSort($arr) { $len = count($arr); for($i = 1; $i \u0026lt; $len; $i++) { for($j = 0; $j \u0026lt; $len-$i; $j++) { if($arr[$j] \u0026gt; $arr[$j+1]) { $tmp = $arr[$j+1]; $arr[$j+1] = $arr[$j]; $arr[$j] = $tmp; } } } return $arr; } 简单选择排序 /* 简单选择排序, 简单排序思想：从数组第一个元素开始依次确定从小到大的元素 */ function selectSort($arr) { $len = count($arr); for($i = 0; $i \u0026lt; $len; $i++) { $k = $i; for($j = $i+1; $j \u0026lt; $len; $j++) { if($arr[$k] \u0026gt; $arr[$j]) { $k = $j; } } if($k != $i) { $tmp = $arr[$i]; $arr[$i] = $arr[$k]; $arr[$k] = $tmp; } } return $arr; } 希尔排序 /* 希尔排序,希尔排序原理：将数组按指定步长分隔成若干子序列，然后分别对子序列进行排序（在这是直接） */ function shellSort($arr) { $len = count($arr); $k = floor($len/2); while($k \u0026gt; 0) { for($i = 0; $i \u0026lt; $k; $i++) { for($j = $i; $j \u0026lt; $len, ($j + $k) \u0026lt; $len; $j = $j + $k) { if($arr[$j] \u0026gt; $arr[$j+$k]) { $tmp = $arr[$j+$k]; $arr[$j+$k] = $arr[$j]; $arr[$j] = $tmp; } } } $k = floor($k/2); } return $arr; } 快速排序 /* * 快速排序,快排思想：通过一趟排序将待排的记录分为两个独立的部分，其中一部分的记录的关键字均不大于 * 另一部分记录的关键字，然后再分别对这两部分记录继续进行快速排序，以达到整个序列有序，具体做法需要 * 每趟排序设置一个标准关键字和分别指向头一个记录的关键字和最后一个记录的关键字的指针。 * quickSort($arr, 0, count($arr) -1); */ function quickSort(\u0026amp;$arr,$low,$high) { if($low \u0026lt; $high) { $i = $low; $j = $high; $primary = $arr[$low]; while($i \u0026lt; $j) { while($i \u0026lt; $j \u0026amp;\u0026amp; $arr[$j] \u0026gt;= $primary) { $j--; } if($i \u0026lt; $j) { $arr[$i++] = $arr[$j]; } while($i \u0026lt; $j \u0026amp;\u0026amp; $arr[$i] \u0026lt;= $primary) { $i++; } if($i \u0026lt; $j) { $arr[$j--] = $arr[$i]; } } $arr[$i] = $primary; quickSort($arr, $low, $i-1); quickSort($arr, $i+1, $high); } } 堆排序 /* 堆排序 */ // 调整子堆的为大根堆的过程，$s为子堆的根的位置，$m为堆最后一个元素位置 function heapAdjust(\u0026amp;$arr, $s, $m) { $tmp = $arr[$s]; // 在调整为大根堆的过程中可能会影响左子堆或右子堆 // for循环的作用是要保证子堆也是大根堆 for($j = 2*$s + 1; $j \u0026lt;= $m; $j = 2*$j + 1) { // 找到根节点的左右孩子中的最大者，然后用这个最大者与根节点比较， // 若大则进行调整，否则符合大根堆的 特点跳出循环 if($j \u0026lt; $m \u0026amp;\u0026amp; $arr[$j] \u0026lt; $arr[$j+1]) { $j++; } if($tmp \u0026gt;= $arr[$j] ) { break; } $arr[$s] = $arr[$j]; $s = $j; } $arr[$s] = $tmp; } // 堆排序 function heapSort($arr) { $len = count($arr); // 依次从子堆开始调整堆为大根堆 for($i = floor($len/2-1); $i \u0026gt;= 0; $i--) { heapAdjust($arr, $i, $len-1); } // 依次把根节点调换至最后一个位置，再次调整堆为大根堆，找到次最大值， // 依次类推得到一个有序数组 for($n = $len-1; $n \u0026gt; 0; $n--) { $tmp = $arr[$n]; $arr[$n] = $arr[0]; $arr[0] = $tmp; heapAdjust($arr, 0, $n-1); } return $arr; } 归并排序 /* 归并排序,这里实现的是两路归并 */ // 分别将有序的$arr1[s..m]、$arr2[m+1..n]归并为有序的$arr2[s..n] function Merge(\u0026amp;$arr1, \u0026amp;$arr2, $s, $m, $n) { for($k = $s,$i = $s, $j = $m+1; $i \u0026lt;= $m \u0026amp;\u0026amp; $j \u0026lt;= $n; $k++) { if($arr1[$i]\u0026lt;$arr1[$j]) { $arr2[$k] = $arr1[$i++]; }else { $arr2[$k] = $arr1[$j++]; } } if($i \u0026lt;= $m) { for(; $i \u0026lt;= $m; $i++) { $arr2[$k++] = $arr1[$i]; } } else if($j \u0026lt;= $n) { for(; $j \u0026lt;= $n; $j++) { $arr2[$k++] = $arr1[$j]; } } } // 递归形式的两路归并 function MSort(\u0026amp;$arr1, \u0026amp;$arr2, $s, $t) { if($s == $t) { $arr2[$s] = $arr1[$s]; }else { $m = floor(($s+$t)/2); $tmp_arr = array(); MSort($arr1, $tmp_arr, $s, $m); MSort($arr1, $tmp_arr, $m+1, $t); Merge($tmp_arr, $arr2, $s, $m, $t); } } // 对一位数组$arr[0..n-1]中的元素进行两路归并 function mergeSort($arr) { $len = count($arr); MSort($arr, $arr, 0, $len-1); return $arr; } 使用经验 若排序的记录数目n较小时，可以采用直接插入排序和简单选择排序，当记录本身信息量较大时，用简单选择排序方法较好。 若待排序记录按关键字基本有序，适合采用直接插入排序和冒泡排序。 若n值较大时，可以采用快速排序、堆排序和归并排序。另外快速排序被认为是内部排序方法中最好的方法。\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/php%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/ddldml%E5%92%8Cdcl%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%90%86%E8%A7%A3\/": {
        "title": "DDL、DML和DCL的区别与理解",
        "tags": ["mysql",],
        "content": "DML、DDL、DCL区别 .\n总体解释：\nDML(data manipulation language)：\n它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言\nDDL(data definition language)：\nDDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表(TABLE)的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用\nDCL(Data Control Language)：\n是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括(grant,deny,revoke等)语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL\n详细解释：\nDDL DDL is Data Definition Language statements. Some examples:数据定义语言，用于定义和管理 SQL 数据库中的所有对象的语言\n1.CREATE - to create objects in the database 创建\n2.ALTER - alters the structure of the database 修改\n3.DROP - delete objects from the database 删除\n4.TRUNCATE - remove all records from a table, including all spaces allocated for the records are removed\nTRUNCATE TABLE [Table Name]。\n下面是对Truncate语句在MSSQLServer2000中用法和原理的说明：\nTruncate table 表名 速度快,而且效率高,因为:\nTRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。\nDELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。\nTRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。\n对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。\nTRUNCATE TABLE 不能用于参与了索引视图的表。\n5.COMMENT - add comments to the data dictionary 注释\n6.GRANT - gives user\u0026rsquo;s access privileges to database 授权\n7.REVOKE - withdraw access privileges given with the GRANT command 收回已经授予的权限\nDML DML is Data Manipulation Language statements. Some examples:数据操作语言，SQL中处理数据等操作统称为数据操纵语言\n1.SELECT - retrieve data from the a database 查询\n2.INSERT - insert data into a table 添加\n3.UPDATE - updates existing data within a table 更新\n4.DELETE - deletes all records from a table, the space for the records remain 删除\n5.CALL - call a PL/SQL or Java subprogram\n6.EXPLAIN PLAN - explain access path to data\nOracle RDBMS执行每一条SQL语句，都必须经过Oracle优化器的评估。所以，了解优化器是如何选择(搜索)路径以及索引是如何被使用的，对优化SQL语句有很大的帮助。Explain可以用来迅速方便地查出对于给定SQL语句中的查询数据是如何得到的即搜索路径(我们通常称为Access Path)。从而使我们选择最优的查询方式达到最大的优化效果。\n7.LOCK TABLE - control concurrency 锁，用于控制并发\nDCL DCL is Data Control Language statements. Some examples:数据控制语言，用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等\n1.COMMIT - save work done 提交\n2.SAVEPOINT - identify a point in a transaction to which you can later roll back 保存点\n3.ROLLBACK - restore database to original since the last COMMIT 回滚\n4.SET TRANSACTION - Change transaction options like what rollback segment to use 设置当前事务的特性，它对后面的事务没有影响.\n转载自-https://www.2cto.com/database/201610/555167.html\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/ddldml%E5%92%8Cdcl%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%90%86%E8%A7%A3\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E8%A7%A3%E5%86%B3mysql%E5%87%BA%E7%8E%B0-waiting-for-table-metadata-lock-%E9%97%AE%E9%A2%98\/": {
        "title": "解决MySQL出现 Waiting for table metadata lock 问题",
        "tags": ["mysql",],
        "content": "前几天修改数据库表，结果数据库就卡死了，通过命令\nshow processlist 发现 Waiting for table metadata lock状态的连接，幸好这个状态的连接不多，kill掉这些连接就可以了。\n通过google之后知道MySQL在进行一些alter table等DDL(Data Definition Language)操作时，如果该表上有未提交的事务的话就会出现 Waiting for table metadata lock而一旦出现metadata lock，该表上的后续操作都会被阻塞。\n查看未提交事务 从 information_schema.innodb_trx 表中查看当前未提交的事务\nselect trx_state, trx_started, trx_mysql_thread_id, trx_query from information_schema.innodb_trx\\G （\\G作为结束符时，MySQL Client会把结果以列模式展示，对于列比较长的表，展示更直观）\n字段意义：\ntrx_state: 事务状态，一般为RUNNING trx_started: 事务执行的起始时间，若时间较长，则要分析该事务是否合理 trx_mysql_thread_id: MySQL的线程ID，用于kill trx_query: 事务中的sql 一般只要kill掉这些线程，DDL操作就不会Waiting for table metadata lock。\n调整锁超时阈值 lock_wait_timeout 表示获取metadata lock的超时（单位为秒），允许的值范围为1到31536000（1年）。 默认值为31536000。详见 https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_lock_wait_timeout 。默认值为一年！！！已哭瞎！将其调整为30分钟\nset session lock_wait_timeout = 1800; set global lock_wait_timeout = 1800; 好让出现该问题时快速故障（failfast）\n借鉴与-https://blog.csdn.net/u013235478/article/details/68062939\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E8%A7%A3%E5%86%B3mysql%E5%87%BA%E7%8E%B0-waiting-for-table-metadata-lock-%E9%97%AE%E9%A2%98\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/%E6%AD%A3%E5%88%99\/": {
        "title": "正则",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/%E6%AD%A3%E5%88%99\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E6%AD%A3%E5%88%99%E6%8E%8C%E6%8F%A1%E7%A8%8B%E5%BA%A6%E6%B5%8B%E8%AF%95%E9%A2%98\/": {
        "title": "正则掌握程度测试题",
        "tags": ["正则",],
        "content": "分组提取/非捕获组 分组，是正则里一个非常重要的概念，我们需要针对某个区域提取数据，往往需要依赖分组。而分组，其实就是正则里()括住的部分。\n分组提取 需求：在分组1中匹配meta中author属性的值 源串： \u0026lt;meta author=\u0026#34;Zjmainstay\u0026#34; /\u0026gt; another author=\u0026#34;Zjmainstay too\u0026#34; 预期：分组1得到Zjmainstay 正则：/\u0026#34;(\\w*)\u0026#34;/ 非捕获组 针对上面的分组，有时候，我们并不需要捕获某个分组的内容，我们可以使用非捕获组(?:表达式)，从而不捕获表达式部分内容到分组中。\n需求：匹配每行字母个数是偶数个的数据，每行数据不为空，正则不能存在分组1 源串： a ab abc abcd 预期： 匹配得到 ab 和 abcd，不包含分组1 正则：/^(?:\\w\\w)+$/m 单字符或 或条件是正则使用过程中常用的概念，比如，密码由字母或数字组成，这里就用到了或条件，而且，由于字母或数字都是单个字符，因此，可以使用[a-z0-9]这样的单字符或语法实现。 常犯错误：匹配a或b写成[a|b]，此表达式实际上表示a或b或|，在[]内部的|表示其本身，注意区分(a|b)表示a或b的写法。\n单字符或 需求：匹配由 A/S/D/F 4个字母(区分大小写)组成的长度为3字符串 源串： ABC ASD ADS ASF BBC A|S A|D ASDF 预期：以[]元字符获得3个字母的或集，匹配 ASD/ADS/ASF 3组数据 正则：/^[ASDF]{3}$/m 多字符或 相对单字符或条件，多字符或也是很常见的，比如，我们需要匹配http或ftp两个协议头的url，就需要^(http|ftp)://.+$这样的语法来实现。\n多字符或 需求：匹配每行数据中以.jpg/.jpeg/.png/.gif结尾的图片名称（含后缀） 源串： image.jpg image.jpeg image.png image.gif not_image.txt not_image.doc not_image.xls not_image.ppt 预期：匹配 image.jpg/image.jpeg/image.png/image.gif 4个结果 正则：/(.*\\.(jpg|jpeg|png|gif))/m 分组引用 前面介绍了分组，那某个分组在我们匹配过程中重复出现，又该如何处理？分组引用恰恰解决这个问题。比如，匹配出现重复单词的一行数据，我们可以这么写（多行模式）：/^.?(\\b\\S+\\b).?\\1.*$/m，\\1表示引用前面分组1中匹配到的内容，也就是重复的单词内容。\n匹配连续相同3次的数字 需求：匹配连续相同3次的数字 源串： 111 121 112 222 预期：匹配 111/222 两组数据 正则：/^(\\d)\\1\\1$/m 匹配换行数据 “我的正则本来好好的，突然不行了！”这个是很多正则新人遇到的问题，而这个问题，很多时候，就是因为原来正则中的.不能匹配新数据里的换行导致的。这时候，只需要把.改成[\\s\\S]这样的表达式就可以了。这个表达式表示空格或非空格，也就是任意字符啦。\n匹配换行数据 需求：分别使用单行模式和普通模式匹配id=\u0026#34;author\u0026#34;的div中数据，div标签不在同一行 源串： \u0026lt;div id=\u0026#34;author\u0026#34;\u0026gt; Zjmainstay \u0026lt;/div\u0026gt; 预期：Zjmainstay 正则1：@\u0026lt;div\\sid=\u0026#34;author\u0026#34;\u0026gt;([\\s\\S]*)\u0026lt;/div\u0026gt;@s 正则2： 存在（或） 匹配多种或条件的数据，没有特殊限制 需求：匹配每行中包含“作者”或者“读者”的数据 源串： 本文的作者是Zjmainstay 本文有很多读者 读者可以是任何一个地方的人 这里的任何一个地方说明读者也能在国外 什么乱七八糟的推理 你不匹配我，凭什么要我推荐你的博客 www.zjmainstay.cn 预期：匹配 本文的作者是Zjmainstay 本文有很多读者 读者可以是任何一个地方的人 这里的任何一个地方说明读者也能在国外 正则：/(.*(作者|读者).*)/m 匹配多种或条件的数据，有特殊限制（不使用环视） 需求：匹配每行中“读者”在开头或结尾的数据 源串： 本文作者是Zjmainstay，有很多读者 读者可以是任何一个地方的人 这里的任何一个地方说明读者也能在国外 预期：匹配 本文作者是Zjmainstay，有很多读者 读者可以是任何一个地方的人 正则：/.*(^读者|读者$).*/m 匹配多种或条件的数据，有特殊限制（使用环视） 需求：匹配每行中“读者”在开头或结尾的数据 源串： 本文作者是Zjmainstay，有很多读者 读者可以是任何一个地方的人 这里的任何一个地方说明读者也能在国外 预期：匹配 本文作者是Zjmainstay，有很多读者 读者可以是任何一个地方的人 正则：/((?\u0026lt;=^读者).*|.*(?=读者$))/m 存在（与） 校验密码必须包含字母、数字和特殊字符，6-16位 需求：校验密码必须包含字母、数字和特殊字符，6-16位，假定特殊字符为 -_= 三个字符 源串： 12345 123456 1234561234561234 12345612345612345 a1234 a12345 -1234 -12345 a-123 a-1234 a-1234a-1234a-12 a-1234a-1234a-1234 aaaaa aaaaaa -_=-_ -_=-_= 预期：匹配 a-1234 a-1234a-1234a-12 正则：^(?=.{6,16})(?=.*[a-z])(?=.*[0-9])(?=.*[-_=])[0-9a-z-_=]*$ 特殊限制（环视否定） 使用\\d{1,3}匹配1-999的数据，不能以0开头 需求：使用\\d{1,3}匹配每行中1-999的数据，不能以0开头 源串： 1 10 100 999 1000 01 001 预期：匹配 1 10 100 999 正则：/^(?!0)\\d{1,3}$/m 匹配除了span标签外的所有标签 需求：匹配除了\u0026lt;span\u0026gt;内容\u0026lt;/span\u0026gt;标签外的所有\u0026lt;tagName\u0026gt;内容\u0026lt;/tagName\u0026gt;格式标签 源串： \u0026lt;div\u0026gt;匹配我\u0026lt;/div\u0026gt; \u0026lt;span\u0026gt;不匹配我\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt;匹配我\u0026lt;/p\u0026gt; \u0026lt;i\u0026gt;匹配我\u0026lt;/i\u0026gt; 预期：匹配 \u0026lt;div\u0026gt;匹配我\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;匹配我\u0026lt;/p\u0026gt; \u0026lt;i\u0026gt;匹配我\u0026lt;/i\u0026gt; 正则：/\u0026lt;(?!span).*(?\u0026lt;!\\/span)\u0026gt;/ 替换分组使用 给源串每个链接加上http://www.zjmainstay.cn前缀 需求：给源串每个链接加上http://www.zjmainstay.cn前缀 源串： \u0026lt;a id=\u0026#34;link-1\u0026#34; href=\u0026#34;/regexp-one\u0026#34;\u0026gt;正则文章合集（All In One)\u0026lt;/a\u0026gt; \u0026lt;a id=\u0026#34;link-2\u0026#34; href=\u0026#34;/my-regexp\u0026#34;\u0026gt;正则入门教程\u0026lt;/a\u0026gt; \u0026lt;a id=\u0026#34;link-3\u0026#34; href=\u0026#34;/deep-regexp\u0026#34;\u0026gt;正则高级教程\u0026lt;/a\u0026gt; \u0026lt;a id=\u0026#34;link-4\u0026#34; href=\u0026#34;/regexp-lookaround\u0026#34;\u0026gt;正则环视详解\u0026lt;/a\u0026gt; \u0026lt;a id=\u0026#34;link-5\u0026#34; href=\u0026#34;/php-curl\u0026#34;\u0026gt;PHP cURL应用\u0026lt;/a\u0026gt; 预期：替换得到 \u0026lt;a id=\u0026#34;link-1\u0026#34; href=\u0026#34;http://www.zjmainstay.cn/regexp-one\u0026#34;\u0026gt;正则文章合集（All In One)\u0026lt;/a\u0026gt; \u0026lt;a id=\u0026#34;link-2\u0026#34; href=\u0026#34;http://www.zjmainstay.cn/my-regexp\u0026#34;\u0026gt;正则入门教程\u0026lt;/a\u0026gt; \u0026lt;a id=\u0026#34;link-3\u0026#34; href=\u0026#34;http://www.zjmainstay.cn/deep-regexp\u0026#34;\u0026gt;正则高级教程\u0026lt;/a\u0026gt; \u0026lt;a id=\u0026#34;link-4\u0026#34; href=\u0026#34;http://www.zjmainstay.cn/regexp-lookaround\u0026#34;\u0026gt;正则环视详解\u0026lt;/a\u0026gt; \u0026lt;a id=\u0026#34;link-5\u0026#34; href=\u0026#34;http://www.zjmainstay.cn/php-curl\u0026#34;\u0026gt;PHP cURL应用\u0026lt;/a\u0026gt; 查找：/href=\u0026#34;(?=\\/)\\// 或者 /href=\u0026#34;\\// 替换：href=\u0026#34;http://www.zjmainstay.cn/ 将每行数据格式化为一条SQL语句 需求：将每行特定格式数据格式化为SQL语句 源串： 1 2017-04-11 Zjmainstay 2 2017-04-12 Nobody 3 2017-04-13 Somebody 预期：替换得到 INSERT INTO table_log(`id`, `created_at`, `author`) values(\u0026#39;1\u0026#39;, \u0026#39;2017-04-11\u0026#39;, \u0026#39;Zjmainstay\u0026#39;); INSERT INTO table_log(`id`, `created_at`, `author`) values(\u0026#39;2\u0026#39;, \u0026#39;2017-04-12\u0026#39;, \u0026#39;Nobody\u0026#39;); INSERT INTO table_log(`id`, `created_at`, `author`) values(\u0026#39;3\u0026#39;, \u0026#39;2017-04-13\u0026#39;, \u0026#39;Somebody\u0026#39;); 查找：/(\\d)\\s([\\d-]+)\\s(\\w+)/ 或者 /([0-9])\\s([0-9-]+)\\s([a-zA-Z]+)/ 替换：INSERT INTO table_log(`id`, `created_at`, `author`) values(\u0026#39;$1\u0026#39;, \u0026#39;$2\u0026#39;, \u0026#39;$3\u0026#39;); 分组可选 分组可选 需求：判断如果单词以A开头，匹配Apple；如果单词以B开头，匹配Banana；否则匹配Empty 源串： Angle Apple Banana Best Empty 预期：匹配 Apple Banana Empty 正则：/((?:A)pple)|((?:B)anana)|((?:E)mpty)/ 分组可选与分组引用 需求：匹配html标签的属性值，属性值可以由双引号、单引号、无单双引号定界 源串： \u0026lt;div id=\u0026#34;I\u0026#39;m Zjmainstay\u0026#34; class=\u0026#34;name\u0026#34; data-year=2017 age=\u0026#39;27\u0026#39;\u0026gt; 预期：分组匹配 I\u0026#39;m Zjmainstay name 2017 27 正则：/[\u0026#34;\\\u0026#39;]([\\w\\s\\\u0026#39;]*)[\u0026#34;\\\u0026#39;]/ 单字符拆分（数字） 匹配0.00-100.00的数值，可以有0-2位小数 需求：匹配0.00-100.00的数值，可以有0-2位小数，不能以小数点结尾，不能以2个以上的0开头 思路：(100|10-99|0-9) + 0-2小数位 + 排除小数点结尾、2个以上0开头的情况 源串： 0 1 0.0 0.00 9.00 18.00 27.0 36.00 45.00 54.00 63.00 72.00 81.00 90.00 99.99 100.00 0. 001 100.01 100.001 101 预期：匹配0.00~100.00 正则：/(?!00)(100|[10-99]|[0-9])*(\\.\\d{1,2})/m 贪婪模式 贪婪模式，正则会优先尽可能多地匹配能匹配到的内容。当剩余正则匹配剩余部分字符（源串）\t但无法满足匹配时，贪婪部分回溯，吐出已匹配的内容，尝试满足剩余部分字符的匹配。\n匹配链接中的文件名 需求：利用贪婪模式，分组1得到每行链接中的文件名 源串： http://localhost.com/a/b/c/d/file1.txt https://localhost.com/a/b/file2long.jpg 预期：分组0匹配行数据，分组1匹配文件名 file1.txt file2long.jpg 正则：/.*\\/(.*\\..*)/ 限定字符贪婪优化匹配性能 需求：匹配div id=\u0026#34;author\u0026#34;的标签内容 源串： \u0026lt;div id=\u0026#34;author\u0026#34; class=\u0026#34;author-text something-\tuseless\u0026#34;\u0026gt;Zjmainstay\u0026lt;/div\u0026gt; 预期：利用贪婪模式去掉div中的噪点（无关数据），分组1匹配到Zjmainstay 正则：/\u0026lt;div.*\u0026gt;(.*)\u0026lt;\\/div\u0026gt;/ 非贪婪模式 非贪婪模式，正则会优先尽可能少地匹配能匹配到的内容。当剩余正则匹配剩余部分字符（源\t串）但无法满足匹配时，非贪婪部分继续匹配更多内容，尝试满足剩余部分字符的匹配。\n匹配p标签内容 需求：匹配p标签内容 源串： \u0026lt;p\u0026gt;内容1\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;内容2\u0026lt;/p\u0026gt; 预期： 在分组1中匹配到内容1和内容2 正则：/\u0026lt;p\u0026gt;(.*?)\u0026lt;\\/p\u0026gt;/ 占用模式(PCRE) 贪婪模式后再加一个+量词，如.++，效果是贪婪而且不回溯。 暂时没有想到应用场景。\n|字符分界（|的作用域） |作为或条件分隔符，它的分隔区间常常存在误用。在使用|字符的过程中，我们常常需要结合 ()来对它进行限定。如，^([0-9]+|[a-z]+)$表示纯数字或纯字母，如果没有()，那它又是 另一种意思了。^[0-9]+|[a-z]+$等价于^[0-9]+或[a-z]+$，因此，它表示数字开头或者 字母结尾，跟我们的需求有了很大的差别。\n|字符分界 需求：在分组1中匹配css或script的链接 源串： \u0026lt;script src=\u0026#34;main.min.js\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;main.css\u0026#34;\u0026gt; 预期： main.min.js main.css 正则：/src=\u0026#34;(.*?)\u0026#34;|href=\u0026#34;(.*?)\u0026#34;/ 元字符转义 元字符，指正则中有特殊意义的字符，如.表示匹配除了换行符以外的任意字符，这个.就是元字符。在正则书写过程中，如果我们真的要匹配这个.，就需要对它进行转义，而不是让它使用正则的含义，比如，匹配域名里的.，我们就要写成/zjmainstay.cn/这样的正则。\n元字符转义 需求：表达式格式固定，提取其中的数值 源串： (20+170)-5*1/5=? 预期： A:20 B:170 C:5 D:1 E:5 F:? 正则：/\\((\\d+)\\+(\\d+)\\)-(\\d+)\\*(\\d+)\\/(\\d+)=(\\?)/ 替换：($1+$2)-$3*$4/$5=$6 分隔符绕过（PCRE） 有时候，如果该语言支持多种分隔符，在写正则的过程中通常会通过规避分隔符的方式，减少对分隔符的转义，让正则看起来更清晰，写起来更舒服，当然，js中是不支持的。\n分隔符绕过 需求：在不对/转义的情况下匹配p标签内容 源串： \u0026lt;p\u0026gt;内容1\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;内容2\u0026lt;/p\u0026gt; 预期： 在分组1中匹配到内容1和内容2 正则：@\u0026lt;p\u0026gt;(.*?)\u0026lt;/p\u0026gt;@m 匹配溢出排除 匹配溢出，这不是一个术语名词，是我自己的叫法，主要指正则匹配内容超出了我们预期，导致匹配得到非预期的结果。\ndiv标签匹配溢出 需求：匹配内容为数字的div 源串： \u0026lt;div class=\u0026#34;aaa bbb\u0026#34;\u0026gt;ABC\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;bbb ccc\u0026#34;\u0026gt;123\u0026lt;/div\u0026gt; 预期： \u0026lt;div\u0026gt;123\u0026lt;/div\u0026gt; 错误正则：/\u0026lt;div.*?\u0026gt;\\d+\u0026lt;\\/div\u0026gt;/ 正则：/\u0026lt;div[^\u0026gt;]*\u0026gt;\\d+\u0026lt;\\/div\u0026gt;/ 多字符排除 需求：匹配不包含某个单词或词语的内容 源串： http://www.zjmainstay.cn http://www.baidu.com http://www.qq.com 预期： http://www.zjmainstay.cn http://www.qq.com 正则：/(http:\\/\\/www.((?!baidu).)+(cn|com))/ 多字符排除 需求：匹配不包含某个单词或词语的内容 源串： A(\u0026#34;Excalibur\u0026#34;, \u0026#34;誓约胜利之剑\u0026#34;, LONG_SWORD, (SPFX_NOGEN | SPFX_RESTR | SPFX_SEEK | SPFX_DEFN | SPFX_INTEL | SPFX_SEARCH), 0, 0, PHYS(5, 10), DRLI(0, 0), NO_CARY, 0, A_LAWFUL, PM_KNIGHT, NON_PM, 4000L, NO_COLOR); /* * Stormbringer only has a 2 because it can drain a level, * providing 8 more. */ A(\u0026#34;Stormbringer\u0026#34;, \u0026#34;兴风者\u0026#34;, RUNESWORD, (SPFX_RESTR | SPFX_ATTK | SPFX_DEFN | SPFX_INTEL | SPFX_DRLI), 0, 0, DRLI(5, 2), DRLI(0, 0), NO_CARY, 0, A_CHAOTIC, NON_PM, NON_PM, 8000L, NO_COLOR); /* * Mjollnir will return to the hand of the wielder when thrown * if the wielder is a Valkyrie wearing Gauntlets of Power. */ A(\u0026#34;Mjollnir\u0026#34;, \u0026#34;雷神之锤\u0026#34;, WAR_HAMMER, /* Mjo:llnir */ (SPFX_RESTR | SPFX_ATTK), 0, 0, ELEC(5, 24), NO_DFNS, NO_CARY, 0, A_NEUTRAL, PM_VALKYRIE, NON_PM, 4000L, NO_COLOR); A(\u0026#34;Cleaver\u0026#34;, \u0026#34;撕裂者\u0026#34;, BATTLE_AXE, SPFX_RESTR, 0, 0, PHYS(3, 6), NO_DFNS, NO_CARY, 0, A_NEUTRAL, PM_BARBARIAN, NON_PM, 1500L, NO_COLOR); /* * Grimtooth glows in warning when elves are present, but its * damage bonus applies to all targets rather than just elves * (handled as special case in spec_dbon()). */ A(\u0026#34;Grimtooth\u0026#34;, \u0026#34;邪兽之牙\u0026#34;, ORCISH_DAGGER, (SPFX_RESTR | SPFX_WARN | SPFX_DFLAG2), 0, M2_ELF, PHYS(2, 6), NO_DFNS, NO_CARY, 0, A_CHAOTIC, NON_PM, PM_ORC, 300L, CLR_RED); /* * Orcrist and Sting have same alignment as elves. * * The combination of SPFX_WARN+SPFX_DFLAG2+M2_value will trigger * EWarn_of_mon for all monsters that have the M2_value flag. * Sting and Orcrist will warn of M2_ORC monsters. */ A(\u0026#34;Orcrist\u0026#34;, \u0026#34;杀兽剑\u0026#34;, ELVEN_BROADSWORD, (SPFX_WARN | SPFX_DFLAG2), 0, M2_ORC, PHYS(5, 0), NO_DFNS, NO_CARY, 0, A_CHAOTIC, NON_PM, PM_ELF, 2000L, CLR_BRIGHT_BLUE); /* bright blue is actually light blue */ 预期： Excalibur=誓约胜利之剑 Stormbringer=兴风者 Mjollnir=雷神之锤 Cleaver=撕裂者 Grimtooth=邪兽之牙 Orcrist=杀兽剑 查找：$re = \u0026#39;/\u0026#34;(\\w+)\u0026#34;(,)\\s\u0026#34;([\\x{4e00}-\\x{9fa5}]+)\u0026#34;/u\u0026#39;; 替换：$subst = \u0026#39;$1=$3\u0026#39;; $result = preg_replace($re, $subst, $str); 环视循环提取格式化 在数据处理过程中，经常遇到一些格式化处理，比如简单地将一批数据格式化为SQL（参考9.2），还有复杂的需要对一行数据的某部分进行循环提取，然后格式化为特定格式。\n需求：循环提取每行数据的分支部分和固定部分，格式化为特定格式 源串： BBB|CCC|DDD=AAA FFF|GGG|HHH|III|JJJ|KKK=EEE 预期： BBB=AAA CCC=AAA DDD=AAA FFF=EEE GGG=EEE HHH=EEE III=EEE JJJ=EEE KKK=EEE 查找：/\\|(?=.*(=.*))/ 替换：$1\\\\n $1 表示引用正则表达式第一个子模式 三段论应用 ​\t三段论，是本人根据对正则的理解，归纳出来的三句话：定锚点，去噪点，取数据。 锚点，在正则中指^、$、\\b这类零宽的位置，这里做了衍生，指能够唯一确定我们目标数据位置的参照点，比如author=Zjmainstay，我们要匹配author属性的数据，则author=就是我们的参照点，通过它，我们能快速写出提取author属性的数据的正则：author=(.+)。\n噪点，就是对我们提取数据产生干扰的无关数据，我们在做正则匹配提取数据的过程中，可以选择性的忽略它们。当然，这里的忽略不是指不需要对它们做匹配，而是不需要对它们做精确匹配。比如，正则表达式，我们要提取a标签的url和文本（正则表达式），这时候，a标签上的class、style、title这些属性，对我们来说就没有意义了，它们就是噪点，在匹配过程中我们可以选择性的忽略它们（使用通配符进行匹配消耗掉它们），因此得到正则：\u0026lt;a [^\u0026gt;]?href=\u0026quot;([^\u0026quot;]+)\u0026quot;[^\u0026gt;]\u0026gt;(.*?)\n数据，这个当然是指我们需要提取的内容了，如上面锚点举例，我们通过author=(.+)的(.+)对Zjmainstay部分数据进行了提取，因此，匹配结果的分组1（程序语言中的数组下标1）中，就能得到我们的结果。而对于多个数据的提取，如噪点举例，我们只需要针对数据部分进行多个分组（括号）的提取即可。 分组的计数，一般可以数左括号，排除环视和非捕获组的左括号，从1开始，依次加1递增，1,2,3,4\u0026hellip;.n，不同语言最大分组个数不同，大家在使用过程中自行留意，不过一般用不了那么多分组。 理解了三段论的概念，我们在写正则的过程中，只需要将源串进行分割划分，根据目标数据确定锚点，过滤噪点，提取数据，就能得到我们想要的正则了。\n练习题地址", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E6%AD%A3%E5%88%99%E6%8E%8C%E6%8F%A1%E7%A8%8B%E5%BA%A6%E6%B5%8B%E8%AF%95%E9%A2%98\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/netstat%E5%91%BD%E4%BB%A4\/": {
        "title": "netstat命令",
        "tags": ["linux",],
        "content": "netstat -anp | grep 端口号 telnet 127.0.0.1 9501 ps aft | grep tcp.php pstree -p 22727 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/netstat%E5%91%BD%E4%BB%A4\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E6%AD%A3%E5%88%99%E7%9A%84%E7%94%A8%E6%B3%95\/": {
        "title": "正则^的用法",
        "tags": ["正则",],
        "content": "^在[]外面表示以[]里的字符为首 ^在[]里面表示不匹配[]里的字符\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E6%AD%A3%E5%88%99%E7%9A%84%E7%94%A8%E6%B3%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/yum-update%E5%92%8Cyum-upgrade%E5%8C%BA%E5%88%AB\/": {
        "title": "yum  update和yum  upgrade区别",
        "tags": ["centos",],
        "content": "yum -y update #升级所有包同时也升级软件和系统内核 yum -y upgrade #只升级所有包，不升级软件和系统内核 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/yum-update%E5%92%8Cyum-upgrade%E5%8C%BA%E5%88%AB\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos--su%E5%92%8Csudo\/": {
        "title": "CentOS--su和sudo",
        "tags": ["centos",],
        "content": "su命令 su - root 一旦在使用su命令登录root，用户获取了系统的绝对管理权限\n只允许特定用户使用该su命令 要做到这一点，编辑插入式验证模块为（PAM）配置文件/etc/pam.d/su 在文本编辑器中打开该文件，取消注释：\n#auth required pam_wheel.so use_uid 将用户添加到名为wheel的特殊管理组\nusermod -a -G wheel username sudo命令 只有/etc/sudoers配置文件中列出的用户才可以使用该sudo命令，命令在用户的 shell中执行，而不是在rootshell中执行。这意味着root可以完全禁用shell。\nsudo ls /root 每个使用该sudo命令的成功身份验证都会记录到/var/log/messages，并将的用户和发出的命令记录到文件/var/log/secure中。\n/var/log/secure cat /var/log/secure #查看记录 如果需要额外的日志记录，请使用该pam_tty_audit模块为指定用户启用TTY审计，方法是将以下行添加到/etc/pam.d/system-auth文件中：\nsession required pam_tty_audit.so disable=pattern enable=pattern 其中pattern表示逗号分隔的用户列表，以下配置将启用root用户的TTY审计，并禁用所有其他用户\nsession required pam_tty_audit.so disable=* enable=root 权限管理 要赋予某人完全的管理权限：\n用visudo命令编辑/etc/sudoers\ngabe ALL =（ALL）ALL #允许gabe使用sudo执行任何命令 赋予部分管理权限\n%users ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom #允许users组中的成员执行执行的挂载磁盘命令 不需要输入sudo密码执行一组命令\nCmnd_Alias SYS_BACKUP = /bin/su - root -c /usr/locale/sbin/sys_backup.sh,/mnt/cdrom insmsop1 ALL=(ALL) NOPASSWD: SYS_BACKUP　配置sudo记录密码的时间 sudo将密码保存五分钟的超时时间。在此期间对该命令的任何后续使用都不会提示用户输入密码。添加下面的一行将修改时间\nDefaults timestamp_timeout=value #value=0,每次sudo都需要输入密码 如果某个帐户遭到入侵，攻击者可以使用以下sudo管理权限打开一个新的shell：\nsudo /bin/bash #绕过/etc/sudoers文件中指定的超时时间，并且永远不要求攻击者sudo再次输入密码 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos--su%E5%92%8Csudo\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/nss\/": {
        "title": "nss",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/nss\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/php-curl-returns-35-ssl-connect-error\/": {
        "title": "PHP curl returns (35) SSL connect error",
        "tags": ["centos","nss","php",],
        "content": "用PHP cURL来获取https链接的页面，出现错误PHP curl returns (35) SSL connect error， 找到一个方法，记录一下，以免忘记。\n解决方法：\nyum update nss Q:但是，什么是NSS呢？\nA:curl模块的ssl 支持默认为NSS,网络安全服务（NSS）\nThe Network Security Services (NSS)\n再来个详细解释 https://serverfault.com/questions/606135/curl-35-ssl-connect-error/642203#642203 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/php-curl-returns-35-ssl-connect-error\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos7%E8%AE%BE%E7%BD%AEip%E7%99%BD%E5%90%8D%E5%8D%95\/": {
        "title": "centos7设置IP白名单",
        "tags": ["centos",],
        "content": "编辑iptables配置文件，将文件内容更改为如下，则具备了ip地址白名单功能\nvim /etc/sysconfig/iptables 1 *filter 2 :INPUT ACCEPT [0:0] 3 :FORWARD ACCEPT [0:0] 4 :OUTPUT ACCEPT [0:0] 5 6 -N whitelist 7 -A whitelist -s 1.2.3.0/24 -j ACCEPT 8 -A whitelist -s 4.5.6.7 -j ACCEPT 9 10 -A INPUT -m state --state RELATED,ESTABLISHED -j whitelist 11 -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j whitelist 12 -A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j whitelist 13 -A INPUT -p icmp -j ACCEPT 14 -A INPUT -i lo -j ACCEPT 15 -A INPUT -j REJECT --reject-with icmp-host-prohibited 16 -A FORWARD -j REJECT --reject-with icmp-host-prohibited 17 COMMIT 6~8 行是添加白名单列表，可以是ip段或者单个ip地址\n10~12行 注意的是“-j whitelist”而不是“-j ACCEPT”，前者将该端口访问权限限制在白名单内，后者为不限制\n13行 任何ip地址都能ping通该主机，因为“-j ACCEPT”没有做相应限制\n配置完毕后，运行命令重启防火墙使规则生效\nsystemctl restart iptables.service ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos7%E8%AE%BE%E7%BD%AEip%E7%99%BD%E5%90%8D%E5%8D%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/php%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B\/": {
        "title": "php下载文件简单实例",
        "tags": ["linux","php",],
        "content": "class Spider { public function downloadImage($url, $path=\u0026#39;images/\u0026#39;) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30); $file = curl_exec($ch); curl_close($ch); $this-\u0026gt;saveAsImage($url, $file, $path); } private function saveAsImage($url, $file, $path) { $filename = pathinfo($url, PATHINFO_BASENAME); if(!file_exists($path)){ mkdir($path,0777); } $resource = fopen($path . $filename, \u0026#39;a\u0026#39;); fwrite($resource, $file); fclose($resource); } } $str = file_get_contents(\u0026#34;http://www.bing.com/HPImageArchive.aspx?format=js\u0026amp;idx=0\u0026amp;n=1\u0026amp;mkt=en-US\u0026#34;); $arr = json_decode($str,true); $img_url = \u0026#39;http://www.bing.com\u0026#39;.$arr[\u0026#39;images\u0026#39;][0][\u0026#39;url\u0026#39;]; $img = new Spider(); $img-\u0026gt;downloadImage($img_url); ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/php%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/nginx-%E5%90%AF%E7%94%A8gzip%E5%8E%8B%E7%BC%A9\/": {
        "title": "Nginx 启用gzip压缩",
        "tags": ["centos","nginx",],
        "content": "网页压缩 网页压缩是一项由 WEB 服务器和浏览器之间共同遵守的协议，也就是说 WEB 服务器和浏览器都必须支持该技术，所幸的是现在流行的浏览器都是支持的，包括 IE、FireFox、Opera 等；服务器有 Apache 和 IIS 等。双方的协商过程如下：　首先浏览器请求某个 URL 地址，并在请求的头 (head) 中设置属性 accept-encoding 值为 gzip, deflate，表明浏览器支持 gzip 和 deflate 这两种压缩方式（事实上 deflate 也是使用 gzip 压缩协议，下面我们会介绍二者之间的区别）；\nWEB 服务器接收到请求后判断浏览器是否支持压缩，如果支持就传送压缩后的响应内容，否则传送不经过压缩的内容； 浏览器获取响应内容后，判断内容是否被压缩，如果是则解压缩，然后显示响应页面的内容。\n在实际的应用中我们发现压缩的比率往往在 3 到 10 倍，也就是本来 50k 大小的页面，采用压缩后实际传输的内容大小只有 5 至 15k 大小，这可以大大节省服务器的网络带宽，同时如果应用程序的响应足够快时，网站的速度瓶颈就转到了网络的传输速度上，因此内容压缩后就可以大大的提升页面的浏览速度。\n配置启用gzip 在nginx.conf中，gzip的配置可以写在http段，server段中的任何地方\n格式如下\ngzip on; gzip_min_length 5k; gzip_buffers 4 16k; #gzip_http_version 1.0; gzip_comp_level 3; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; gzip_vary on; 保存，重启nginx\n配置指令详细注释： gzip on|off # 默认值: gzip off # 开启或者关闭gzip模块 gzip_static on|off # nginx对于静态文件的处理模块 # 该模块可以读取预先压缩的gz文件，这样可以减少每次请求进行gzip压缩的CPU资源消耗。该模块启用后，nginx首先检查是否存在请求静态文件的gz结尾的文件，如果有则直接返回该gz文件内容。为了要兼容不支持gzip的浏览器，启用gzip_static模块就必须同时保留原始静态文件和gz文件。这样的话，在有大量静态文件的情况下，将会大大增加磁盘空间。我们可以利用nginx的反向代理功能实现只保留gz文件。 # 可以google\u0026#34;nginx gzip_static\u0026#34;了解更多 gzip_comp_level 4 # 默认值：1(建议选择为4) # gzip压缩比/压缩级别，压缩级别 1-9，级别越高压缩率越大，当然压缩时间也就越长（传输快但比较消耗cpu）。 gzip_buffers 4 16k # 默认值: gzip_buffers 4 4k/8k # 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 例如 4 4k 代表以4k为单位，按照原始数据大小以4k为单位的4倍申请内存。 4 8k 代表以8k为单位，按照原始数据大小以8k为单位的4倍申请内存。 # 如果没有设置，默认值是申请跟原始数据相同大小的内存空间去存储gzip压缩结果。 gzip_types mime-type [mime-type ...] # 默认值: gzip_types text/html (默认不对js/css文件进行压缩) # 压缩类型，匹配MIME类型进行压缩 # 不能用通配符 text/* # (无论是否指定)text/html默认已经压缩 # 设置哪压缩种文本文件可参考 conf/mime.types gzip_min_length 1k # 默认值: 0 ，不管页面多大都压缩 # 设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取。 # 建议设置成大于1k的字节数，小于1k可能会越压越大。 即: gzip_min_length 1024 gzip_http_version 1.0|1.1 # 默认值: gzip_http_version 1.1(就是说对HTTP/1.1协议的请求才会进行gzip压缩) # 识别http的协议版本。由于早期的一些浏览器或者http客户端，可能不支持gzip自解压，用户就会看到乱码，所以做一些判断还是有必要的。 # 注：99.99%的浏览器基本上都支持gzip解压了，所以可以不用设这个值,保持系统默认即可。 # 假设我们使用的是默认值1.1，如果我们使用了proxy_pass进行反向代理，那么nginx和后端的upstream server之间是用HTTP/1.0协议通信的，如果我们使用nginx通过反向代理做Cache Server，而且前端的nginx没有开启gzip，同时，我们后端的nginx上没有设置gzip_http_version为1.0，那么Cache的url将不会进行gzip压缩 gzip_proxied [off|expired|no-cache|no-store|private|no_last_modified|no_etag|auth|any] ... # 默认值：off # Nginx作为反向代理的时候启用，开启或者关闭后端服务器返回的结果，匹配的前提是后端服务器必须要返回包含\u0026#34;Via\u0026#34;的 header头。 off - 关闭所有的代理结果数据的压缩 expired - 启用压缩，如果header头中包含 \u0026#34;Expires\u0026#34; 头信息 no-cache - 启用压缩，如果header头中包含 \u0026#34;Cache-Control:no-cache\u0026#34; 头信息 no-store - 启用压缩，如果header头中包含 \u0026#34;Cache-Control:no-store\u0026#34; 头信息 private - 启用压缩，如果header头中包含 \u0026#34;Cache-Control:private\u0026#34; 头信息 no_last_modified - 启用压缩,如果header头中不包含 \u0026#34;Last-Modified\u0026#34; 头信息 no_etag - 启用压缩 ,如果header头中不包含 \u0026#34;ETag\u0026#34; 头信息 auth - 启用压缩 , 如果header头中包含 \u0026#34;Authorization\u0026#34; 头信息 any - 无条件启用压缩 gzip_vary on # 和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩 gzip_disable \u0026#34;MSIE [1-6].\u0026#34; # 禁用IE6的gzip压缩，又是因为杯具的IE6。当然，IE6目前依然广泛的存在，所以这里你也可以设置为“MSIE [1-5].” # IE6的某些版本对gzip的压缩支持很不好，会造成页面的假死，今天产品的同学就测试出了这个问题 后来调试后，发现是对img进行gzip后造成IE6的假死，把对img的gzip压缩去掉后就正常了 为了确保其它的IE6版本不出问题，所以建议加上gzip_disable的设置 可以看到，网页请求的文件只有7.3K\n而实际文件大小大约是10K（10141）\n这张图可以看到response header 中说明了使用了gzip压缩\n参考 https://www.cnblogs.com/yingsong/p/6047311.html http://blog.csdn.net/hjh15827475896/article/details/53432823 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/nginx-%E5%90%AF%E7%94%A8gzip%E5%8E%8B%E7%BC%A9\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos7-%E6%90%AD%E5%BB%BA-ftp-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1\/": {
        "title": "CentOS7 搭建 FTP 文件服务",
        "tags": ["centos","ftp",],
        "content": "安装并启动 FTP 服务 安装 VSFTPD 使用 yum 安装 vsftpd\nyum install -y vsftpd 启动 VSFTPD 安装完成后，启动 FTP 服务：\nservice vsftpd start 启动后，可以看到系统已经监听了 21 端口：\nnetstat -nltp | grep 21 此时，访问 ftp://192.168.3.16 可浏览机器上的 /var/ftp目录了。\n配置 FTP 权限 了解 VSFTP 配置 vsftpd 的配置目录为 /etc/vsftpd，包含下列的配置文件：\nvsftpd.conf 为主要配置文件 ftpusers 配置禁止访问 FTP 服务器的用户列表 user_list 配置用户访问控制\n阻止匿名访问和切换根目录 匿名访问和切换根目录都会给服务器带来安全风险，我们把这两个功能关闭。\n编辑 /etc/vsftpd/vsftpd.conf，找到下面两处配置并修改：\n# 禁用匿名用户 12 YES 改为NO anonymous_enable=NO # 禁止切换根目录 101 行 删除# chroot_local_user=YES 编辑完成后保存配置，重新启动 FTP 服务\nservice vsftpd restart 创建 FTP 用户 创建一个用户 ftpuser\nuseradd ftpuser 为用户 ftpuser 设置密码\necho \u0026ldquo;password\u0026rdquo; | passwd ftpuser \u0026ndash;stdin\n限制该用户仅能通过 FTP 访问 限制用户 ftpuser只能通过 FTP 访问服务器，而不能直接登录服务器：\nusermod -s /sbin/nologin ftpuser\n为用户分配主目录 为用户 ftpuser创建主目录并约定：\n/data/ftp 为主目录, 该目录不可上传文件 /data/ftp/pub 文件只能上传到该目录下\n在/data中创建相关的目录\nmkdir -p /data/ftp/pub 创建登录欢迎文件 echo \u0026#34;Welcome to use FTP service.\u0026#34; \u0026gt; /data/ftp/welcome.txt 设置访问权限\nchmod a-w /data/ftp \u0026amp;\u0026amp; chmod 777 -R /data/ftp/pub 设置为用户的主目录：\nusermod -d /data/ftp ftpuser 访问FTP 根据您个人的工作环境，选择一种方式来访问已经搭建的 FTP 服务\n注意：记得关闭防火墙或者开放FTP默认端口(21)\n# 关闭SELinux服务 setenforce 0 # 关闭防火墙 iptables -F 通过 Windows 资源管理器访问 Windows 用户可以复制下面的链接 到资源管理器的地址栏访问：\nftp://ftpuser:password@192.168.1.170 其中ftpuser为登录FTP的用户名，password为登录FTP的密码\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos7-%E6%90%AD%E5%BB%BA-ftp-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/ftp\/": {
        "title": "ftp",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/ftp\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos6.5%E5%AE%89%E8%A3%85git\/": {
        "title": "Centos6.5安装git",
        "tags": ["centos","git",],
        "content": "安装编译git时需要的包 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel yum install gcc perl-ExtUtils-MakeMaker 删除已有的git yum remove git 下载git源码 地址：https://www.kernel.org/pub/software/scm/git/ 选择要安装的版本\ncd /opt/local/src wget https://www.kernel.org/pub/software/scm/git/git-x.x.x.tar.gz tar xzf git-x.x.x.tar.gz 编译安装 cd git-x.x.x make prefix=/usr/local/git all make prefix=/usr/local/git install echo \u0026#34;export PATH=$PATH:/usr/local/git/bin\u0026#34; \u0026gt;\u0026gt; /etc/bashrc source /etc/bashrc ``` ###### 检查一下版本号 ```bash git --version ``` ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos6.5%E5%AE%89%E8%A3%85git\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/git\/": {
        "title": "git",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/git\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos7%E4%B8%8B%E5%AE%89%E8%A3%85gui%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2\/": {
        "title": "centOS7下安装GUI图形界面",
        "tags": ["linux",],
        "content": "1 .在命令行下 输入下面的命令来安装Gnome包。 yum groupinstall \u0026#34;GNOME Desktop\u0026#34; \u0026#34;Graphical Administration Tools\u0026#34; 2.在命令行输入startx进入桌面 startx 3.如果想开机就进桌面，那就更新系统的运行级别。 ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target 4.重启机器。启动默认进入图形界面。 reboot ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos7%E4%B8%8B%E5%AE%89%E8%A3%85gui%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/vboxadd.sh-failed-modprobe-vboxguest-failed.\/": {
        "title": "vboxadd.sh failed modprobe vboxguest failed.",
        "tags": ["linux",],
        "content": "virtualbox安装增强功能报错：\nvboxadd.sh failed modprobe vboxguest failed. 解决方法：\nyum install dkms binutils gcc make patch libgomp glibc-headers glibc-devel kernel-headers then\nyum install kernel-devel or\nyum install kernel-PAE-devel Then\nre-run VBoxLinuxAdditions.run. ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/vboxadd.sh-failed-modprobe-vboxguest-failed.\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E8%A3%85%E5%AE%8Ccentos7%E6%8F%90%E7%A4%BAinitial-setup-of-centos-linux-7-core\/": {
        "title": "装完Centos7提示Initial setup of CentOS Linux 7 (core)",
        "tags": ["linux",],
        "content": "Initial setup of CentOS Linux 7 (core) 1) [x] Creat user 2) [!] License information (no user will be created) (license not accepted) Please make your choice from above [\u0026#39;q\u0026#39; to quit | \u0026#39;c\u0026#39; to continue | \u0026#39;r\u0026#39; to refresh]: 解决方法： 输入“1”，按Enter键 输入“2”，按Enter键 输入“q\u0026quot;，按Enter键 输入“yes”，按Enter键\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E8%A3%85%E5%AE%8Ccentos7%E6%8F%90%E7%A4%BAinitial-setup-of-centos-linux-7-core\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/mysql%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%E5%91%BD%E4%BB%A4\/": {
        "title": "mysql添加索引命令",
        "tags": ["mysql",],
        "content": "1.PRIMARY KEY（主键索引） mysql\u0026gt;ALTER TABLE `table_name` ADD PRIMARY KEY (`column`) 2.UNIQUE(唯一索引) mysql\u0026gt;ALTER TABLE `table_name` ADD UNIQUE (`column` ) 3.INDEX(普通索引) mysql\u0026gt;ALTER TABLE `table_name` ADD INDEX index_name (`column`) 4.FULLTEXT(全文索引) mysql\u0026gt;ALTER TABLE `table_name` ADD FULLTEXT (`column`) 5.多列索引 mysql\u0026gt;ALTER TABLE `table_name` ADD INDEX index_name (`column1`, `column2`, `column3`) ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/mysql%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%E5%91%BD%E4%BB%A4\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/mysql%E6%9F%A5%E8%AF%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A1%A8\/": {
        "title": "mysql查询出的数据插入另一个表",
        "tags": ["mysql",],
        "content": "1. INSERT INTO 表名1(字段列表1) SELECT 字段列表2 FROM 表名2 WHERE 条件表达式; 2. INSERT INTO 表名1(字段列表1) select * from (select 字段 from *) 临时表名 INSERT INTO 要插入数据的表 (字段1,字段2,....) SELECT * FROM (查询数据的sql语句) 临时表名 2-例子： INSERT INTO purchaseandsale_export (`name`) SELECT * FROM (SELECT name FROM `worker`) temp ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/mysql%E6%9F%A5%E8%AF%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A1%A8\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/mysqli-statement-execute-error-statement-violates-gtid-consistency-create-table-...-\/": {
        "title": "Mysqli statement execute error  Statement violates GTID consistency CREATE TABLE ...",
        "tags": ["mysql",],
        "content": "解决：\n在my.cnf 中将\ngtid_mode = ON enforce_gtid_consistency = ON 改为\ngtid_mode = OFF\renforce_gtid_consistency = OFF 要两个参数一起改,然后重启mysql，问题解决\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/mysqli-statement-execute-error-statement-violates-gtid-consistency-create-table-...-\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/linux%E5%AE%89%E8%A3%85pear\/": {
        "title": "linux安装pear",
        "tags": ["linux","php",],
        "content": "看图操作\n这是错误，先放在前面，以免出现错误不知道怎么办 出现这个错误就按照它的那个地址下载现在在执行安装就好了 安装过程，基本上一路回车就可以了 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/linux%E5%AE%89%E8%A3%85pear\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93\/": {
        "title": "git将本地代码提交到远程仓库",
        "tags": ["git",],
        "content": "touch README.md git init git add README.md git add . git commit -m \u0026#34;first commit\u0026#34; git remote add origin git@xx.xx.xx.xx:repos/xxx/xxx/xxx.git git push -u origin 分支名 可能会遇到这个问题 出现错误的原因是git服务器中的README.md文件不在本地代码目录中，可以通过如下命令进行代码合并\ngit pull --rebase origin master ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/php%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E7%A1%AE%E8%BF%90%E7%AE%97\/": {
        "title": "php浮点数精确运算",
        "tags": ["php",],
        "content": "如果用php的+-*/计算浮点数的时候，可能会遇到一些计算结果错误的问题，所以基本上大部分语言都提供了精准计算的类库或函数库，比如php有BC高精确度函数库，下面我们介绍一下一些常用的BC高精确度函数使用。\nbc是Binary Calculator的缩写。bc*函数的参数都是操作数加上一个可选的 [int scale]，比如string bcadd(string $left_operand, string $right_operand[, int $scale])，如果scale没有提供，就用bcscale的缺省值。这里大数直接用一个由0-9组成的string表示，计算结果返回的也是一个 string。\nbcadd — 将两个高精度数字相加 bccomp — 比较两个高精度数字，返回-1, 0, 1 bcdiv — 将两个高精度数字相除 bcmod — 求高精度数字余数 bcmul — 将两个高精度数字相乘 bcpow — 求高精度数字乘方 bcpowmod — 求高精度数字乘方求模，数论里非常常用 bcscale — 配置默认小数点位数，相当于就是Linux bc中的”scale=” bcsqrt — 求高精度数字平方根 bcsub — 将两个高精度数字相减\n首先看一段代码:\n\u0026lt;?php $a = 0.1; $b = 0.7; var_dump(($a + $b) == 0.8); 打印出来的值居然为 boolean false\n这是为啥?PHP手册对于浮点数有以下警告信息:\nWarning 浮点数精度 显然简单的十进制分数如同 0.1 或 0.7 不能在不丢失一点点精度的情况下转换为内部二进制的格式。这就会造成混乱的结果：例如，floor((0.1+0.7)*10) 通常会返回 7 而不是预期中的 8，因为该结果内部的表示其实是类似 7.9999999999\u0026hellip;。 这和一个事实有关，那就是不可能精确的用有限位数表达某些十进制分数。例如，十进制的 1/3 变成了 0.3333333. . .。 所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用任意精度数学函数或者 gmp 函数\n那么上面的算式我们应该改写为\n\u0026lt;?php $a = 0.1; $b = 0.7; var_dump(bcadd($a,$b,2) == 0.8); 这样就能解决浮点数的计算问题了\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/php%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E7%A1%AE%E8%BF%90%E7%AE%97\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E9%80%A24%E8%BF%9B5%E9%80%A25%E8%BF%9B1005%E5%80%BC%E4%B8%8D%E5%8F%98\/": {
        "title": "逢4进5,逢5进10。0,5值不变",
        "tags": ["php",],
        "content": "\u0026lt;?php //逢4进5,逢5进10。0,5值不变 function ceiling($number = 0){ if($number == 0){ return 0; } //这里取出整数 $number = explode(\u0026#39;.\u0026#39;,$number); $number = $number[0]; $cc = $number%10; $price = $number; if($cc \u0026gt; 5){ $price = $number+(10-$cc); }elseif ($cc \u0026gt; 0) { $price = $number+(5-$cc); } return $price; } ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E9%80%A24%E8%BF%9B5%E9%80%A25%E8%BF%9B1005%E5%80%BC%E4%B8%8D%E5%8F%98\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/php%E4%B8%8B%E5%AE%89%E8%A3%85event%E6%89%A9%E5%B1%95\/": {
        "title": "php下安装event扩展",
        "tags": ["linux","php",],
        "content": "安装支持库libevent，需要编译高版本（这里以最新版本release-2.1.8-stable为例）\nwget -c https://github.com/libevent/libevent/releases/download/release-2.1.8-stable/libevent-2.1.8-stable.tar.gz -P /opt/local/src cd /opt/local/src tar -zxvf libevent-2.1.8-stable.tar.gz \u0026amp;\u0026amp; cd libevent-2.1.8-stable ./configure --prefix=/opt/local/libevent make \u0026amp;\u0026amp; make install 安装event库（以event-2.3.0.tgz为例）\nwget -c http://pecl.php.net/get/event-2.3.0.tgz -P /opt/local/src cd /opt/local/src tar -zxvf event-2.3.0.tgz \u0026amp;\u0026amp; cd event-2.3.0 /opt/local/php72/bin/bin/phpize ./configure --with-php-config=/opt/local/php72/bin/php-config --with-event-libevent-dir=/opt/local/libevent/ make \u0026amp;\u0026amp; make install 在php.ini添加下面配置\nextension=event.so ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/php%E4%B8%8B%E5%AE%89%E8%A3%85event%E6%89%A9%E5%B1%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/redis\/": {
        "title": "redis",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/redis\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85redis\/": {
        "title": "编译安装redis",
        "tags": ["linux","redis",],
        "content": "一.安装Redis (1) cd /usr/src 进入下载目录\n(1) yum install -y wget gcc make tcl 安装依赖\n(2) redis官网http://www.redis.io下载最新的源码包\n(3) tar -zxvf redis-3.2.2.tar.gz 解压\n(4) cd redis-3.2.2 进入redis目录\n(5) make 编辑\n(6) make test 测试\n测试过程报错\n[exception]: Executing test client: NOREPLICAS Not enough good slaves to write.. NOREPLICAS Not enough good slaves to write. while executing\n这种情况下，可以修改当前目录文件tests/integration/replication-2.tcl，将after 1000改为after 10000以延长等待时间 重新测试\n(7)make install PREFIX=/usr/local/redis PREFIX安装指定目录 否则安装到/usr/local/bin里面了\n(8)启动redis服务 ./redis-server ./redis-conf\n发现很多错误：\n1.\nWARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128 echo 511 \u0026gt; /proc/sys/net/core/somaxconn 写到/etc/rc.local里面 rc.local 是开机启动程序 是一个软连接 （确定两者都有执行权限）\nlrwxrwxrwx. 1 root root 13 Aug 2 07:50 /etc/rc.local -\u0026gt; rc.d/rc.local 2.\nWARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add \u0026#39;vm.overcommit_memory = 1\u0026#39; to /etc/sysctl.conf and then reboot or run the command \u0026#39;sysctl vm.overcommit_memory=1\u0026#39; for this to take effect. 往/etc/sysctl.conf 中添加vm.overcommit_memory = 1\n3.\nWARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command \u0026#39;echo never \u0026gt; /sys/kernel/mm/transparent_hugepage/enabled\u0026#39; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled. echo never \u0026gt; /sys/kernel/mm/transparent_hugepage/enabled 写到/etc/rc.local里面\n还有想在后台运行的话修改配置redis.conf daemonize yes 就可以了\n(9)运行./redis-cli\n./redis-cli 127.0.0.1:6379\u0026gt; set 1 2 OK 127.0.0.1:6379\u0026gt; get 1 \u0026#34;2\u0026#34; 127.0.0.1:6379\u0026gt; quit 二.Redis配置说明 Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程\ndaemonize no\n当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\npidfile /var/run/redis.pid\n指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字\nport 6379\n绑定的主机地址\nbind 127.0.0.1\n当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\ntimeout 300\n指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\nloglevel verbose\n日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null\nlogfile stdout\n设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id\ndatabases 16\n指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\nsave Redis默认配置文件中提供了三个条件：\nsave 900 1\nsave 300 10\nsave 60 10000\n分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。\n指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\nrdbcompression yes\n指定本地数据库文件名，默认值为dump.rdb\ndbfilename dump.rdb\n指定本地数据库存放目录\ndir ./\n设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\nslaveof 当master服务设置了密码保护时，slav服务连接master的密码\nmasterauth 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭\nrequirepass foobared\n设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息\nmaxclients 128\n指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区\nmaxmemory 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no\nappendonly no\n指定更新日志文件名，默认为appendonly.aof\nappendfilename appendonly.aof\n指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值）\nappendfsync everysec\n指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）\nvm-enabled no\n虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享\nvm-swap-file /tmp/redis.swap\n将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0\nvm-max-memory 0\nRedis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值\nvm-page-size 32\n设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。\nvm-pages 134217728\n设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4\nvm-max-threads 4\n设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\nglueoutputbuf yes\n指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\nhash-max-zipmap-entries 64\nhash-max-zipmap-value 512\n指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）\nactiverehashing yes\n指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件\ninclude /path/to/local.conf\n增加服务并开机启动 redis启动脚本\n#!/bin/bash #chkconfig: 2345 55 25 #description: Starts,stops and restart the redis-server #Ver:1.1 #Write by ND chengh(200808) #usage: ./script_name -p [port] {start|stop|status|restart} # Source function library. . /etc/rc.d/init.d/functions # Source networking configuration. . /etc/sysconfig/network # Check networking is up. [ \u0026#34;$NETWORKING\u0026#34; = \u0026#34;no\u0026#34; ] \u0026amp;\u0026amp; exit 0 RETVAL=0 REDIS_PORT=6379 PID= if [ \u0026#34;$1\u0026#34; = \u0026#34;-p\u0026#34; ]; then REDIS_PORT=$2 shift 2 fi REDIS_DIR=\u0026#34;/opt/local/redis\u0026#34; REDIS=\u0026#34;${REDIS_DIR}/bin/redis-server\u0026#34; PROG=$(basename $REDIS) CONF=\u0026#34;${REDIS_DIR}/etc/redis-${REDIS_PORT}.conf\u0026#34; if [ ! -f $CONF ]; then if [ -f \u0026#34;${REDIS_DIR}/etc/redis.conf\u0026#34; ];then CONF=\u0026#34;${REDIS_DIR}/etc/redis.conf\u0026#34; else echo -n $\u0026#34;$CONF not exist.\u0026#34;;warning;echo exit 1 fi fi PID_FILE=`grep \u0026#34;pidfile\u0026#34; ${CONF}|cut -d \u0026#39; \u0026#39; -f2` PID_FILE=${PID_FILE:=/var/run/redis.pid} LOCKFILE=\u0026#34;/var/lock/subsys/redis-${REDIS_PORT}\u0026#34; if [ ! -x $REDIS ]; then echo -n $\u0026#34;$REDIS not exist.\u0026#34;;warning;echo exit 0 fi start() { echo -n $\u0026#34;Starting $PROG: \u0026#34; $REDIS $CONF RETVAL=$? if [ $RETVAL -eq 0 ]; then success;echo;touch $LOCKFILE else failure;echo fi return $RETVAL } stop() { echo -n $\u0026#34;Stopping $PROG: \u0026#34; if [ -f $PID_FILE ] ;then read PID \u0026lt; \u0026#34;$PID_FILE\u0026#34; else failure;echo; echo -n $\u0026#34;$PID_FILE not found.\u0026#34;;failure;echo return 1; fi if checkpid $PID; then kill -TERM $PID \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 RETVAL=$? if [ $RETVAL -eq 0 ] ;then success;echo echo -n \u0026#34;Waiting for Redis to shutdown ..\u0026#34; while checkpid $PID;do echo -n \u0026#34;.\u0026#34; sleep 1; done success;echo;rm -f $LOCKFILE else failure;echo fi else echo -n $\u0026#34;Redis is dead and $PID_FILE exists.\u0026#34;;failure;echo RETVAL=7 fi return $RETVAL } restart() { stop start } rhstatus() { status -p ${PID_FILE} $PROG } hid_status() { rhstatus \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 } case \u0026#34;$1\u0026#34; in start) hid_status \u0026amp;\u0026amp; exit 0 start ;; stop) rhstatus || exit 0 stop ;; restart) restart ;; status) rhstatus RETVAL=$? ;; *) echo $\u0026#34;Usage: $0 -p [port] {start|stop|status|restart}\u0026#34; RETVAL=1 esac exit $RETVAL 把redis脚本文件放在 /etc/rc.d/init.d/ 目录下\nchmod +x /etc/rc.d/init.d/redis chkconfig --add redis chkconfig --level 345 redis on chkconfig --list redis ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85redis\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/php%E5%AF%BC%E5%87%BAcsv\/": {
        "title": "php导出CSV",
        "tags": ["php",],
        "content": "\u0026lt;?php //导出的首行标题以及需要导出的字段 $parm = array( \u0026#34;公司名称\u0026#34;=\u0026gt;\u0026#39;business_name\u0026#39;, \u0026#39;公司城市\u0026#39;=\u0026gt;\u0026#39;province\u0026#39;, \u0026#39;公司地址\u0026#39;=\u0026gt;\u0026#39;detail_addr_\u0026#39; ); /** * 导出CSV文件 * @param array $data 数据 * @param array $header_data 首行数据 * @param string $file_name 文件名称 * @param string $body_data 需要导出的字段名 * @return string */ public function export_csv($data = [], $parm = [], $file_name = \u0026#39;\u0026#39;) { header(\u0026#39;Content-Type: application/vnd.ms-excel\u0026#39;); header(\u0026#39;Content-Disposition: attachment;filename=\u0026#39;.$file_name); header(\u0026#39;Cache-Control: max-age=0\u0026#39;); $fp = fopen(\u0026#39;php://output\u0026#39;, \u0026#39;a\u0026#39;); $header_data = array_keys($parm); $body_data = array_values($parm); if (!empty($header_data)) { foreach ($header_data as $key =\u0026gt; $value) { $header_data[$key] = iconv(\u0026#39;utf-8\u0026#39;, \u0026#39;gbk\u0026#39;, $value); } fputcsv($fp, $header_data); } $num = 0; $limit = 100000; //逐行取出数据，不浪费内存 $count = count($data); if ($count \u0026gt; 0) { for ($i = 0; $i \u0026lt; $count; $i++) { $num++; //刷新一下输出buffer，防止由于数据过多造成问题 if ($limit == $num) { ob_flush(); flush(); $num = 0; } $row = []; $export_data = $data[$i]; foreach ($export_data as $key =\u0026gt; $value) { if(!in_array($key,$body_data)){ continue; }else{ foreach($body_data as $key1=\u0026gt;$value1){ $row[$value1] = iconv(\u0026#39;utf-8\u0026#39;, \u0026#39;gbk\u0026#39;, $export_data[$value1]); } } } fputcsv($fp, $row); } } fclose($fp); } public function export_csv_1($data = [], $header_data = [], $file_name = \u0026#39;\u0026#39;) { header(\u0026#39;Content-Type: application/octet-stream\u0026#39;); header(\u0026#39;Content-Disposition: attachment; filename=\u0026#39; . $file_name); if (!empty($header_data)) { echo iconv(\u0026#39;utf-8\u0026#39;,\u0026#39;gbk//TRANSLIT\u0026#39;,\u0026#39;\u0026#34;\u0026#39;.implode(\u0026#39;\u0026#34;,\u0026#34;\u0026#39;,$header_data).\u0026#39;\u0026#34;\u0026#39;.\u0026#34;\\n\u0026#34;); } foreach ($data as $key =\u0026gt; $value) { $output = array(); $output[] = $value[\u0026#39;id\u0026#39;]; $output[] = $value[\u0026#39;name\u0026#39;]; echo iconv(\u0026#39;utf-8\u0026#39;,\u0026#39;gbk//TRANSLIT\u0026#39;,\u0026#39;\u0026#34;\u0026#39;.implode(\u0026#39;\u0026#34;,\u0026#34;\u0026#39;, $output).\u0026#34;\\\u0026#34;\\n\u0026#34;); } } ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/php%E5%AF%BC%E5%87%BAcsv\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/device-eth0-does-not-seem-to-be-present%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\/": {
        "title": "虚拟机克隆centos出现“Device eth0 does not seem to be present”解决办法",
        "tags": [],
        "content": "在virtualBox中克隆出新的CentOS虚拟机时，出现如下问题：\nservice network restart Shutting down loopback insterface: [ OK ] Bringing up loopback insterface: [ OK ] Bringing up interface eth0: Device eth0 does not seem to be present,delaying initialization. [FAILED] 用ifconfig查看发现缺少eth0，只有lo；用ifconfig -a查看发现多出了eth1的信息。\n解决办法1：\nmv /etc/sysconfig/network-scripts/ifcfg-eth0 /etcsysconfig/network-scripts/ifcfg-eth1 将eth0的mac地址改为eth1的mac地址，同时改变其DEVICE名称为eth1，再重启网络即可。\n解决办法2：\nrm -rf /etc/udev/rules.d/70-persistent-net.rules reboot 总之，只要保证/etc/sysconfig/network-scripts/ifcfg-eth0 与/etc/udev/rules.d/70-persistent-net.rules的信息一致即可，即网卡地址与网卡编号一致，这样service network restart 就可以配置成功。\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/device-eth0-does-not-seem-to-be-present%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/laravel\/": {
        "title": "laravel",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/laravel\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/laravel%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99runtimeexception-no-application-encryption-key-has-been-specified.\/": {
        "title": "Laravel运行出错RuntimeException No application encryption key has been specified.",
        "tags": ["laravel",],
        "content": "在项目根目录放置.env文件\nAPP_NAME=Laravel APP_ENV=local APP_KEY= APP_DEBUG=true APP_LOG_LEVEL=debug APP_URL=http://localhost DB_CONNECTION=mysql DB_HOST=127.0.0.1 DB_PORT=3306 DB_DATABASE=homestead DB_USERNAME=homestead DB_PASSWORD=secret BROADCAST_DRIVER=log CACHE_DRIVER=file SESSION_DRIVER=file SESSION_LIFETIME=120 QUEUE_DRIVER=sync REDIS_HOST=127.0.0.1 REDIS_PASSWORD=null REDIS_PORT=6379 MAIL_DRIVER=smtp MAIL_HOST=smtp.mailtrap.io MAIL_PORT=2525 MAIL_USERNAME=null MAIL_PASSWORD=null MAIL_ENCRYPTION=null PUSHER_APP_ID= PUSHER_APP_KEY= PUSHER_APP_SECRET= 在项目目录下运行:\nphp artisan key:generate 该命令会生成APP_KEY并写入到.env文件中，重新运行\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/laravel%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99runtimeexception-no-application-encryption-key-has-been-specified.\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/laravel%E8%AE%BF%E9%97%AE%E5%87%BA%E9%94%99%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AFwarning-requirevendorautoload.php-failed-to-open-stream-no-such-file-or-dire\/": {
        "title": "Laravel访问出错错误信息：\u0060Warning require(vendorautoload.php) failed to open stream No such file or dire",
        "tags": ["laravel",],
        "content": "Warning: require(/opt/project/erp_api/public/../vendor/autoload.php): failed to open stream: No such file or directory in /opt/project/erp_api/public/index.php on line 24\nFatal error: require(): Failed opening required \u0026lsquo;/opt/project/erp_api/public/../vendor/autoload.php\u0026rsquo; (include_path=\u0026rsquo;.:\u0026rsquo;) in /opt/project/erp_api/public/index.php on line 24\n原因：网站根目录下缺少vendor这个存放laraver依赖包的目录 解决方法：使用composer install进行安装 （没有安装过的情况下，以前安装过的话使用：composer update）\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/laravel%E8%AE%BF%E9%97%AE%E5%87%BA%E9%94%99%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AFwarning-requirevendorautoload.php-failed-to-open-stream-no-such-file-or-dire\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos7%E4%B8%8B%E5%AE%89%E8%A3%85python3%E5%8F%8Apip3%E5%B9%B6%E4%BF%9D%E7%95%99python2\/": {
        "title": "CentOS7下安装Python3及Pip3并保留Python2",
        "tags": ["linux","python",],
        "content": "安装依赖环境 yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 浏览器打开 https://www.python.org/ftp/python/ 查看最新的Python版本，标记为3.A.B wget https://www.python.org/ftp/python/3.A.B/Python-3.A.B.tgz 创建Python3的目录 mkdir /usr/local/python3 解压下载文件并切换目录 tar -zxvf Python-3.A.B.tgz cd Python-3.A.B 执行 ./configure --prefix=/usr/local/python3 make \u0026amp;\u0026amp; make install 创建Python3的软链接 ln -s /usr/local/python3/bin/python3 /usr/bin/python3 创建Pip3的软链接 ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 测试命令 python3 和 pip3 python3 pip3 因为执行yum需要python2版本，所以我们还要修改yum的配置，执行： vim /usr/bin/yum 把#! /usr/bin/python修改为#! /usr/bin/python2\n同理 vim /usr/libexec/urlgrabber-ext-down 文件里面的#! /usr/bin/python 也要修改为#! /usr/bin/python2\n安装保留了原python命令调用python2\n安装完成\nps 安装报错 Q： ModuleNotFoundError: No module named \u0026#39;_ctypes\u0026#39; A： yum -y install gcc gcc-c++ yum -y install zlib zlib-devel yum -y install libffi-devel Q：configure: error: no acceptable C compiler found in $PATH A：yum install gcc ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos7%E4%B8%8B%E5%AE%89%E8%A3%85python3%E5%8F%8Apip3%E5%B9%B6%E4%BF%9D%E7%95%99python2\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/python\/": {
        "title": "python",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/python\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/gcc\/": {
        "title": "gcc",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/gcc\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E8%A7%A3%E5%86%B3configure-error-no-acceptable-c-compiler-found-in-path\/": {
        "title": "解决\u0022configure error no acceptable C compiler found in $PATH\u0022",
        "tags": ["linux","gcc",],
        "content": "解决方法： 安装gcc\nyum install gcc ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E8%A7%A3%E5%86%B3configure-error-no-acceptable-c-compiler-found-in-path\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/php%E7%9A%84socket%E9%80%9A%E4%BF%A1\/": {
        "title": "php的socket通信",
        "tags": ["php","socket",],
        "content": "对TCP/IP、UDP、Socket编程这些词你不会很陌生吧？随着网络技术的发展，这些词充斥着我们的耳朵。那么我想问：\n什么是TCP/IP、UDP？ Socket在哪里呢？ Socket是什么呢？ 你会使用它们吗？ 什么是TCP/IP、UDP？ TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。 这里有一张图，表明了这些协议的关系。\nTCP/IP协议族包括运输层、网络层、链路层。\nSocket在哪里呢？ 在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。\n原来Socket在这里。\nSocket是什么呢？ Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 你会使用它们吗？ 前人已经给我们做了好多的事了，网络间的通信也就简单了许多，但毕竟还是有挺多工作要做的。以前听到Socket编程，觉得它是比较高深的编程知识，但是只要弄清Socket编程的工作原理，神秘的面纱也就揭开了。 一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理，也许TCP/IP协议族就是诞生于生活中，这也不一定。\n先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。\nsocket相关函数： \u0026lt;?php socket_accept() 接受一个Socket连接 socket_bind() 把socket绑定在一个IP地址和端口上 socket_clear_error() 清除socket的错误或者最后的错误代码 socket_close() 关闭一个socket资源 socket_connect() 开始一个socket连接 socket_create_listen() 在指定端口打开一个socket监听 socket_create_pair() 产生一对没有区别的socket到一个数组里 socket_create() 产生一个socket，相当于产生一个socket的数据结构 socket_get_option() 获取socket选项 socket_getpeername() 获取远程类似主机的ip地址 socket_getsockname() 获取本地socket的ip地址 socket_iovec_add() 添加一个新的向量到一个分散/聚合的数组 socket_iovec_alloc() 这个函数创建一个能够发送接收读写的iovec数据结构 socket_iovec_delete() 删除一个已经分配的iovec socket_iovec_fetch() 返回指定的iovec资源的数据 socket_iovec_free() 释放一个iovec资源 socket_iovec_set() 设置iovec的数据新值 socket_last_error() 获取当前socket的最后错误代码 socket_listen() 监听由指定socket的所有连接 socket_read() 读取指定长度的数据 socket_readv() 读取从分散/聚合数组过来的数据 socket_recv() 从socket里结束数据到缓存 socket_recvfrom() 接受数据从指定的socket，如果没有指定则默认当前socket socket_recvmsg() 从iovec里接受消息 socket_select() 多路选择 socket_send() 这个函数发送数据到已连接的socket socket_sendmsg() 发送消息到socket socket_sendto() 发送消息到指定地址的socket socket_set_block() 在socket里设置为块模式 socket_set_nonblock() socket里设置为非块模式 socket_set_option() 设置socket选项 socket_shutdown() 这个函数允许你关闭读、写、或者指定的socket socket_strerror() 返回指定错误号的详细错误 socket_write() 写数据到socket缓存 socket_writev() 写数据到分散/聚合数组 案例一：socket通信演示 服务器端：\n\u0026lt;?php //确保在连接客户端时不会超时 set_time_limit(0); $ip = \u0026#39;127.0.0.1\u0026#39;; $port = 2018; /* +------------------------------- * @socket通信整个过程 +------------------------------- * @socket_create * @socket_bind * @socket_listen * @socket_accept * @socket_read * @socket_write * @socket_close +-------------------------------- */ /*---------------- 以下操作都是手册上的 -------------------*/ if(($sock = socket_create(AF_INET,SOCK_STREAM,SOL_TCP)) \u0026lt; 0) { echo \u0026#34;socket_create() 失败的原因是:\u0026#34;.socket_strerror($sock).\u0026#34;\\n\u0026#34;; } if(($ret = socket_bind($sock,$ip,$port)) \u0026lt; 0) { echo \u0026#34;socket_bind() 失败的原因是:\u0026#34;.socket_strerror($ret).\u0026#34;\\n\u0026#34;; } if(($ret = socket_listen($sock,4)) \u0026lt; 0) { echo \u0026#34;socket_listen() 失败的原因是:\u0026#34;.socket_strerror($ret).\u0026#34;\\n\u0026#34;; } $count = 0; do { if (($msgsock = socket_accept($sock)) \u0026lt; 0) { echo \u0026#34;socket_accept() failed: reason: \u0026#34; . socket_strerror($msgsock) . \u0026#34;\\n\u0026#34;; break; } else { //发到客户端 $msg =\u0026#34;测试成功！\\n\u0026#34;; socket_write($msgsock, $msg, strlen($msg)); echo \u0026#34;测试成功了啊\\n\u0026#34;; $buf = socket_read($msgsock,8192); $talkback = \u0026#34;收到的信息:$buf\\n\u0026#34;; echo $talkback; if(++$count \u0026gt;= 5){ break; }; } //echo $buf; socket_close($msgsock); } while (true); socket_close($sock); 这是socket的服务端代码,然后在命令行运行\n没有反映，对现在服务端的程序已经开始运行，端口已经开始监听了。运行netstat -nltp可以查看端口情况，我的是2018端口\n端口已经处于LISTENING状态了。接下来我们只要运行客户端程序即可连接上。代码如下\n\u0026lt;?php error_reporting(E_ALL); set_time_limit(0); echo \u0026#34;\u0026lt;h2\u0026gt;TCP/IP Connection\u0026lt;/h2\u0026gt;\\n\u0026#34;; $port = 2018; $ip = \u0026#34;127.0.0.1\u0026#34;; /* +------------------------------- * @socket连接整个过程 +------------------------------- * @socket_create * @socket_connect * @socket_write * @socket_read * @socket_close +-------------------------------- */ $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); if ($socket \u0026lt; 0) { echo \u0026#34;socket_create() failed: reason: \u0026#34; . socket_strerror($socket) . \u0026#34;\\n\u0026#34;; }else { echo \u0026#34;OK.\\n\u0026#34;; } echo \u0026#34;试图连接 \u0026#39;$ip\u0026#39; 端口 \u0026#39;$port\u0026#39;...\\n\u0026#34;; $result = socket_connect($socket, $ip, $port); if ($result \u0026lt; 0) { echo \u0026#34;socket_connect() failed.\\nReason: ($result) \u0026#34; . socket_strerror($result) . \u0026#34;\\n\u0026#34;; }else { echo \u0026#34;连接OK\\n\u0026#34;; } $in = \u0026#34;Yo\\r\\n\u0026#34;; $in .= \u0026#34;hello world\\r\\n\u0026#34;; $out = \u0026#39;\u0026#39;; if(!socket_write($socket, $in, strlen($in))) { echo \u0026#34;socket_write() failed: reason: \u0026#34; . socket_strerror($socket) . \u0026#34;\\n\u0026#34;; }else { echo \u0026#34;发送到服务器信息成功！\\n\u0026#34;; echo \u0026#34;发送的内容为: $in \\n\u0026#34;; } while($out = socket_read($socket, 8192)) { echo \u0026#34;接收服务器回传信息成功！\\n\u0026#34;; echo \u0026#34;接受的内容为:\u0026#34;,$out; } echo \u0026#34;关闭SOCKET...\\n\u0026#34;; socket_close($socket); echo \u0026#34;关闭OK\\n\u0026#34;; 至此客户端已经连接上服务端了。\n案例二：代码详解 \u0026lt;?php // 设置一些基本的变量 $host = \u0026#34;192.168.1.99\u0026#34;; $port = 1234; // 设置超时时间 set_time_limit(0); // 创建一个Socket $socket = socket_create(AF_INET, SOCK_STREAM, 0) or die(\u0026#34;Could not createsocket\\n\u0026#34;); //绑定Socket到端口 $result = socket_bind($socket, $host, $port) or die(\u0026#34;Could not bind tosocket\\n\u0026#34;); // 开始监听链接 $result = socket_listen($socket, 3) or die(\u0026#34;Could not set up socketlistener\\n\u0026#34;); // accept incoming connections // 另一个Socket来处理通信 $spawn = socket_accept($socket) or die(\u0026#34;Could not accept incomingconnection\\n\u0026#34;); // 获得客户端的输入 $input = socket_read($spawn, 1024) or die(\u0026#34;Could not read input\\n\u0026#34;); // 清空输入字符串 $input = trim($input); //处理客户端输入并返回结果 $output = strrev($input) . \u0026#34;\\n\u0026#34;; socket_write($spawn, $output, strlen ($output)) or die(\u0026#34;Could not write output\\n\u0026#34;); // 关闭sockets socket_close($spawn); socket_close($socket); 下面是其每一步骤的详细说明: 1 . 第一步是建立两个变量来保存Socket运行的服务器的IP地址和端口.你可以设置为你自己的服务器和端口(这个端口可以是1到65535之间的数字),前提是这个端口未被使用.\n// 设置两个变量 $host = \u0026#34;192.168.1.99\u0026#34;; $port = 1234; 2 . 在服务器端可以使用set_time_out()函数来确保PHP在等待客户端连接时不会超时.\n// 超时时间 set_time_limit(0); 3 . 在前面的基础上,现在该使用socket_creat()函数创建一个Socket了—这个函数返回一个Socket句柄,这个句柄将用在以后所有的函数中.\n// 创建Socket $socket = socket_create(AF_INET, SOCK_STREAM, 0) or die(\u0026#34;Could not create socket\\n\u0026#34;); 第一个参数”AF_INET”用来指定域名; 第二个参数”SOCK_STREM”告诉函数将创建一个什么类型的Socket(在这个例子中是TCP类型)\n因此,如果你想创建一个UDP Socket的话,你可以使用如下的代码:\n// 绑定 socket to 指定地址和端口 $result = socket_bind($socket, $host, $port) or die(\u0026#34;Could not bind to socket\\n\u0026#34;); 4 . 一旦创建了一个Socket句柄,下一步就是指定或者绑定它到指定的地址和端口.这可以通过socket_bind()函数来完成.\n// 绑定 socket to 指定地址和端口 $result = socket_bind($socket, $host, $port) or die(\u0026#34;Could not bind to socket\\n\u0026#34;); 5 . 当Socket被创建好并绑定到一个端口后,就可以开始监听外部的连接了.PHP允许你由socket_listen()函数来开始一个监听,同时你可以指定一个数字(在这个例子中就是第二个参数:3)\n// 开始监听连接 $result = socket_listen($socket, 3) or die(\u0026#34;Could not set up socket listener\\n\u0026#34;); 6 . 到现在,你的服务器除了等待来自客户端的连接请求外基本上什么也没有做.一旦一个客户端的连接被收到,socket_accept()函数便开始起作用了,它接收连接请求并调用另一个子Socket来处理客户端–服务器间的信息.\n//接受请求链接 // 调用子socket 处理信息 $spawn = socket_accept($socket) or die(\u0026#34;Could not accept incoming connection\\n\u0026#34;); 这个子socket现在就可以被随后的客户端–服务器通信所用了.\n7 . 当一个连接被建立后,服务器就会等待客户端发送一些输入信息,这写信息可以由socket_read()函数来获得,并把它赋值给PHP的$input变量.\n// 读取客户端输入 $input = socket_read($spawn, 1024) or die(\u0026#34;Could not read input\\n\u0026#34;); ?\u0026amp;gt; socker_read的第而个参数用以指定读入的字节数,你可以通过它来限制从客户端获取数据的大小.\n注意:socket_read函数会一直读取壳户端数据,直到遇见\\n,\\t或者\\0字符.PHP脚本把这写字符看做是输入的结束符.\n8 . 现在服务器必须处理这些由客户端发来是数据(在这个例子中的处理仅仅包含数据的输入和回传到客户端).这部分可以由socket_write()函数来完成(使得由通信socket发回一个数据流到客户端成为可能)\n// 处理客户端输入并返回数据 $output = strrev($input) . \u0026#34;\\n\u0026#34;; socket_write($spawn, $output, strlen ($output)) or die(\u0026#34;Could not write output\\n\u0026#34;); 9 . 一旦输出被返回到客户端,父/子socket都应通过socket_close()函数来终止\n// 关闭 sockets socket_close($spawn); socket_close($socket); 文章参考：http://www.cnblogs.com/thinksasa/archive/2013/02/26/2934206.html ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/php%E7%9A%84socket%E9%80%9A%E4%BF%A1\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/socket\/": {
        "title": "socket",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/socket\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/php%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0\/": {
        "title": "php设计模式概述",
        "tags": ["php",],
        "content": "工厂模式： 我们定义一个专门用来创建其它对象的类。 这样在需要调用某个类的时候，我们就不需要去使用new关键字实例化这个类，而是通过我们的工厂类调用某个方法得到类的实例。 好处：当我们对象所对应的类的类名发生变化的时候，我们只需要改一下工厂类类里面的实例化方法即可。不需要外部改所有的地方。\n单例模式（口诀：三私一公） class Singleton{ //私有化构造方法，禁止外部实例化对象 private function __construct(){} //私有化__clone，防止对象被克隆 private function __clone(){} //私有化内部实例化的对象 private static $instance = null; // 公有静态实例方法 public static function getInstance(){ if(self::$instance == null){ //内部实例化对象 self::$instance = new self(); } return self::$instance; } } 注册器模式： 用来将一些对象注册到全局的注册树上，可以在任何地方访问。\nset():将对象隐射到全局树上， _unset():从树上移除。 get():去注册到树上的对象。 适配器模式： 1、可以将截然不同的函数接口封装成统一的API 2、实际应用举例：PHP的数据库操作有mysql/mysqli/pdo 三种，可以用适配器模式统一成一致。类似的场景还有cache适配器，可以将memcache/redis/file/apc等不同的缓存函数统一成一致的接口。\n策略模式： 1、策略模式，将一组特定的行为和算法封装成类，以适应某些特定的上下文环境，这种模式就是策略模式 2、实际应用举例，假如一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类名，并且所有广告位展示不同的广告，传统的做法是加入if\u0026hellip;else\u0026hellip; 判断。 如果新增加一种用户类型，只需要新增加一种策略即可 3、使用策略模式可以实现Ioc ,依赖倒置，控制反转\n数据对象映射模式： 1、数据对象映射模式，是将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作，比我们在代码中new一个对象，那么使用该模式就可以将对对象的一些操作，比如说我们设置的一些属性，它就会自动保存到数据库，跟数据库中表的一条记录对应起来 实例，在代码中实现数据对象映射模式，我们将写一个ORM类，将复杂的SQL语句映射成对象属性的操作 结合使用数据对象映射模式，工厂模式，注册模式\n对象关系映射 对象关系映射（英语：Object Relation Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换[1] 。从效果上说，它其实是创建了一个可在编程语言里使用的\u0026ndash;“虚拟对象数据库”。 面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象，对象关系映射技术应运而生 简单的说：ORM相当于中继数据\n适配器模式： 1、可以将截然不同的函数接口封装成统一的API 2、实际应用举例：PHP的数据库操作有mysql/mysqli/pdo 三种，可以用适配器模式统一成一致。类似的场景还有cache适配器，可以将memcache/redis/file/apc等不同的缓存函数统一成一致的接口。\n观察者模式 1、 观察者模式（ Observer ），当一个对象状态发生改变时，依赖它的对象全部会收到通知，并自动更新 2、 场景：一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理逻辑。当更新的逻辑增多后，代码会变得难以维护。这种方式是耦合的，入侵式的，增加新的逻辑需要修改事件主体的代码 3、观察者模式实现了低耦合，非入侵式的通知与更新机制\n原型模式 1、 与工厂模式作用类似，都是用来创建对象 2、 与工厂模式的实现不懂，原型模式是首先创建好一个原型对象，然后通过clone原型对象来创建新的对象。这样就免去了类创建是重复的初始化操作 3、 原型模式适用于大对象的创建。创建一个大对象需要很大的开销，如果每次new就会消耗很大，原型模式仅需内存拷贝即可\n装饰器模式 1、装饰器模式（Decorator）可以动态地添加修改类的功能 2、一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要写一个子类继承它，并重新实现类的方法 3、使用装饰器模式，仅需在运行时添加一个装饰器对象即可实现，可以实现最大的灵活性\n迭代器模式 1、 迭代器模式，在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素。 2、 相比传统的编程模式，迭代器模式可以隐藏遍历元素的所需操作。\n代理模式 1、 在客户端与实体之间建立一个代理对象（proxy），客户端对实体进行的操作全部委派给代理对象，隐藏实体的具体实现细节。 2、 Proxy还可以与业务代码分离，部署到另外的服务器，业务代码中通过RPC来委派任务。\n面向对象编程的基本原则： 1、单一职责：一个类，只需要做好一件事，一个文件中最好只有一个类 2、开放封闭：一个类，应该是可扩展的，而不可修改的。 3、依赖倒置：一个类，不应该强依赖另一个类。每个类对于另外一个类都是可替换的。 4、配置化：尽可能地使用配置，而不是硬编码。 5、面向接口编程：只需要关心接口，不需要关心实现。\nmvc结构 1、model：对数据库的操作 2、view：视图，例如模板文件 3、controller：逻辑层，实现业务逻辑部分\n配置和设计模式 1、php中使用ArrayAccess实现配置文件的加载 2、在工厂方法中读取配置,生成可配置化对象 3、使用装饰模式实现权限验证,模板渲染,json串化 4、使用观察者模式实现数据跟新时间的一系列更新操作 5、使用代理模式实现数据库的主从自动切换\nPHP魔术方法的使用： __get/ __set 将对象的属性进行接管，访问/设置不存在的属性时 __call/ __callStatic 控制对象的方法调用，访问不存在的方法、静态方法时 __toString 将php对象转化为字符串 __invoke 将php对象当作一个函数来执行时会调用这个方法 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/php%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/nginx%E9%85%8D%E7%BD%AEhttps\/": {
        "title": "nginx配置HTTPS",
        "tags": ["nginx",],
        "content": "PS：设置HTTPS nginx需要添加ssl模块 \u0026ndash;with-http_ssl_module 在nginx的conf目录下新增ssl目录，并进入。 生成服务器端的私钥(key文件): openssl genrsa -des3 -out server.key 2048 运行时会提示输入密码,此密码用于加密key文件(参数des3便是指加密算法,当然也可以选用其他你认为安全的算法.),以后每当需读取此文件(通过openssl提供的命令或API)都需输入口令.如果觉得不方便,也可以去除这个口令,但一定要采取其他的保护措施! 去除key文件口令的命令：\nopenssl rsa -in server.key -out server.key 用刚生成的服务器私钥，生成证书请求文件。 openssl req -new -key server.key -out server.csr 生成Certificate Signing Request（CSR）,生成的csr文件交给CA签名后形成服务端自己的证书.\n同样的命令生成生成客户端的私钥(key 文件)和证书请求文件Certificate Signing Request（CSR） openssl genrsa -des3 -out client.key 2048 openssl req -new -key client.key -out client.csr 生成的CSR证书文件必须有CA的签名才可形成证书。这里制作自己的CA， 这时生成一个KEY文件ca.key 和根证书ca.crt。默认生成CA证书有效期是一个月，可以添加-days 365,设置有效期即为365天。 openssl req -new -x509 -keyout ca.key -out ca.crt -days 365 签署证书准备工作： [root@centos65 ssl]# vim /etc/pki/tls/openssl.cnf #修改如下 dir = /etc/pki/CA #根据openssl.cnf生成配置文件 [root@centos65 ssl]# touch /etc/pki/CA/{index.txt,serial} [root@centos65 ssl]#echo 01 \u0026gt; /etc/pki/CA/serial 用生成的CA的证书(ca.crt)为刚才生成的服务器请求文件server.csr生成对应CA签名后的crt文件。默认有效期是365天，命令后增加-days 3650，即设置有效期为3650天。 openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key 用生成的CA的证书(ca.crt)为刚才生成的客户端请求文件client.csr生成对应CA签名后的crt文件。注意：可能直接运行会报以下错误，修改对应index.txt.attr文件unique_subject = no，重新运行即可。默认有效期是365天，命令后增加-days 1，即设置有效期为1天。 openssl ca -in client.csr -out client.crt -cert ca.crt -keyfile ca.key 如果有错误修改\nvim /etc/pki/CA/index.txt.attr #unique_subject = yes unique_subject = no 然后再重新运行一次 这个certificate是BASE64形式的,要转成PKCS12才能装到IE,/NETSCAPE上.转换如下： openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfx 最后生成这些文件 配置nginx如下： listen\t443 ssl; server_name alpha.sherp.xyz; root /opt/project/erp_old_version/Shanghai_erp/public; index index.php; ssl_certificate ssl/server.crt; ssl_certificate_key ssl/server.key; ssl_client_certificate ssl/ca.crt; ssl_session_timeout 5m; ssl_verify_client on; 最后把client.pfx安装到客户端就可以了 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/nginx%E9%85%8D%E7%BD%AEhttps\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/linux%E8%A7%A3%E5%86%B3warning-mysql_connect-headers-and-client-library-minor-version-mismatch.-%E8%AD%A6%E5%91%8A\/": {
        "title": "Linux解决Warning mysql_connect() Headers and client library minor version mismatch. 警告",
        "tags": ["mysql",],
        "content": "yum remove php-mysql yum install php70w-mysqlnd ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/linux%E8%A7%A3%E5%86%B3warning-mysql_connect-headers-and-client-library-minor-version-mismatch.-%E8%AD%A6%E5%91%8A\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos%E4%B8%8B%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4mysql-%E5%92%8C%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85mysql\/": {
        "title": "centos下彻底删除MYSQL 和重新安装MYSQL",
        "tags": ["centos","mysql",],
        "content": "1 删除Mysql\nyum remove mysql mysql-server mysql-libs mysql-server; find / -name mysql 将找到的相关东西delete掉； rpm -qa|grep mysql(查询出来的东东yum remove掉) 2 安装Mysql\nyum install mysql mysql-server mysql-libs mysql-server; ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos%E4%B8%8B%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4mysql-%E5%92%8C%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85mysql\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/error-1044-42000-access-denied-for-user-@localhost-to-database-mysql\/": {
        "title": "ERROR 1044 (42000) Access denied for user \u0027\u0027@\u0027localhost\u0027 to database \u0027mysql\u0027",
        "tags": ["mysql",],
        "content": "方法一： 1.关闭mysql\nservice mysqld stop 2.屏蔽权限\nmysqld_safe --skip-grant-table 屏幕出现： Starting demo from \u0026hellip;..\n3.新开起一个终端输入\nmysql -u root mysql mysql\u0026gt; UPDATE user SET Password=PASSWORD(\u0026#39;newpassword\u0026#39;) where USER=\u0026#39;root\u0026#39;; mysql\u0026gt; FLUSH PRIVILEGES;//记得要这句话，否则如果关闭先前的终端，又会出现原来的错误 mysql\u0026gt;exit; 方法二： 1.关闭mysql\nservice mysqld stop 2.屏蔽权限\nmysqld_safe --skip-grant-table 屏幕出现： Starting demo from \u0026hellip;..\n3.新开起一个终端输入\nmysql -u root mysql mysql\u0026gt; delete from user where USER=\u0026#39;\u0026#39;; mysql\u0026gt; FLUSH PRIVILEGES;//记得要这句话，否则如果关闭先前的终端，又会出现原来的错误 mysql\u0026gt;exit; ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/error-1044-42000-access-denied-for-user-@localhost-to-database-mysql\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/mysql%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%AE%E5%BD%95\/": {
        "title": "mysql更改数据库目录",
        "tags": ["mysql",],
        "content": "修改 my.cnf\ndatadir=/www/mysql/data socket=/www/mysql/data/mysql.sock 其实这里不需要复制/var/lib/mysql下的文件到新目录，修改完配置之后，mysql会自动复制/var/lib/mysql下的文件到新目录\n关闭SELinux\nvim /etc/selinux/config #编辑文件 # This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. #permissive - SELinux prints warnings instead of enforcing. #disabled - No SELinux policy is loaded. SELINUX=enforcing # SELINUXTYPE= can take one of these two values: # targeted - Targeted processes are protected, # mls - Multi Level Security protection. 将SELINUX=enforceing 改为 SELINUX=disabled 重启机器就ok了\n最后\nln -s /www/mysql/data/mysql.sock /var/lib/mysql/mysql.sock ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/mysql%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%AE%E5%BD%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos7-yum%E5%AE%89%E8%A3%85lnmp\/": {
        "title": "centos7 yum安装lnmp",
        "tags": ["centos","yum","lnmp",],
        "content": "PHP7 1.安装epel-release 通过命令：\nyum -y install epel-release 成功安装。\n2.安装PHP7 终端再次运行如下命令：\nrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 成功获取PHP7的yum源，然后再执行：\nphp安装以及安装扩展 yum install php70w php70w-devel php70w-fpm php70w-gd php70w-mysqli php70w-mbstring nginx centos7系统库中默认是没有nginx的rpm包的，所以我们自己需要先更新下rpm依赖库\n1.使用yum安装nginx需要包括Nginx的库，安装Nginx的库 rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 2.使用下面命令安装nginx yum install nginx 3.启动Nginx service nginx start 或\nsystemctl start nginx.service mysql 1.下载mysql的repo源 wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 2.安装mysql-community-release-el7-5.noarch.rpm包 sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm 安装这个包后，会获得两个mysql的yum repo源：/etc/yum.repos.d/mysql-community.repo，/etc/yum.repos.d/mysql-community-source.repo。\n3.安装mysql sudo yum install mysql-server 根据提示安装就可以了,不过安装完成后没有密码,需要重置密码\n4.重置mysql密码 mysql -u root 登录时有可能报这样的错：ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户：\nsudo chown -R root:root /var/lib/mysql 重启mysql服务\nservice mysqld restart 接下来登录重置密码：\nmysql -u root //直接回车进入mysql控制台 mysql \u0026gt; use mysql; mysql \u0026gt; update user set password=password(\u0026#39;123456\u0026#39;) where user=\u0026#39;root\u0026#39;; mysql \u0026gt; exit; ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos7-yum%E5%AE%89%E8%A3%85lnmp\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/lnmp\/": {
        "title": "LNMP",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/lnmp\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/yum\/": {
        "title": "yum",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/yum\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/phpstorm\/": {
        "title": "phpstorm",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/phpstorm\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/phpstorm%E4%B8%AD%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95xdebug\/": {
        "title": "phpstorm中配置远程调试xdebug",
        "tags": ["phpstorm",],
        "content": "这里说的是真正的远程调试，不是本地，本地不需要安装任何php程序！！！\n这里略去xdebug的安装，安装很简单可以下载源码包，动态编译进去！\n环境：\nDev 服务器(IP:192.168.3.2)，安装phpstorm，用来做开发任务！\nServer服务器（IP:192.168.3.9），web服务器(php架构)，用来浏览网页用！\n这里的两台服务器在同一个网段下，可以互通！\n在Server服务器上的php.ini里配置xdebug如下：\n[xdebug] zend_extension=xdebug.so xdebug.remote_enable=1 xdebug.remote_handler=dbgp xdebug.remote_mode=req xdebug.remote_host=192.168.3.9 xdebug.remote_port=9000 xdebug.idekey=\u0026#34;PHPSTORM\u0026#34; remote_host参数的值填写Dev 服务器(开发机器)的IP地址。\nremote_port填写9000，只要没有被其它程序占用，就可以了，可以不是9000。\n接下来开始设置phpstorm的参数：\n快捷键(Ctrl + Alt + S)打开窗口：\n打开phpstorm的配置对话框，找到Languages \u0026amp; Frameworks \u0026raquo; PHP \u0026raquo;Debug 窗口\n这里填写的Debug port为：9000，与php.ini里配置的端口号保持一致!\n接下来点选Server选项，点击绿色的 “+” 新建Server，并根据如下设置填写你相对应的内容！\n因为是远程调试，所以这里的Use Path mappings 一定要选，并且本地与远程文件要映射好。\nDebugger里选择：Xdebug ！\n接下来配置Edit Configurations( Run \u0026raquo; Edit Configurations)\n点击后弹出窗口如下：\n选中PHP Web Application ，在右边选择前面新增的Server：ecstore，保存。\n这里其实只是用来配置一个模板，我之前只配置了这个，没有新增Debug选项，总是不能调试，后来参照资料才想明白，这里其实只是模板，配置好了后，可以直接新增选择对应模板就可以了。\n现在来新增Debug选项：\n点击后新增调试选项：\n好了。\n在php代码里打个断点开始调试吧：)\n然后，点击调试，开始愉快的干活吧！！！\n看看调试效果：\n这里真的没有什么DBGp概念，我们没有用到，也没有什么点击什么绿色的电话图标启动Start Listening\u0026hellip;，有吗？？\n没用，真的用不到那么些概念，网上一大堆以讹传讹的贴子，真是越看越迷糊！！！\n就这么愉快的调试吧 :)\n关于DBGp，其实就是个代理，把phpstorm设置成一个代理，但是对于我来说，真的需要什么代理吗？？？\n就这样吧，最简单的远程调试，去粗到精的成果！\n浏览器设置 下载谷歌浏览器的扩展程序chrome helper，安装好后，在选项里找到IDE key，在其下拉列表中选择PhpStorm。如下图：\n，接着点击灰色的chrome helper的臭虫图标，在下拉项中选择Debug项，这时臭虫图标变为绿色，处于调试模式。配置好后，打开phpstorm，点击下图中的电话按钮开启侦听浏览器。如下图所示：\n转载自：https://www.cnblogs.com/yjken/p/6555438.html ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/phpstorm%E4%B8%AD%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95xdebug\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/linux%E4%B8%8Bphp%E6%89%A9%E5%B1%95mysqli%E7%9A%84%E6%94%AF%E6%8C%81\/": {
        "title": "linux下php扩展mysqli的支持",
        "tags": ["linux","mysql",],
        "content": "mysqli是优化后的mysql，具体的优点baidu下就ok了\ncd php-5.2.8 在这下面有个ext文件夹里有mysqli cd ext/mysqli linux下将源码文件编译应该都有configure吧，可这里没有，在我们已经安装php后，php5这个文件夹里的命令目录bin里有一个文件叫phpize，用它就可以生成configure文件啦，继续\n/usr/local/php5/bin/phpize 这里回车运行，执行完后就出了configure文件，\n./configure --prefix=/opt/local/mysqli --with-php-config=/opt/local/php/bin/php-config --with-mysqli=/opt/local/mysql/bin/mysql_config 直接回车，不出问题就继续。。 make make test make install (不出错就会显示Installing shared extensions: /usr/local/php5/lib/php/extensions/no-debug-non-zts-20041030/) 现在mysqli.so文件就出来啦。。\n直接在php.ini里把这个文件加载就OK啦。。\nextension_dir=”/usr/local/php5/ext” extension=mysqli.so 把上面第一行找到修改成这个,然后再把第二行加入。。wq保存退出。\n把mysqli.so这个文件cp到/usr/local/php5/ext下\n重启apache.\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/linux%E4%B8%8Bphp%E6%89%A9%E5%B1%95mysqli%E7%9A%84%E6%94%AF%E6%8C%81\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E5%9C%A8%E5%AE%89%E8%A3%85mysqli%E7%9A%84%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0error-ext-mysqlnd-mysql-float-to-double-h-no-such-file-or-directory\/": {
        "title": "在安装mysqli的时候，出现error-ext-mysqlnd-mysql-float-to-double-h-No-such-file-or-directory",
        "tags": ["mysql",],
        "content": "直接修改源码，把找不到的那个头文件的路径修改为绝对路径，编译通过了，也能正常使用\npwd /home/neo/tools/php-5.5.28/ext/mysqli vim mysqli_api.c 把第36行的 #include \u0026#34;ext/mysqlnd/mysql_float_to_double.h\u0026#34; 修改为 #include \u0026#34;/home/neo/tools/php-5.5.28/ext/mysqlnd/mysql_float_to_double.h\u0026#34; ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E5%9C%A8%E5%AE%89%E8%A3%85mysqli%E7%9A%84%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0error-ext-mysqlnd-mysql-float-to-double-h-no-such-file-or-directory\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%BB%A5%E5%8F%8A%E4%B8%8B%E8%BD%BD\/": {
        "title": "网络连接以及下载",
        "tags": ["linux",],
        "content": "wget 指定本定文件夹和保存为特定名称 1. 在shell 中执行以下命令 wget -P /root/test \u0026#34;http://www.baidu.com/index.html\u0026#34; 会把 index.html 文件保存到 \u0026#34;/root/test\u0026#34; 目录下. 2. 执行 wget -O \u0026#34;baidu.html\u0026#34; \u0026#34;http://www.baidu.com/index.html\u0026#34; 会把 index.hmtl 保存到当前目录, 命令为 \u0026#34;baidu.html\u0026#34;. 3. 执行 wget -P /root/test -O \u0026#34;baidu.html\u0026#34; \u0026#34;http://www.baidu.com/index.html\u0026#34; 的结果和 2 相同, 并不会保存到 \u0026#34;/root/test\u0026#34; 目录下. 在linux命令下如何访问一个url？ 1.elinks - lynx-like替代角色模式WWW的浏览器 例如： elinks --dump http://www.baidu.com 2.wget 这个会将访问的首页下载到本地 [root@el5-mq2 ~]# wget http://www.baidu.com --2011-10-17 16:30:10-- http://www.baidu.com/ Resolving www.baidu.com... 119.75.218.45, 119.75.217.56 Connecting to www.baidu.com|119.75.218.45|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 8403 (8.2K) [text/html] Saving to: `index.html\u0026#39; 100%[==========================================================================================\u0026gt;] 8,403 --.-K/s in 0.01s 2011-10-17 16:30:10 (648 KB/s) - `index.html\u0026#39; saved [8403/8403] 3.curl会显示出源码 curl http://www.baidu.com/index.html 4.lynx（这个以前在群里面见有人讨论过，但是没有尝试过，想用的话还需要下载软件） lynx http://www.baidu.com ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%BB%A5%E5%8F%8A%E4%B8%8B%E8%BD%BD\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/crontab\/": {
        "title": "crontab",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/crontab\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E4%BD%BF%E7%94%A8crontab%E8%AE%A9linux%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC\/": {
        "title": "使用crontab，让linux定时执行shell脚本",
        "tags": ["linux","crontab",],
        "content": "使用crontab你可以在指定的时间执行一个shell脚本或者一系列Linux命令。例如系统管理员安排一个备份任务使其每天都运行 入门 crontab –e 这样可以已编辑模式打开个人的crontab配置文件，然后加入一下这行： 0 0 * * * /home/linrui/XXXXXXXX.sh 这将会在每天凌晨运行 指定的.sh文件 Cron 各项的描述 以下是 crontab 文件的格式： {minute} {hour} {day-of-month} {month} {day-of-week} {full-path-to-shell-script} o minute: 区间为 0 – 59 o hour: 区间为0 – 23 o day-of-month: 区间为0 – 31 o month: 区间为1 – 12. 1 是1月. 12是12月. o Day-of-week: 区间为0 – 7. 周日可以是0或7. Crontab 示例 1、在 凌晨00:01运行 1 0 * * * /home/linrui/XXXX.sh 2、每个工作日23:59都进行备份作业。 59 11 * * 1,2,3,4,5 /home/linrui/XXXX.sh 或者如下写法： 59 11 * * 1-5 /home/linrui/XXXX.sh 3、每分钟运行一次命令 */1 * * * * /home/linrui/XXXX.sh 4、每个月的1号 14:10 运行 10 14 1 * * /home/linrui/XXXX.sh Crontab命令的选项 以下是 crontab 的有效选项: crontab –e : 修改 crontab 文件. 如果文件不存在会自动创建。 crontab –l : 显示 crontab 文件。 crontab -r : 删除 crontab 文件。 crontab -ir : 删除 crontab 文件前提醒用户。 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E4%BD%BF%E7%94%A8crontab%E8%AE%A9linux%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%96%87%E4%BB%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93\/": {
        "title": "迁移数据库：直接复制数据表文件到数据库",
        "tags": ["mysql",],
        "content": "把目的数据库里面的 *.err 文件，ib_logfile 文件删除 备注：经测试，源mysql的安装目录及数据文件目录 可以与 目标Mysql的安装目录及数据文件目录 不一致。 此时，只需要拷贝所需移动的dbname及\u0026#39;mysql\u0026#39;和\u0026#39;ibdata1\u0026#39;，即可。 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%96%87%E4%BB%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E6%9F%A5%E7%9C%8Blinux%E4%B8%AD%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3port%E6%98%AF%E5%90%A6%E8%A2%AB%E5%8D%A0%E7%94%A8\/": {
        "title": "查看linux中某个端口（port）是否被占用",
        "tags": ["linux",],
        "content": "1.使用lsof\nlsof -i:端口号查看某个端口是否被占用\n2.使用netstat\n使用netstat -anp|grep 80\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E6%9F%A5%E7%9C%8Blinux%E4%B8%AD%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3port%E6%98%AF%E5%90%A6%E8%A2%AB%E5%8D%A0%E7%94%A8\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E7%BC%96%E8%BE%91-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4\/": {
        "title": "编辑-自定义命令",
        "tags": ["linux",],
        "content": "vim ~/.bashrc example: alias codedir=\u0026#39;cd /opt/local/www/project\u0026#39; ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E7%BC%96%E8%BE%91-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/yum-y-install%E4%B8%8Eyum-install%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C\/": {
        "title": "yum-y-install与yum-install有什么不同",
        "tags": ["linux","centos",],
        "content": "yum -y install 包名（支持*） ：自动选择y，全自动 yum install 包名（支持*） ：手动选择y or n yum remove 包名（不支持*） rpm -ivh 包名（支持*）：安装rpm包 rpm -e 包名（不支持*）：卸载rpm包 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/yum-y-install%E4%B8%8Eyum-install%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/windows%E4%B8%8B%E7%94%A8navicat%E8%BF%9C%E7%A8%8B%E9%93%BE%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BAlinux%E4%B8%8Bmysql%E6%95%B0%E6%8D%AE%E5%BA%93\/": {
        "title": "windows下用navicat远程链接虚拟机Linux下MySQL数据库",
        "tags": ["mysql",],
        "content": "手动增加可以远程访问数据库的用户。\n方法一、本地登入mysql，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，将”localhost”改为”%”\nmysql -u root -proot mysql\u0026gt;use mysql; mysql\u0026gt;update user set host = \u0026#39;%\u0026#39; where user = \u0026#39;root\u0026#39;; mysql\u0026gt;flush privileges; mysql\u0026gt;select host, user from user; 方法二、直接授权(推荐)\n从任何主机上使用root用户，密码：youpassword（你的root密码）连接到mysql服务器：\nmysql -u root -proot mysql\u0026gt;GRANT ALL PRIVILEGES ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;youpassword\u0026#39; WITH GRANT OPTION; mysql\u0026gt;flush privileges; ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/windows%E4%B8%8B%E7%94%A8navicat%E8%BF%9C%E7%A8%8B%E9%93%BE%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BAlinux%E4%B8%8Bmysql%E6%95%B0%E6%8D%AE%E5%BA%93\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/ss\/": {
        "title": "ss",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/ss\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/ss%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85libsodium%E6%94%AF%E6%8C%81chacha20\/": {
        "title": "ss服务端安装libsodium支持chacha20",
        "tags": ["ss",],
        "content": "ss如果要使用 salsa20 或 chacha20 或 chacha20-ietf 算法，需要安装 libsodium ，否则就算在config.json里面设置成chacha20也会提示method not supported.\ncentos：\nyum -y groupinstall \u0026#34;Development Tools\u0026#34; wget https://github.com/jedisct1/libsodium/releases/download/1.0.11/libsodium-1.0.11.tar.gztar xf libsodium-1.0.11.tar.gz \u0026amp;\u0026amp; cd libsodium-1.0.11./configure \u0026amp;\u0026amp; make -j2 \u0026amp;\u0026amp; make install echo /usr/local/lib \u0026gt;/etc/ld.so.conf.d/usr_local_lib.confldconfig ubuntu/debian： apt-get install build-essential wget https://github.com/jedisct1/libsodium/releases/download/1.0.11/libsodium-1.0.11.tar.gztar xf libsodium-1.0.11.tar.gz \u0026amp;\u0026amp; cd libsodium-1.0.11./configure \u0026amp;\u0026amp; make -j2 \u0026amp;\u0026amp; make installldconfig 如果曾经安装过旧版本，亦可重复用以上步骤更新到最新版，仅1.0.4或以上版本支持chacha20-ietf ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/ss%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85libsodium%E6%94%AF%E6%8C%81chacha20\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/ssh\/": {
        "title": "ssh",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/ssh\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B\/": {
        "title": "ssh远程登录命令简单实例",
        "tags": ["ssh",],
        "content": "ssh命令用于远程登录上Linux主机。 常用格式：ssh [-l login_name] [-p port] [user@]hostname 更详细的可以用ssh -h查看。 举例 不指定用户： ssh 192.168.0.11 指定用户： ssh -l root 192.168.0.11 ssh root@192.168.0.11 如果修改过ssh登录端口的可以： ssh -p 12333 192.168.0.11 ssh -l root -p 12333 216.230.230.114 ssh -p 12333 root@216.230.230.114 另外修改配置文件/etc/ssh/sshd_config，可以改ssh登录端口和禁止root登录。改端口可以防止被端口扫描。 编辑配置文件： vim /etc/ssh/sshd_config 找到#Port 22，去掉注释，修改成一个五位的端口： Port 12333 找到#PermitRootLogin yes，去掉注释，修改为： PermitRootLogin no 重启sshd服务： service sshd restart ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/php-fpm%E8%AE%BE%E7%BD%AEsocket%E6%96%B9%E5%BC%8F%E8%BF%9E%E6%8E%A5fastcgi\/": {
        "title": "php-fpm设置socket方式连接FastCGI",
        "tags": ["php",],
        "content": "nginx和fastcgi的通信方式有两种，一种是TCP的方式，一种是unix socket方式。\nsocket方式不会走到tcp层，tcp方式则会走到ip层。因此，理论上说socket连接方式效率会更好一点。 TCP和unix domain socket方式对比\nTCP是使用TCP端口连接127.0.0.1:9000\nSocket是使用unix domain socket连接套接字/dev/shm/php-fpm.sock\n修改php-fpm.conf配置\n#listen = 127.0.0.1:9000 listen=/dev/shm/php-fpm.sock #/dev/shm/为内存文件系统，注意 确保可读写 listen.owner=apache #注意自己的用户和组 listen.group=apache 修改nginx.conf配置\n#fastcgi_pass 127.0.0.1:9000; #将相应的如上内容修改如下 fastcgi_pass unix:/dev/shm/php-fpm.sock; 重启nginx和php-fpm\nservice nginx restart /usr/local/nginx/sbin/nginx -s reload ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/php-fpm%E8%AE%BE%E7%BD%AEsocket%E6%96%B9%E5%BC%8F%E8%BF%9E%E6%8E%A5fastcgi\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/pdo-mysql-make-pdo-mysql-lo-error-1\/": {
        "title": "PDO-MYSQL-make-pdo-mysql-lo-Error-1",
        "tags": ["mysql",],
        "content": "编译安装PDO_MYSQL拓展模块，总是提示\nIn file included from /data0/software/PDO_MYSQL-1.0.2/pdo_mysql.c:31: /data0/software/PDO_MYSQL-1.0.2/php_pdo_mysql_int.h:25:19: error: mysql.h: No such file or directory In file included from /data0/software/PDO_MYSQL-1.0.2/pdo_mysql.c:31: /data0/software/PDO_MYSQL-1.0.2/php_pdo_mysql_int.h:36: error: expected specifier-qualifier-list before ‘MYSQL’ /data0/software/PDO_MYSQL-1.0.2/php_pdo_mysql_int.h:48: error: expected specifier-qualifier-list before ‘MYSQL_FIELD’ /data0/software/PDO_MYSQL-1.0.2/php_pdo_mysql_int.h:53: error: expected specifier-qualifier-list before ‘MYSQL_RES’ make: *** [pdo_mysql.lo] Error 1 这是因为这是因为在编译时需要 MySQL 的头的文件。而它按默认搜索找不到头文件的位置，所以才出现这个问题。通过软连接把MySQL头文件对应到/usr/local/include/下就好 比如你的MySQL安装文件位于/usr/local/mysql，那么就执行以下命令：\nln -s /usr/local/mysql/include/* /usr/local/include/ ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/pdo-mysql-make-pdo-mysql-lo-error-1\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/nginx-%E5%90%AF%E5%8A%A8-warn-conflicting-server-name-xxx-com-on-0-0-0-0-80-ignored%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90\/": {
        "title": "NGINX-启动-warn-conflicting-server-name-“xxx-com”-on-0-0-0-0-80-ignored原因分析",
        "tags": ["nginx",],
        "content": "报错如下：\nnginx: [warn] conflicting server name “www.xxx.com” on 0.0.0.0:80, ignored 域名重复配置所致\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/nginx-%E5%90%AF%E5%8A%A8-warn-conflicting-server-name-xxx-com-on-0-0-0-0-80-ignored%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/nginx%E9%85%8D%E7%BD%AElocation%E6%80%BB%E7%BB%93%E5%8F%8Arewrite%E8%A7%84%E5%88%99%E5%86%99%E6%B3%95\/": {
        "title": "nginx配置location总结及rewrite规则写法",
        "tags": ["nginx",],
        "content": "location正则写法 一个示例：\nlocation = / { # 精确匹配 / ，主机名后面不能带任何字符串 [ configuration A ] } location / { # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求 # 但是正则和最长字符串会优先匹配 [ configuration B ] } location /documents/ { # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration C ] } location ~ /documents/Abc { # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration CC ] } location ^~ /images/ { # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。 [ configuration D ] } location ~* \\.(gif|jpg|jpeg)$ { # 匹配所有以 gif,jpg或jpeg 结尾的请求 # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则 [ configuration E ] } location /images/ { # 字符匹配到 /images/，继续往下，会发现 ^~ 存在 [ configuration F ] } location /images/abc { # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在 # F与G的放置顺序是没有关系的 [ configuration G ] } location ~ /images/abc/ { # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用 [ configuration H ] } 1 location ~* /js/.*/\\.js 已=开头表示精确匹配 如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。 ^~ 开头表示uri以某个常规字符串开头，不是正则匹配 ~ 开头表示区分大小写的正则匹配; ~* 开头表示不区分大小写的正则匹配 / 通用匹配, 如果没有其它匹配,任何请求都会匹配到 顺序 no优先级： (location =) \u0026gt; (location 完整路径) \u0026gt; (location ^~ 路径) \u0026gt; (location ~,~* 正则顺序) \u0026gt; (location 部分起始路径) \u0026gt; (/) 上面的匹配结果 按照上面的location写法，以下的匹配示例成立：\n/ -\u0026gt; config A 精确完全匹配，即使/index.html也匹配不了 /downloads/download.html -\u0026gt; config B 匹配B以后，往下没有任何匹配，采用B /images/1.gif -\u0026gt; configuration D 匹配到F，往下匹配到D，停止往下 /images/abc/def -\u0026gt; config D 最长匹配到G，往下匹配D，停止往下 你可以看到 任何以/images/开头的都会匹配到D并停止，FG写在这里是没有任何意义的，H是永远轮不到的，这里只是为了说明匹配顺序 /documents/document.html -\u0026gt; config C 匹配到C，往下没有任何匹配，采用C /documents/1.jpg -\u0026gt; configuration E 匹配到C，往下正则匹配到E /documents/Abc.jpg -\u0026gt; config CC 最长匹配到C，往下正则顺序匹配到CC，不会往下到E 实际使用建议 所以实际使用中，个人觉得至少有三个匹配规则定义，如下： #直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。 #这里是直接转发给后端应用服务器了，也可以是一个静态首页 # 第一个必选规则 location = / { proxy_pass http://tomcat:8080/index } # 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项 # 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用 location ^~ /static/ { root /webroot/static/; } location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ { root /webroot/res/; } #第三个规则就是通用规则，用来转发动态请求到后端应用服务器 #非静态文件请求就默认是动态请求，自己根据实际把握 #毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了 location / { proxy_pass http://tomcat:8080/ } http://tengine.taobao.org/book/chapter_02.html http://nginx.org/en/docs/http/ngx_http_rewrite_module.html Rewrite规则 rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。rewrite只能放在server{},location{},if{}中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 http://seanlook.com/a/we/index.php?id=1\u0026amp;u=str 只对/a/we/index.php重写。语法rewrite regex replacement [flag]; 如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用proxy_pass反向代理。 表明看rewrite和location功能有点像，都能实现跳转，主要区别在于rewrite是在同一域名内更改获取资源的路径，而location是对一类路径做控制访问或反向代理，可以proxy_pass到其他机器。很多情况下rewrite也会写在location里，它们的执行顺序是： 执行server块的rewrite指令 执行location匹配 执行选定的location中的rewrite指令 如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件；循环超过10次，则返回500 Internal Server Error错误。 flag标志位 last : 相当于Apache的[L]标记，表示完成rewrite break : 停止执行当前虚拟主机的后续rewrite指令集 redirect : 返回302临时重定向，地址栏会显示跳转后的地址 permanent : 返回301永久重定向，地址栏会显示跳转后的地址 因为301和302不能简单的只返回状态码，还必须有重定向的URL，这就是return指令无法返回301,302的原因了。这里 last 和 break 区别有点难以理解： last一般写在server和if中，而break一般使用在location中 last不终止重写后的url匹配，即新的url会再从server走一遍匹配流程，而break终止重写后的匹配 break和last都能组织继续执行后面的rewrite指令 if指令与全局变量 if判断指令 语法为if(condition){...}，对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行，if条件(conditon)可以是如下任何内容： 当表达式只是一个变量时，如果值为空或任何以0开头的字符串都会当做false 直接比较变量和内容时，使用=或!= ~正则表达式匹配，~*不区分大小写的匹配，!~区分大小写的不匹配 -f和!-f用来判断是否存在文件 -d和!-d用来判断是否存在目录 -e和!-e用来判断是否存在文件或目录 -x和!-x用来判断文件是否可执行 例如： if ($http_user_agent ~ MSIE) { rewrite ^(.*)$ /msie/$1 break; } //如果UA包含\u0026#34;MSIE\u0026#34;，rewrite请求到/msid/目录下 if ($http_cookie ~* \u0026#34;id=([^;]+)(?:;|$)\u0026#34;) { set $id $1; } //如果cookie匹配正则，设置变量$id等于正则引用部分 if ($request_method = POST) { return 405; } //如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302 if ($slow) { limit_rate 10k; } //限速，$slow可以通过 set 指令设置 if (!-f $request_filename){ break; proxy_pass http://127.0.0.1; } //如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查 if ($args ~ post=140){ rewrite ^ http://example.com/ permanent; } //如果query string中包含\u0026#34;post=140\u0026#34;，永久重定向到example.com location ~* \\.(gif|jpg|png|swf|flv)$ { valid_referers none blocked www.jefflei.com www.leizhenfang.com; if ($invalid_referer) { return 404; } //防盗链 } 全局变量 下面是可以用作if判断的全局变量 $args ： #这个变量等于请求行中的参数，同$query_string $content_length ： 请求头中的Content-length字段。 $content_type ： 请求头中的Content-Type字段。 $document_root ： 当前请求在root指令中指定的值。 $host ： 请求主机头字段，否则为服务器名称。 $http_user_agent ： 客户端agent信息 $http_cookie ： 客户端cookie信息 $limit_rate ： 这个变量可以限制连接速率。 $request_method ： 客户端请求的动作，通常为GET或POST。 $remote_addr ： 客户端的IP地址。 $remote_port ： 客户端的端口。 $remote_user ： 已经经过Auth Basic Module验证的用户名。 $request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。 $scheme ： HTTP方法（如http，https）。 $server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 $server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。 $server_name ： 服务器名称。 $server_port ： 请求到达服务器的端口号。 $request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。 $uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。 $document_uri ： 与$uri相同。 例：http://localhost:88/test1/test2/test.php $host：localhost $server_port：88 $request_uri：http://localhost:88/test1/test2/test.php $document_uri：/test1/test2/test.php $document_root：/var/www/html $request_filename：/var/www/html/test1/test2/test.php 常用正则 . ： 匹配除换行符以外的任意字符 ? ： 重复0次或1次 + ： 重复1次或更多次 * ： 重复0次或更多次 \\d ：匹配数字 ^ ： 匹配字符串的开始 $ ： 匹配字符串的介绍 {n} ： 重复n次 {n,} ： 重复n次或更多次 [c] ： 匹配单个字符c [a-z] ： 匹配a-z小写字母的任意一个 小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\\转义特殊字符。 rewrite实例 例1： http { # 定义image日志格式 log_format imagelog \u0026#39;[$time_local] \u0026#39; $image_file \u0026#39; \u0026#39; $image_type \u0026#39; \u0026#39; $body_bytes_sent \u0026#39; \u0026#39; $status; # 开启重写日志 rewrite_log on; server { root /home/www; location / { # 重写规则信息 error_log logs/rewrite.log notice; # 注意这里要用‘’单引号引起来，避免{} rewrite \u0026#39;^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\\.(png|jpg|gif)$\u0026#39; /data?file=$3.$4; # 注意不能在上面这条规则后面加上“last”参数，否则下面的set指令不会执行 set $image_file $3; set $image_type $4; } location /data { # 指定针对图片的日志格式，来分析图片类型和大小 access_log logs/images.log mian; root /data/images; # 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最后一个url里 try_files /$arg_file /image404.html; } location = /image404.html { # 图片不存在返回特定的信息 return 404 \u0026#34;image not found\\n\u0026#34;; } } 对形如/images/ef/uh7b3/test.png的请求，重写到/data?file=test.png，于是匹配到location /data，先看/data/images/test.png文件存不存在，如果存在则正常响应，如果不存在则重写tryfiles到新的image404 location，直接返回404状态码。 例2： rewrite ^/images/(.*)_(\\d+)x(\\d+)\\.(png|jpg|gif)$ /resizer/$1.$4?width=$2\u0026amp;height=$3? last; 对形如/images/bla_500x400.jpg的文件请求，重写到/resizer/bla.jpg?width=500\u0026amp;height=400地址，并会继续尝试匹配location。 一．正则表达式匹配，其中： * ~ 为区分大小写匹配 * ~* 为不区分大小写匹配 * !~和!~*分别为区分大小写不匹配及不区分大小写不匹配 二．文件及目录匹配，其中： * -f和!-f用来判断是否存在文件 * -d和!-d用来判断是否存在目录 * -e和!-e用来判断是否存在文件或目录 * -x和!-x用来判断文件是否可执行 三．rewrite指令的最后一项参数为flag标记，flag标记有： 1.last 相当于apache里面的[L]标记，表示rewrite。 2.break本条规则匹配完成后，终止匹配，不再匹配后面的规则。 3.redirect 返回302临时重定向，浏览器地址会显示跳转后的URL地址。 4.permanent 返回301永久重定向，浏览器地址会显示跳转后的URL地址。 使用last和break实现URI重写，浏览器地址栏不变。而且两者有细微差别，使用alias指令必须用last标记;使用proxy_pass指令时，需要使用break标记。Last标记在本条rewrite规则执行完毕后，会对其所在server{......}标签重新发起请求，而break标记则在本条规则匹配完成后，终止匹配。 例如：如果我们将类似URL/photo/123456 重定向到/path/to/photo/12/1234/123456.png rewrite \u0026#34;/photo/([0-9]{2})([0-9]{2})([0-9]{2})\u0026#34;/path/to/photo/$1/$1$2/$1$2$3.png ; 四．NginxRewrite 规则相关指令 1.break指令 使用环境：server,location,if; 该指令的作用是完成当前的规则集，不再处理rewrite指令。 2.if指令 使用环境：server,location 该指令用于检查一个条件是否符合，如果条件符合，则执行大括号内的语句。If指令不支持嵌套，不支持多个条件\u0026amp;\u0026amp;和||处理。 3.return指令 语法：returncode ; 使用环境：server,location,if; 该指令用于结束规则的执行并返回状态码给客户端。 示例：如果访问的URL以\u0026#34;.sh\u0026#34;或\u0026#34;.bash\u0026#34;结尾，则返回403状态码 location ~ .*\\.(sh|bash)?$ { return 403; } 4.rewrite 指令 语法：rewriteregex replacement flag 使用环境：server,location,if 该指令根据表达式来重定向URI，或者修改字符串。指令根据配置文件中的顺序来执行。注意重写表达式只对相对路径有效。如果你想配对主机名，你应该使用if语句，示例如下： if( $host ~* www\\.(.*) ) { set $host_without_www $1; rewrite ^(.*)$ http://$host_without_www$1permanent; } 5.Set指令 语法：setvariable value ; 默认值:none; 使用环境：server,location,if; 该指令用于定义一个变量，并给变量赋值。变量的值可以为文本、变量以及文本变量的联合。 示例：set$varname \u0026#34;hello world\u0026#34;; 6.Uninitialized_variable_warn指令 语法：uninitialized_variable_warnon|off 使用环境：http,server,location,if 该指令用于开启和关闭未初始化变量的警告信息，默认值为开启。 五．Nginx的Rewrite规则编写实例 1.当访问的文件和目录不存在时，重定向到某个php文件 if( !-e $request_filename ) { rewrite ^/(.*)$ index.php last; } 2.目录对换 /123456/xxxx ====\u0026gt; /xxxx?id=123456 rewrite ^/(\\d+)/(.+)/ /$2?id=$1 last; 3.如果客户端使用的是IE浏览器，则重定向到/ie目录下 if( $http_user_agent ~ MSIE) { rewrite ^(.*)$ /ie/$1 break; } 4.禁止访问多个目录 location ~ ^/(cron|templates)/ { deny all; break; } 5.禁止访问以/data开头的文件 location ~ ^/data { deny all; } 6.禁止访问以.sh,.flv,.mp3为文件后缀名的文件 location ~ .*\\.(sh|flv|mp3)$ { return 403; } 7.设置某些类型文件的浏览器缓存时间 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; } location ~ .*\\.(js|css)$ { expires 1h; } 8.给favicon.ico和robots.txt设置过期时间; 这里为favicon.ico为99天,robots.txt为7天并不记录404错误日志 location ~(favicon.ico) { log_not_found off; expires 99d; break; } location ~(robots.txt) { log_not_found off; expires 7d; break; } 9.设定某个文件的过期时间;这里为600秒，并不记录访问日志 location ^~ /html/scripts/loadhead_1.js { access_log off; root /opt/lampp/htdocs/web; expires 600; break; } 10.文件反盗链并设置过期时间 这里的return412 为自定义的http状态码，默认为403，方便找出正确的盗链的请求 “rewrite ^/ http://img.linuxidc.net/leech.gif;”显示一张防盗链图片 “access_log off;”不记录访问日志，减轻压力 “expires 3d”所有文件3天的浏览器缓存 location ~*^.+\\.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ { valid_referers none blocked *.linuxidc.com*.linuxidc.net localhost 208.97.167.194; if ($invalid_referer) { rewrite ^/ http://img.linuxidc.net/leech.gif; return 412; break; } access_log off; root /opt/lampp/htdocs/web; expires 3d; break; } 11.只允许固定ip访问网站，并加上密码 root /opt/htdocs/www; allow 208.97.167.194; allow 222.33.1.2; allow 231.152.49.4; deny all; auth_basic “C1G_ADMIN”; auth_basic_user_file htpasswd; 12将多级目录下的文件转成一个文件，增强seo效果 /job-123-456-789.html 指向/job/123/456/789.html rewrite^/job-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ /job/$1/$2/jobshow_$3.html last; 13.文件和目录不存在的时候重定向： if (!-e $request_filename) { proxy_pass http://127.0.0.1; } 14.将根目录下某个文件夹指向2级目录 如/shanghaijob/ 指向 /area/shanghai/ 如果你将last改成permanent，那么浏览器地址栏显是/location/shanghai/ rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last; 上面例子有个问题是访问/shanghai时将不会匹配 rewrite ^/([0-9a-z]+)job$ /area/$1/ last; rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last; 这样/shanghai 也可以访问了，但页面中的相对链接无法使用， 如./list_1.html真实地址是/area/shanghia/list_1.html会变成/list_1.html,导至无法访问。 那我加上自动跳转也是不行咯 (-d $request_filename)它有个条件是必需为真实目录，而我的rewrite不是的，所以没有效果 if (-d $request_filename){ rewrite ^/(.*)([^/])$ http://$host/$1$2/permanent; } 知道原因后就好办了，让我手动跳转吧 rewrite ^/([0-9a-z]+)job$ /$1job/permanent; rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last; 15.域名跳转 server { listen 80; server_name jump.linuxidc.com; index index.html index.htm index.php; root /opt/lampp/htdocs/www; rewrite ^/ http://www.linuxidc.com/; access_log off; } 16.多域名转向 server_name www.linuxidc.comwww.linuxidc.net; index index.html index.htm index.php; root /opt/lampp/htdocs; if ($host ~ \u0026#34;linuxidc\\.net\u0026#34;) { rewrite ^(.*) http://www.linuxidc.com$1permanent; } 六．nginx全局变量 arg_PARAMETER #这个变量包含GET请求中，如果有变量PARAMETER时的值。 args #这个变量等于请求行中(GET请求)的参数，如：foo=123\u0026amp;bar=blahblah; binary_remote_addr #二进制的客户地址。 body_bytes_sent #响应时送出的body字节数数量。即使连接中断，这个数据也是精确的。 content_length #请求头中的Content-length字段。 content_type #请求头中的Content-Type字段。 cookie_COOKIE #cookie COOKIE变量的值 document_root #当前请求在root指令中指定的值。 document_uri #与uri相同。 host #请求主机头字段，否则为服务器名称。 hostname #Set to themachine’s hostname as returned by gethostname http_HEADER is_args #如果有args参数，这个变量等于”?”，否则等于”\u0026#34;，空值。 http_user_agent #客户端agent信息 http_cookie #客户端cookie信息 limit_rate #这个变量可以限制连接速率。 query_string #与args相同。 request_body_file #客户端请求主体信息的临时文件名。 request_method #客户端请求的动作，通常为GET或POST。 remote_addr #客户端的IP地址。 remote_port #客户端的端口。 remote_user #已经经过Auth Basic Module验证的用户名。 request_completion #如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)。 request_method #GET或POST request_filename #当前请求的文件路径，由root或alias指令与URI请求生成。 request_uri #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。不能修改。 scheme #HTTP方法（如http，https）。 server_protocol #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 server_addr #服务器地址，在完成一次系统调用后可以确定这个值。 server_name #服务器名称。 server_port #请求到达服务器的端口号。 七．Apache和Nginx规则的对应关系 Apache的RewriteCond对应Nginx的if Apache的RewriteRule对应Nginx的rewrite Apache的[R]对应Nginx的redirect Apache的[P]对应Nginx的last Apache的[R,L]对应Nginx的redirect Apache的[P,L]对应Nginx的last Apache的[PT,L]对应Nginx的last 例如：允许指定的域名访问本站，其他的域名一律转向www.linuxidc.net Apache: RewriteCond %{HTTP_HOST} !^(.*?)\\.aaa\\.com$[NC] RewriteCond %{HTTP_HOST} !^localhost$ RewriteCond %{HTTP_HOST}!^192\\.168\\.0\\.(.*?)$ RewriteRule ^/(.*)$ http://www.linuxidc.net[R,L] Nginx: if( $host ~* ^(.*)\\.aaa\\.com$ ) { set $allowHost ‘1’; } if( $host ~* ^localhost ) { set $allowHost ‘1’; } if( $host ~* ^192\\.168\\.1\\.(.*?)$ ) { set $allowHost ‘1’; } if( $allowHost !~ ‘1’ ) { rewrite ^/(.*)$ http://www.linuxidc.netredirect ; ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/nginx%E9%85%8D%E7%BD%AElocation%E6%80%BB%E7%BB%93%E5%8F%8Arewrite%E8%A7%84%E5%88%99%E5%86%99%E6%B3%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/nginx-php-fpm%E5%87%BA%E7%8E%B0502-bad-gateway%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\/": {
        "title": "nginx-php-fpm出现502-bad-gateway错误解决方法",
        "tags": ["nginx",],
        "content": "1.或者php-cgi端口和nginx配置不一致，这是比较低级的错误\n2.php-fpm没有启动,到php-fpm所在目录启动\n3.php-fpm配置文件user和group配置和Nginx不一致\n4.在centos7中user和group修改在/opt/local/php/etc/php-fpm.d/www.conf里面\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/nginx-php-fpm%E5%87%BA%E7%8E%B0502-bad-gateway%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/nginx-fastcgi-param%E8%A7%A3%E9%87%8A\/": {
        "title": "nginx-fastcgi-param解释",
        "tags": ["nginx",],
        "content": "fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;#脚本文件请求的路径 fastcgi_param QUERY_STRING $query_string; #请求的参数;如?app=123 fastcgi_param REQUEST_METHOD $request_method; #请求的动作(GET,POST) fastcgi_param CONTENT_TYPE $content_type; #请求头中的Content-Type字段 fastcgi_param CONTENT_LENGTH $content_length; #请求头中的Content-length字段。 fastcgi_param SCRIPT_NAME $fastcgi_script_name; #脚本名称 fastcgi_param REQUEST_URI $request_uri; #请求的地址不带参数 fastcgi_param DOCUMENT_URI $document_uri; #与$uri相同。 fastcgi_param DOCUMENT_ROOT $document_root; #网站的根目录。在server配置中root指令中指定的值 fastcgi_param SERVER_PROTOCOL $server_protocol; #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 fastcgi_param GATEWAY_INTERFACE CGI/1.1; #cgi 版本 fastcgi_param SERVER_SOFTWARE nginx/$nginx_version; #nginx 版本号，可修改、隐藏 fastcgi_param REMOTE_ADDR $remote_addr; #客户端IP fastcgi_param REMOTE_PORT $remote_port; #客户端端口 fastcgi_param SERVER_ADDR $server_addr; #服务器IP地址 fastcgi_param SERVER_PORT $server_port; #服务器端口 fastcgi_param SERVER_NAME $server_name; #服务器名，域名在server配置中指定的server_name #fastcgi_param PATH_INFO $path_info; #可自定义变量 #PHP only, required if PHP was built with --enable-force-cgi-redirect #fastcgi_param REDIRECT_STATUS 200; 在php可打印出上面的服务环境变量 如：echo $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;] ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/nginx-fastcgi-param%E8%A7%A3%E9%87%8A\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/nginx-alert-kill-646-1-failed-3-no-such-process-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\/": {
        "title": "nginx-alert-kill-646-1-failed-3-No-such-process-解决方法",
        "tags": ["nginx",],
        "content": "./nginx -s reload nginx: [alert] kill(1708, 1) failed (3: No such process) /opt/local/nginx/sbin/nginx -c /opt/local/nginx/conf/nginx.conf /opt/local/nginx/sbin/nginx -s reload PS: 假设你的nginx的目录是：/usr/opt/nginx/sbin/nginx 假设nginx的配置目录是： /usr/opt/nginx/conf/nginx.conf 重启的方法是：/usr/opt/nginx/sbin/nginx -c /usr/opt/nginx/conf/nginx.conf 参数-c 指定了配置文件的路径，如果不指定该参数，则nginx会默认加载其按照目录的conf目录下的nginx.conf. 平滑重启： 1、检查修改后的配置文件是否正确： /usr/opt/nginx/sbin/nginx -t -c /usr/opt/nginx/conf/nginx.conf 2、kill -HUP Nginx主进程号。示例如下：\nkill -HUP cat/usr/local/webserver/nginx/logs/nginx.pid 主要参数介绍如下：-c 为Nginx 指定一个配置文件，来代替缺省的。-t 不运行，而仅仅测试配置文件。\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/nginx-alert-kill-646-1-failed-3-no-such-process-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/mysql-error-table-mysql-user-doesn-t-exist\/": {
        "title": "MySQL-ERROR-Table-mysql-user-doesn-t-exist",
        "tags": ["mysql",],
        "content": "1、现象描述 [root@centos65 scripts]# service mysqld start Starting MySQL..The server quit without updating PID file (/var/lib/mysql/HKBO.pid).[FAILED] 查看错误日志\n[root@centos65 scripts]# tail /var/log/mysqld.log InnoDB: Apply batch completed 2014-12-08 11:01:37 15721 [Note] InnoDB: 128 rollback segment(s) are active. 2014-12-08 11:01:37 15721 [Note] InnoDB: Waiting for purge to start 2014-12-08 11:01:37 15721 [Note] InnoDB: 5.6.12 started; log sequence number 1600607 2014-12-08 11:01:37 15721 [Note] Server hostname (bind-address): \u0026#39;*\u0026#39;; port: 3306 2014-12-08 11:01:37 15721 [Note] IPv6 is available. 2014-12-08 11:01:37 15721 [Note] - \u0026#39;::\u0026#39; resolves to \u0026#39;::\u0026#39;; 2014-12-08 11:01:37 15721 [Note] Server socket created on IP: \u0026#39;::\u0026#39;. 2014-12-08 11:01:37 15721 [ERROR] Fatal error: Can\u0026#39;t open and lock privilege tables: Table \u0026#39;mysql.user\u0026#39; doesn\u0026#39;t exist 141208 11:01:37 mysqld_safe mysqld from pid file /var/lib/mysql/HKBO.pid ended 2、解决办法\n查看当前的my.cnf配置文件\nmore /etc/my.cnf |grep -v ^# [mysqld] datadir=/var/lib/mysql socket=/var/lib/mysql/mysql.sock user=mysql old_passwords=1 [mysqld_safe] log-error=/var/log/mysqld.log pid-file=/var/run/mysqld/mysqld.pid 由于编译安装时指定的路径为/opt/data以及mysql_install_db时指定的datadir也为/opt/data,而my.cnf为缺省的路径 因此修改datadir至正确路径后，问题解决\nvi /etc/my.cnf more /etc/my.cnf |grep datadir datadir=/opt/data service mysqld start Starting MySQL.[ OK ] ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/mysql-error-table-mysql-user-doesn-t-exist\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/linux%E5%BC%80%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4\/": {
        "title": "Linux开机执行命令",
        "tags": ["linux",],
        "content": "1、把需要执行的命令写到一个bash脚本里面： #!/bin/sh （此括号内为需要执行的命令） 保存为一个文件，比如123.sh，放在oracle的主目录里面。 给这个文件加上可执行属性：chmod 775 123.sh 然后，在/etc/rc.d/rc.local里面加上这句就可以了：\n/123.sh 延时执行 例子：( sleep 60 sh /goexcel.sh )\u0026amp; 延时60秒执行 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/linux%E5%BC%80%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/linux-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%88%A0%E9%99%A4%E8%BF%9B%E7%A8%8B\/": {
        "title": "Linux-查看进程和删除进程",
        "tags": ["linux",],
        "content": " 在 LINUX 命令平台输入 1-2 个字符后按 Tab 键会自动补全后面的部分(前提是要有这个东西，例如在装了 tomcat 的前提下, 输入 tomcat 的 to 按 tab)。 ps 命令用于查看当前正在运行的进程。 grep 是搜索 例如： ps -ef | grep java 表示查看所有进程里 CMD 是 java 的进程信息 ps -aux | grep java -aux 显示所有状态 ps kill 命令用于终止进程 例如： kill -9 [PID] -9 表示强迫进程立即停止 通常用 ps 查看进程 PID ，用 kill 命令终止进程 网上关于这两块的内容 PS ps 简介 ps 命令就是最根本相应情况下也是相当强大地进程查看命令.运用该命令可以确定有哪些进程正在运行和运行地状态、 进程 是否结束、进程有没有僵死、哪些进程占用了过多地资源等等.总之大部分信息均为可以通过执行该命令得到地. ps 命令及其参数 ps 命令最经常使用地还是用于监控后台进程地工作情况,因为后台进程是不和屏幕键盘这些标准输入/输出设 备进行通信地,所以如果需要检测其情况,便可以运用 ps 命令了. 该命令语法格式如下： ps [选项] -e 显示所有进程,环境变量 -f 全格式 -h 不显示标题 -l 长格式 -w 宽输出 a 显示终端上地所有进程,包括其他用户地进程 r 只显示正在运行地进程 x 显示没有控制终端地进程 O[+|-] k1 [,[+|-] k2 [,…]] 根据 SHORT KEYS、k1、k2 中快捷键指定地多级排序顺序显示进程列表. 对于 ps 地不同格式都存在着默认地顺序指定.这些默认顺序可以被用户地指定所覆盖.在这里面“+”字符是可选地,“-” 字符是倒转指定键地方向. pids 只列出进程标识符,之间运用逗号分隔.该进程列表必须在命令行参数地最后一个选项后面紧接着给出,中间不能插入 空格.比如：ps -f1,4,5. 以下介绍长命令行选项,这些选项都运用“\u0026ndash;”开头： \u0026ndash;sort X[+|-] key [,[+|-] key [,…]] 从 SORT KEYS 段中选一个多字母键.“+”字符是可选地,因为默认地方向就是按 数字升序或者词典顺序.比如： ps -jax -sort=uid,-ppid,+pid. \u0026ndash;help 显示帮助信息. \u0026ndash;version 显示该命令地版本信息. 在前面地选项说明中提到了排序键,接下来对排序键作进一步说明.需要注意地是排序中运用地值是 ps 运用地内部值,并非 仅用于某些输出格式地伪值.排序键列表见表 4-3. 表 4-3 排序键列表 c cmd 可执行地简单名称 C cmdline 完整命令行 f flags 长模式标志 g pgrp 进程地组 ID G tpgid 控制 tty 进程组 ID j cutime 累计用户时间 J cstime 累计系统时间 k utime 用户时间 K stime 系统时间 m min_flt 次要页错 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/linux-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%88%A0%E9%99%A4%E8%BF%9B%E7%A8%8B\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/linux-source%E5%91%BD%E4%BB%A4%E5%8F%8A%E8%84%9A%E6%9C%AC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F%E8%A7%A3%E6%9E%90\/": {
        "title": "Linux-Source命令及脚本的执行方式解析",
        "tags": ["linux",],
        "content": "当我修改了/etc/profile文件，我想让它立刻生效，而不用重新登录；这时就想到用source命令，如:source /etc/profile 对source进行了学习，并且用它与sh 执行脚本进行了对比，现在总结一下。\nsource命令： source命令也称为“点命令”，也就是一个点符号（.）,是bash的内部命令。 功能：使Shell读入指定的Shell程序文件并依次执行文件中的所有语句 source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。 用法： source filename 或 . filename source命令(从 C Shell 而来)是bash shell的内置命令;点命令(.)，就是个点符号(从Bourne Shell而来)是source的另一名称。 source filename 与 sh filename 及./filename执行脚本的区别在那里呢？ 1.当shell脚本具有可执行权限时，用sh filename与./filename执行脚本是没有区别得。./filename是因为当前目录没有在PATH中，所有\u0026quot;.\u0026ldquo;是用来表示当前目录的。 2.sh filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，除非使用export。 3.source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。 举例说明： 1.新建一个test.sh脚本，内容为:A=1 2.然后使其可执行chmod +x test.sh 3.运行sh test.sh后，echo $A，显示为空，因为A=1并未传回给当前shell 4.运行./test.sh后，也是一样的效果 5.运行source test.sh 或者 . test.sh，然后echo $A，则会显示1，说明A=1的变量在当前shell中\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/linux-source%E5%91%BD%E4%BB%A4%E5%8F%8A%E8%84%9A%E6%9C%AC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F%E8%A7%A3%E6%9E%90\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos%E4%B8%AD%E5%AE%89%E8%A3%85php%E7%9A%84pdo-mysql%E6%89%A9%E5%B1%95\/": {
        "title": "Centos中安装PHP的PDO-MySQL扩展",
        "tags": ["centos","php",],
        "content": "1、下载 文件 或者 进入 在PHP源码包中进入ext/pdo_mysql http://pecl.php.net/get/PDO_MYSQL-1.0.2.tgz 2、解压文件\ntar zxvf PDO_MYSQL-1.0.2.tgz 3、配置和编译文件\ncd PDO_MYSQL-1.0.2 /usr/local/php/bin/phpize ./configure –with-php-config=/usr/local/php/bin/php-config –with-pdo-mysql=/usr/local/mysql make make install 注： 我的PHP安装在 ： /usr/local/php/ mysql 安装在 ： /usr/local/mysql 编译的时候注意你自己的安装目录在哪里 3、安装到PHP配置下\n把这个记住，然后打开 php.ini文件， 并添加一行\nextension=pdo_mysql.so ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos%E4%B8%AD%E5%AE%89%E8%A3%85php%E7%9A%84pdo-mysql%E6%89%A9%E5%B1%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos-6-5-%E6%9B%B4%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4\/": {
        "title": "Centos-6-5-更改系统时间",
        "tags": ["centos",],
        "content": "date 时间窗口 date -s \u0026#39;2015-02-02 10:10:00\u0026#39; 更改年月日小时分秒 date -s 10:00:02 只更改时间 不更改年月 clock -w 写入系统时间 hwclock 同步bios 时间 service ntpdate start 开启网络时间同步 systemctl start ntpdate.service 开启网络时间同步 Red Hat 7 chkconfig --leves 2345 ntpdate on 开机启动 reboot 重启报错 or type Contril-D to contime:输入系统密码-根据报错修复 fsck -y /dev/mapper/VolGroup-lv_root fsck -y /dev/sda1 reboot 重启是否正常 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos-6-5-%E6%9B%B4%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos-6-4-php-fpm-%E6%B7%BB%E5%8A%A0service-%E6%B7%BB%E5%8A%A0%E5%B9%B3%E6%BB%91%E5%90%AF%E5%8A%A8-%E9%87%8D%E5%90%AF\/": {
        "title": "CentOS-6-4-php-fpm-添加service-添加平滑启动-重启",
        "tags": ["php-fpm",],
        "content": "我的php是源码安装的。php-fpm在PHP 5.3.2以后的版本不支持以前的php-fpm (start|restart|stop|reload) ，那么如果将php-fpm配置成服务，并添加平滑启动/重启。 配置php-fpm.conf（vi /usr/local/php54/etc/php-fpm.conf）,将pid（;pid = run/php-fpm.pid）前的;去掉。 因为编译安装php的，所以会在php目录生成很多二进制文件，找到init.d.php-fpm，拷贝到init.d下。\ncp /usr/local/src/php54/sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm 设置权限，并添加服务\nchmod +x /etc/init.d/php-fpm chkconfig --add php-fpm 以后可以使用如下命令管理php-fpm了\nservice php-fpm start service php-fpm stop service php-fpm restart service php-fpm reload ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos-6-4-php-fpm-%E6%B7%BB%E5%8A%A0service-%E6%B7%BB%E5%8A%A0%E5%B9%B3%E6%BB%91%E5%90%AF%E5%8A%A8-%E9%87%8D%E5%90%AF\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/php-fpm\/": {
        "title": "php-fpm",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/php-fpm\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/mysql%E5%8F%8C%E4%B8%BB%E5%90%8C%E6%AD%A5\/": {
        "title": "Mysql双主同步",
        "tags": ["mysql",],
        "content": "平台：centos7,mysql5.6.34\n解决数据库瓶颈问题 两台服务器可以同时读写数据库 A B两台服务器 A和B需要拥有一个同名的数据库 同步账号设置 首先要在两台服务器上各新增加一个可登陆的账号。\nA端50\nmysql\u0026gt;grant replication slave,file on *.* to \u0026#39;sync_user\u0026#39;@\u0026#39;192.168.10.58\u0026#39; identified by \u0026#39;123456\u0026#39;; B端58\nmysql\u0026gt;grant replication slave,file on *.* to \u0026#39;sync_user\u0026#39;@\u0026#39;192.168.10.50\u0026#39; identified by \u0026#39;123456\u0026#39;; 修改my.cnf主配置文件\nvim /etc/my.cnf 在 [mysqld] 添加\n[mysqld] A端 log-bin=mysql-bin #启动二进制日志系统 server-id=1 #本机数据库ID标示为主，另一为2 binlog-do-db=test #二进制需同步的数据库名 binlog-ignore-db=mysql #避免同步用户数据库配置 replicate-do-db=test #同步数据库的名称 replicate-ignore-db=mysql #屏蔽对mysql数据库的同步 log-slave-updates slave-skip-errors=all sync_binlog=1 auto_increment_increment=2 auto_increment_offset=1 #B端配置2 B端 log-bin=mysql-bin #启动二进制日志系统 server-id=2 #本机数据库ID标示为主，另一为1 binlog-do-db=test #二进制需同步的数据库名 binlog-ignore-db=mysql #避免同步用户数据库配置 replicate-do-db=test #同步数据库的名称 replicate-ignore-db=mysql #屏蔽对mysql数据库的同步 log-slave-updates slave-skip-errors=all sync_binlog=1 auto_increment_increment=2 auto_increment_offset=2 #A端配置1 mysql -u root -p mysql\u0026gt;flush tables with read lock; #锁定表格 service mysqld restart mysql\u0026gt;show master status\\G ＃查看主服务器同步状态 A端是这样的\nmysql\u0026gt; show master status\\G *************************** 1. row *************************** File: mysql-bin.000001 Position: 106 Binlog_Do_DB: test Binlog_Ignore_DB: mysql 1 row in set (0.00 sec) B端是这样的\nmysql\u0026gt; show master status\\G *************************** 1. row *************************** File: mysql-bin.000002 Position: 106 Binlog_Do_DB: test Binlog_Ignore_DB: mysql 1 row in set (0.00 sec) 设定同步服务器ip 用户名与口令和日志文件名与show master status\\G 输出结果一致。\nA端： mysql\u0026gt;change master to master_host=\u0026#39;192.168.10.58\u0026#39;, master_user=\u0026#39;sync_user\u0026#39;, master_password=\u0026#39;123456\u0026#39;, master_log_file=\u0026#39;mysql-bin.000002\u0026#39;, master_log_pos=106; B端： mysql\u0026gt;change master to master_host=\u0026#39;192.168.10.50\u0026#39;, master_user=\u0026#39;sync_user\u0026#39;, master_password=\u0026#39;123456\u0026#39;, master_log_file=\u0026#39;mysql-bin.000001\u0026#39;, master_log_pos=106; start slave; 两段互为辅助 show slave status\\G 验证配置 unlock tables; 解锁验证 1 . Master_host 指的是 主服务器的地址。\n2 . Master_user 指的是主服务器上用来复制的用户。 从服务器会用此账号来登录主服务。进行复制。\n3 . Master_log_file 就是前面提到的， 主服务器上的日志文件名.\n4 . Read_Master_log_pos 就是前面提到的主服务器的日志记录位置， 从服务器根据这两个条件来选择复制的文件和位置。\n5 . Slave_IO_Running 指的就是从服务器上负责读取主服务器的线程工作状态。 从服务器用这个专门的线程链接到主服务器上，并把日志拷贝回来。\n6 . Slave_SQL_Running 指的就是专门执行sql的线程。 它负责把复制回来的Relaylog执行到自己的数据库中。 这两个参数必须都为Yes 才表明复制在正常工作。\n此时你在A或者B端对test数据库里的内容进行修改，另一端会同步你的更改\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/mysql%E5%8F%8C%E4%B8%BB%E5%90%8C%E6%AD%A5\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/mysql%E4%BD%BF%E7%94%A8symbolic-links%E4%BB%A5%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8\/": {
        "title": "MySQL使用Symbolic-Links以支持数据分区存储",
        "tags": ["mysql",],
        "content": "MySQL数据库及表(仅MyISAM)支持符号链接(symbolic link)，即数据库或表可以存储在my.cnf中指定datadir之外的分区或目录。 要支持符号链接，需要在配置中设置symbolic-links=1(较新的版本为默认开启)\n假设my.cnf有设置data目录:\ndatadir=/data1/mysql/data/ 而在另一个分区目录下保存有数据数据库TestDB:\n/data2/mysql/data/TestDB 那么可以这样使得同一个MySQL实例能同时管理TestDB:\nln -s /data2/mysql/data/TestDB /data1/mysql/data/ 所有文件相关权限设置正确后，MySQL就可以管理TestDB了。 值得注意的是，TestDB最好只能为一个MySQL服务来操作，否则会出现意想不到的问题。使用symbolic link的一个好处是当一个磁盘或分区空间不够时，可以将数据存储到其他的磁盘或分区。\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/mysql%E4%BD%BF%E7%94%A8symbolic-links%E4%BB%A5%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos7%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx\/": {
        "title": "centos7编译安装nginx",
        "tags": ["centos","nginx",],
        "content": "ps : nginx安装在/opt/local/nginx里\n1.安装编译安装依赖的类库和包\n如果需要编译MySQL和PHP，就安装这些\nyum install -y make apr* autoconf automake curl curl-devel gcc gcc-c++ gtk+-devel zlib-devel openssl openssl-devel pcre-devel gd kernel keyutils patch perl kernel-headers compat* cpp glibc libgomp libstdc++-devel keyutils-libs-devel libsepol-devel libselinux-devel krb5-devel libXpm* freetype freetype-devel freetype* fontconfig fontconfig-devel libjpeg* libpng* php-common php-gd gettext gettext-devel ncurses* libtool* libxml2 libxml2-devel patch policycoreutils bison 如果只编译nginx，就安装这些\nyum install gcc gcc-c++ autoconf automake zlib zlib-devel openssl openssl-devel pcre-devel 2.编译安装pcre\nPS：Pcre版本不能太高，8最好，要不编译不能通过\nmkdir /usr/local/pcre #创建安装目录 tar zxvf pcre-8.34.tar.gz cd pcre-8.34 ./configure --prefix=/opt/local/pcre #配置 make \u0026amp;\u0026amp; make install 3.配置 Nginx 安装选项\nchecking for OS + Linux 3.10.0-327.22.2.el7.x86_64 x86_64 checking for C compiler ... found + using GNU C compiler + gcc version: 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) checking for gcc -pipe switch ... found checking for -Wl,-E switch ... found checking for gcc builtin atomic operations ... found checking for C99 variadic macros ... found checking for gcc variadic macros ... found checking for gcc builtin 64 bit byteswap ... found checking for unistd.h ... found checking for inttypes.h ... found checking for limits.h ... found checking for sys/filio.h ... not found checking for sys/param.h ... found checking for sys/mount.h ... found checking for sys/statvfs.h ... found checking for crypt.h ... found checking for Linux specific features checking for epoll ... found checking for EPOLLRDHUP ... found checking for EPOLLEXCLUSIVE ... not found checking for O_PATH ... found checking for sendfile() ... found checking for sendfile64() ... found checking for sys/prctl.h ... found checking for prctl(PR_SET_DUMPABLE) ... found checking for sched_setaffinity() ... found checking for crypt_r() ... found checking for sys/vfs.h ... found checking for poll() ... found checking for /dev/poll ... not found checking for kqueue ... not found checking for crypt() ... not found checking for crypt() in libcrypt ... found checking for F_READAHEAD ... not found checking for posix_fadvise() ... found checking for O_DIRECT ... found checking for F_NOCACHE ... not found checking for directio() ... not found checking for statfs() ... found checking for statvfs() ... found checking for dlopen() ... not found checking for dlopen() in libdl ... found checking for sched_yield() ... found checking for SO_SETFIB ... not found checking for SO_REUSEPORT ... found checking for SO_ACCEPTFILTER ... not found checking for SO_BINDANY ... not found checking for IP_BIND_ADDRESS_NO_PORT ... not found checking for IP_TRANSPARENT ... found checking for IP_BINDANY ... not found checking for IP_RECVDSTADDR ... not found checking for IP_PKTINFO ... found checking for IPV6_RECVPKTINFO ... found checking for TCP_DEFER_ACCEPT ... found checking for TCP_KEEPIDLE ... found checking for TCP_FASTOPEN ... found checking for TCP_INFO ... found checking for accept4() ... found checking for eventfd() ... found checking for int size ... 4 bytes checking for long size ... 8 bytes checking for long long size ... 8 bytes checking for void * size ... 8 bytes checking for uint32_t ... found checking for uint64_t ... found checking for sig_atomic_t ... found checking for sig_atomic_t size ... 4 bytes checking for socklen_t ... found checking for in_addr_t ... found checking for in_port_t ... found checking for rlim_t ... found checking for uintptr_t ... uintptr_t found checking for system byte ordering ... little endian checking for size_t size ... 8 bytes checking for off_t size ... 8 bytes checking for time_t size ... 8 bytes checking for AF_INET6 ... found checking for setproctitle() ... not found checking for pread() ... found checking for pwrite() ... found checking for pwritev() ... found checking for sys_nerr ... found checking for localtime_r() ... found checking for posix_memalign() ... found checking for memalign() ... found checking for mmap(MAP_ANON|MAP_SHARED) ... found checking for mmap(\u0026#34;/dev/zero\u0026#34;, MAP_SHARED) ... found checking for System V shared memory ... found checking for POSIX semaphores ... not found checking for POSIX semaphores in libpthread ... found checking for struct msghdr.msg_control ... found checking for ioctl(FIONBIO) ... found checking for struct tm.tm_gmtoff ... found checking for struct dirent.d_namlen ... not found checking for struct dirent.d_type ... found checking for sysconf(_SC_NPROCESSORS_ONLN) ... found checking for openat(), fstatat() ... found checking for getaddrinfo() ... found checking for PCRE library ... found checking for PCRE JIT support ... found checking for OpenSSL library ... found checking for zlib library ... found checking for libxslt ... found checking for libexslt ... found checking for GD library ... found checking for GD WebP support ... not found creating objs/Makefile Configuration summary + using system PCRE library + using system OpenSSL library + using system zlib library #配置地址 nginx path prefix: \u0026#34;/opt/local/nginx\u0026#34; nginx binary file: \u0026#34;/opt/local/nginx/sbin/nginx\u0026#34; nginx modules path: \u0026#34;/opt/local/nginx/modules\u0026#34; nginx configuration prefix: \u0026#34;/opt/local/nginx/conf\u0026#34; nginx configuration file: \u0026#34;/opt/local/nginx/conf/nginx.conf\u0026#34; nginx pid file: \u0026#34;/opt/local/nginx/logs/nginx.pid\u0026#34; nginx error log file: \u0026#34;/opt/local/nginx/logs/error.log\u0026#34; nginx http access log file: \u0026#34;/opt/local/nginx/logs/access.log\u0026#34; nginx http client request body temporary files: \u0026#34;client_body_temp\u0026#34; nginx http proxy temporary files: \u0026#34;proxy_temp\u0026#34; nginx http fastcgi temporary files: \u0026#34;fastcgi_temp\u0026#34; nginx http uwsgi temporary files: \u0026#34;uwsgi_temp\u0026#34; nginx http scgi temporary files: \u0026#34;scgi_temp\u0026#34; 编译完成之后注意nginx path prefix 到 nginx http access log file 这几行配置信息，后面需要用的到。\n4.安装 Nginx\nmake \u0026amp;\u0026amp; make install 5.配置 systemd Nginx 服务和设置 Nginx 自启动\ncentos 7 中采用 systemd 来管理系统，我们来为 nginx 创建服务文件，来实现通过 systemd 来管理 nginx 。 创建 systemd 服务文件： /lib/systemd/system/nginx.service，内容如下：\n[Unit] Description=The NGINX HTTP and reverse proxy server After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=forking PIDFile=/opt/local/nginx/logs/nginx.pid ExecStartPre=/opt/local/nginx/sbin/nginx -t ExecStart=/opt/local/nginx/sbin/nginx ExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target 这里的 PIDFile 的配置要和前面的 配置保持一致。\n设置自启动\nsystemctl enable nginx 通过 systemd 管理 nginx\nsystemctl start nginx systemctl stop nginx systemctl restart nginx systemctl reload nginx ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos7%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos6-5%E5%BC%80%E5%90%AF-%E5%85%B3%E9%97%AD%E7%AB%AF%E5%8F%A3\/": {
        "title": "centos6-5开启-关闭端口",
        "tags": ["centos",],
        "content": "列出所有端口\nnetstat -ntlp 1、开启端口（以80端口为例）\n方法一：\n/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT 写入修改 /etc/init.d/iptables save 保存修改 service iptables restart 重启防火墙，修改生效 方法二：\nvi /etc/sysconfig/iptables 打开配置文件加入如下语句: -A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT 重启防火墙，修改完成 2、关闭端口\n方法一：\n/sbin/iptables -I INPUT -p tcp --dport 80 -j DROP 写入修改 /etc/init.d/iptables save 保存修改 service iptables restart 重启防火墙，修改生效 方法二：\nvi /etc/sysconfig/iptables 打开配置文件加入如下语句: -A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j DROP 重启防火墙，修改完成 3、查看端口状态\n/etc/init.d/iptables status ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos6-5%E5%BC%80%E5%90%AF-%E5%85%B3%E9%97%AD%E7%AB%AF%E5%8F%A3\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/samba\/": {
        "title": "samba",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/samba\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/windows%E9%80%9A%E8%BF%87samba%E8%AE%BF%E9%97%AElinux%E6%96%87%E4%BB%B6\/": {
        "title": "Windows通过Samba访问Linux文件",
        "tags": ["samba",],
        "content": "安装\nyum install samba smaba-client 配置\n我想设置root用户给samba，并设置其密码，执行以下命令\nsmbpasswd -a root 这个命令也可以修改设置的用户的密码\n这里的意思是说，当windows登录到Linux共享文件夹的时候输入的用户名root和密码(刚刚设置的)\n配置下smb.conf\nvim /etc/samba/smb.conf ⒈找到security = XXXX\n设置其为 security = root ⒉定位到该文件的最后，添加以下代码\n[root] comment = share path = /www browseable = yes guest ok = yes writable = yes path的意思是说我要共享的文件夹路径，其他的设置成yes就OK\n④使用windows连接Linux共享的这个文件夹 windows : 开始 -\u0026gt; 输入\\192.168.10.52 (该IP为Linux的IP地址) -\u0026gt; 输入设置好的用户名和密码即可连接。。\nps:linux需要开启139和445端口\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/windows%E9%80%9A%E8%BF%87samba%E8%AE%BF%E9%97%AElinux%E6%96%87%E4%BB%B6\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/samba-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3\/": {
        "title": "Samba-配置文件详解",
        "tags": ["linux","samba",],
        "content": "Samba 的配置文件 /etc/samba/smb.conf 分为两大部分，一部分是 [global] ，即全局配置，另一部分是 [home] 、[printer] 、[自定义共享名] ，这些都是共享的部分，共享部分的设置优先级高于全局配置，另外，Samba 默认开启本地用户家目录 [home] 和打印机 [printer] 的共享，如果不需要你也可以关闭这两个共享，然后在末行自己重新创建一个共享，下面是详细的配置，你可以自定义一个共享，然后自己选择需要哪些配置：\n[pzk] # 自定义共享名 comment = Home Directories # 描述符，是给系统管理员看的 path = /tmp # 共享的路径 public = yes # 是否公开，也就是是否能在网上邻居看到该共享 browseable = yes # 共享的目录是否让所有人可见 writable = yes # 是否可写 guest ok = no # 是否拒绝匿名访问，仅当安全级别为 share 时才生效 workgroup = WORKGROUP # 工作组，要设置成跟 Windows 的工作组一致 server string = Samba Server Version %v # 其他 Linux 主机查看共享时的提示符 netbios name = MYSERVER # 用于在 Windows 网上邻居上显示的主机名 hosts allow = 127. 192.168.12. 192.168.13. EXCEPT 192.168.13.13 # 指定允许访问 samba 服务器的主机 security = share # 定义安全级别 log file = /var/log/samba/log.%m # 定义日志文件，每个访问的主机会产生独立的日志文件，%m 是客户端主机名 max log size = 50 # 定义单个日志的最大容量（KB） passdb backend = tdbsam # Samba 用户的存储方式，smbpasswd 表示明文存储，tdbsam 表示密文存储 deadtime = 10 # 客户端在10分钟内没有打开任何 Samba 资源，服务器将自动关闭会话，在大量的并发访问环境中，这样的设置可以提高服务器性能 display charset = UTF8 # 设置显示的字符集 max connections = 0 # 设置最大连接数，0表示无限制，如果超过最大连接数则拒绝连接 guest account = nobody # 设置匿名账户为nobody load printers = yes # 是否在启动 Samba 时就共享打印机 cups options = raw # 设置打印机使用的方式 valid users = user1 user2 user3 # 指定哪些用户可以访问，如果不指定则所有用户都可访问 invalid users = user1 user2 # 指定哪些用户不可以访问 create mask = 0775 # 客户端上传文件的默认权限 directory mask = 0775 # 客户端创建目录的默认权限 write list = user1 user2 user3 # 设置可对文件进行写操作的用户 admin users = user1 # 设置共享目录的管理员，具有完全权限 安全级别： share ：表示匿名用户，不需要 samba 账户就可登陆 samba 服务器 user ：系统账户要先添加进 samba 库然后变成 samba 用户，使用 samba 用户来登陆，简单来讲就是需要使用用户密码登录 server ：由另外一台 samba 服务器来对用户进行身份验证 domain ：把 samba 服务器加入到 NT 域，由 NT 的域控制器来进行身份验证 ADS ：（Active Directory Service，活动目录服务），是 samba3.0 中新增的身份验证方式，采用 ADS 验证方式，samba 服务器集成到活动目录中 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/samba-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/firewalld\/": {
        "title": "firewalld",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/firewalld\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E4%BD%BF%E7%94%A8firewalld%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E7%AB%AF%E5%8F%A3\/": {
        "title": "使用firewalld打开关闭防火墙与端口",
        "tags": ["linux","firewalld",],
        "content": "1、firewalld的基本使用\n启动： systemctl start firewalld\n查看状态： systemctl status firewalld\n停止： systemctl disable firewalld\n禁用： systemctl stop firewalld\n2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。\n启动一个服务：systemctl start firewalld.service\n关闭一个服务：systemctl stop firewalld.service\n重启一个服务：systemctl restart firewalld.service\n显示一个服务的状态：systemctl status firewalld.service\n在开机时启用一个服务：systemctl enable firewalld.service\n在开机时禁用一个服务：systemctl disable firewalld.service\n查看服务是否开机启动：systemctl is-enabled firewalld.service\n查看已启动的服务列表：systemctl list-unit-files|grep enabled\n查看启动失败的服务列表：systemctl –failed\n3.配置firewalld-cmd\n查看版本： firewall-cmd –version\n查看帮助： firewall-cmd –help\n显示状态： firewall-cmd –state\n查看所有打开的端口： firewall-cmd –zone=public –list-ports\n更新防火墙规则： firewall-cmd –reload\n查看区域信息: firewall-cmd –get-active-zones\n查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0\n拒绝所有包：firewall-cmd –panic-on\n取消拒绝状态： firewall-cmd –panic-off\n查看是否拒绝： firewall-cmd –query-panic\n那怎么开启一个端口呢\n添加 firewall-cmd –zone=public –add-port=80/tcp –permanent （–permanent永久生效，没有此参数重启后失效）\n重新载入 firewall-cmd –reload\n查看 firewall-cmd –zone= public –query-port=80/tcp\n删除 firewall-cmd –zone= public –remove-port=80/tcp –permanent\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E4%BD%BF%E7%94%A8firewalld%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E7%AB%AF%E5%8F%A3\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/ubuntu\/": {
        "title": "ubuntu",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/ubuntu\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E5%B0%86ubuntu%E4%B8%BB%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8C%E7%9A%84%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0%E6%94%B9%E6%88%90%E8%8B%B1%E6%96%87\/": {
        "title": "将Ubuntu主文件夹里的中文文件夹名称改成英文",
        "tags": ["ubuntu",],
        "content": "Ubuntu中文版本把用户主目录下的文件夹名称都默认设置成了中文（home文件里用户目录的“桌面”、“图片”、“视频”、“音乐”……都是中文的），这其实对于英文不太好才选择中文版本的Ubuntu系统也未必是一件好事，当在各个路径跳转的时候必须得使用中英文切换，感觉很复杂，所以这些默认文件夹名称还是英文的比较好。下面是将中文名称调整为英文的方法。\n第一种调整方法\n首先打开终端，在终端中输入命令:\nexport LANG=en_US xdg-user-dirs-gtk-update 然后会跳出对话框询问是否将目录转化为英文路径,同意并关闭.\n在终端中输入命令：\nexport LANG=zh_CN 最后关闭终端,并重起系统.下次再进入系统时，会提示是否把转化好的目录改回中文.选择不再提示,并取消修改.主目录的中文转英文就完成了。\n第二种调整方法\n首先通过可视化界面修改现有主文件夹下各文件夹名称（就是右键重命名）： Desktop、 Download、Documents、 Pictures、 Videos 、 Music、 Templates、Public ……\n然后修改配置文件（采用vi或者gedit都可以，此处以gedit为例）：\n打开一个终端输入命令打开配置文件编辑器\nvim ~/.config/user-dirs.dirs 把文件夹指向改掉，等号右边引号中即为指向，调整为刚才通过重命名所更改的文件名\nXDG_DESKTOP_DIR=\u0026#34;$HOME/Desktop\u0026#34; XDG_DOWNLOAD_DIR=\u0026#34;$HOME/Download\u0026#34; XDG_TEMPLATES_DIR=\u0026#34;$HOME/Templates\u0026#34; XDG_DOCUMENTS_DIR=\u0026#34;$HOME/Documents\u0026#34; XDG_MUSIC_DIR=\u0026#34;$HOME/Music\u0026#34; XDG_PICTURES_DIR=\u0026#34;$HOME/Pictures\u0026#34; XDG_VIDEOS_DIR=\u0026#34;$HOME/Videos\u0026#34; XDG_PUBLICSHARE_DIR=\u0026#34;$HOME/Public\u0026#34; 调整完之后，Ubuntu主目录下文件夹中文名称改为英文就调整好了。\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E5%B0%86ubuntu%E4%B8%BB%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8C%E7%9A%84%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0%E6%94%B9%E6%88%90%E8%8B%B1%E6%96%87\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98e-%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E9%94%81-var-lib-dpkg-lock-open-11-%E8%B5%84%E6%BA%90%E6%9A%82%E6%97%B6%E4%B8%8D%E5%8F%AF%E7%94%A8-e-%E6%97%A0%E6%B3%95%E9%94%81%E5%AE%9A%E7%AE%A1%E7%90%86%E7%9B%AE%E5%BD%95\/": {
        "title": "解决问题E-无法获得锁-var-lib-dpkg-lock-open-11-资源暂时不可用-E-无法锁定管理目录",
        "tags": ["linux",],
        "content": "在用sudo apt-get update 更新时，终端提示:\n“E: 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用) E: 无法锁定管理目录(/var/lib/dpkg/)，是否有其他进程正占用它？” 解决办法如下：\n1.终端输入 ps -aux ，列出进程。找到含有apt‘-get的进程，直接sudo kill PID。解决。\n2.强制解锁,命令\nsudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98e-%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E9%94%81-var-lib-dpkg-lock-open-11-%E8%B5%84%E6%BA%90%E6%9A%82%E6%97%B6%E4%B8%8D%E5%8F%AF%E7%94%A8-e-%E6%97%A0%E6%B3%95%E9%94%81%E5%AE%9A%E7%AE%A1%E7%90%86%E7%9B%AE%E5%BD%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/ubuntu%E4%BF%AE%E6%94%B9su%E5%AF%86%E7%A0%81\/": {
        "title": "ubuntu修改su密码",
        "tags": ["ubuntu",],
        "content": "非常简单，下面是设置的方法：\ngabe@gabe-TM-1613:~$ sudo passwd Password: \u0026lt;--- sudo的密码 Enter new UNIX password: \u0026lt;--- 新的Root用户密码 Retype new UNIX password: \u0026lt;--- 重复新的Root用户密码 passwd ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/ubuntu%E4%BF%AE%E6%94%B9su%E5%AF%86%E7%A0%81\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/mysql-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6mysql-bin%E6%96%87%E4%BB%B6%E6%B8%85%E9%99%A4%E6%96%B9%E6%B3%95\/": {
        "title": "mysql-日志文件mysql-bin文件清除方法",
        "tags": ["mysql",],
        "content": "默认情况下mysql会一直保留mysql-bin文件，这样到一定时候，磁盘可能会被撑满，这时候是否可以删除这些文件呢，是否可以安全删除，是个问题。\n首先要说明一下，这些文件都是mysql的日志文件，如果不做主从复制的话，基本上是没用的，虽然没用，但是不建议使用rm命令删除，这样有可能会不安全，正确的方法是通过mysql的命令去删除。\nmysql -u root -p Enter password:Welcome to the MySQL monitor.Commandsendwith;or \\g.YourMySQL connection id is2819416Server version:5.5.24-0ubuntu0.12.04.1-log (Ubuntu)Copyright(c)2000,2011,Oracleand/or its affiliates.All rights reserved.Oracleis a registered trademark of OracleCorporationand/or its affiliates.Other names may be trademarks of their respective owners.Type\u0026#39;help;\u0026#39;or\u0026#39;\\h\u0026#39;for help.Type\u0026#39;\\c\u0026#39; to clear the current input statement. mysql\u0026gt; reset master;Query OK,0 rows affected (3 min 37.65 sec) 其实关键的命令就是reset master;这个命令会清空mysql-bin文件。\n另外如果你的mysql服务器不需要做主从复制的话，建议通过修改my.cnf文件，来设置不生成这些文件，只要删除my.cnf中的下面一行就可以了。\nlog-bin=mysql-bin 如果你需要复制，最好控制一下这些日志文件保留的天数，可以通过下面的配置设定日志文件保留的天数：\nexpire_logs_days =7 表示保留7天的日志，这样老日志会自动被清理掉。\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/mysql-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6mysql-bin%E6%96%87%E4%BB%B6%E6%B8%85%E9%99%A4%E6%96%B9%E6%B3%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/virtualbox-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9-cannot-create-symlink-error\/": {
        "title": "Virtualbox 共享文件夹 cannot create symlink error",
        "tags": ["linux","golang",],
        "content": "npm操作虚拟机共享文件夹里的文件时出现 npm Error: EROFS: read-only file system, symlink的报错信息。\n解决方法 原来VirtualBox从安全角度出发，限制了软链接的创建，需要打开相应的Feature。以下为详细步骤：\n关闭 VirtualBox。 将VirtualBox安装目录的路径加入系统环境变量PATH中。 打开命令行窗口，执行如下命令： VBoxManage setextradata YOURVMNAME VBoxInternal2/SharedFoldersEnableSymlinksCreate/YOURSHAREFOLDERNAME 1 其中：YOURVMNAME为虚拟机中linux系统的名称 YOURSHAREFOLDERNAME 为共享的目录名称\n“以管理者身份运行” VirtualBox　即可！ ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/virtualbox-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9-cannot-create-symlink-error\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E5%AE%89%E8%A3%85golang\/": {
        "title": "安装golang",
        "tags": ["linux","golang",],
        "content": "到官方https://golang.org/dl/\n或者 https://www.golangtc.com/download 下载安装包\nwget https://www.golangtc.com/static/go/1.9/go1.9.linux-amd64.tar.gz tar zxvf go1.9.linux-amd64.tar.gz -C /usr/local 新建GOPATH目录\nmkdir -p /www/golang vim /etc/profile export GOROOT=/usr/local/go export GOBIN=$GOROOT/bin export PATH=$PATH:$GOBIN export GOPATH=/www/golang :wq保存 使其生效\nsource /etc/profile 查看是否配置成功\ngo version go version go1.9 linux/amd64 简单测试：\ncd /www/golang vim hello.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, world\u0026#34;) } :wq go run hello.go Hello, world ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E5%AE%89%E8%A3%85golang\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E5%AE%89%E8%A3%85centos7%E6%96%87%E5%AD%97%E7%95%8C%E9%9D%A2%E7%89%88%E5%90%8E%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%94%A8yum%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA-cannot-find-a-valid-baseurl-for-repobase7x86-64-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\/": {
        "title": "安装CentOS7文字界面版后，无法联网，用yum安装软件提示-cannot-find-a-valid-baseurl-for-repobase7x86-64-的解决方法",
        "tags": ["centos",],
        "content": "无法联网的明显表现会有：\n1、yum install出现 Error: cannot find a valid baseurl or repo:base\n2、ping host会提示unknown host\n方法一、\n1、打开 vi /etc/sysconfig/network-scripts/ifcfg-eth0（每个机子都可能不一样，但格式会是“ifcfg-eth数字”），把ONBOOT=no，改为ONBOOT=yes\n2、重启网络：service network restart\n方法二、\n1、打开 vi /etc/resolv.conf，增加 nameserver 8.8.8.8\n2、重启网络: service network restart\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E5%AE%89%E8%A3%85centos7%E6%96%87%E5%AD%97%E7%95%8C%E9%9D%A2%E7%89%88%E5%90%8E%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%94%A8yum%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA-cannot-find-a-valid-baseurl-for-repobase7x86-64-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/ubuntu%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86\/": {
        "title": "ubuntu配置全局代理",
        "tags": ["ubuntu",],
        "content": "PS:使用 polipo 前需要先安装 shadowsocks\n启动shawdowsocks服务后，发现并不能翻墙上网，这是因为shawdowsocks是socks 5代理，需要客户端配合才能翻墙。\n为了让整个系统都走shawdowsocks通道，需要配置全局代理，可以通过polipo实现。\n首先是安装polipo：\nsudo apt-get install polipo 接着修改polipo的配置文件/etc/polipo/config：\nlogSyslog = true logFile = /var/log/polipo/polipo.log proxyAddress = \u0026#34;0.0.0.0\u0026#34; socksParentProxy = \u0026#34;127.0.0.1:1080\u0026#34; socksProxyType = socks5 chunkHighMark = 50331648 objectHighMark = 16384 serverMaxSlots = 64 serverSlots = 16 serverSlots1 = 32 重启polipo服务：\nsudo /etc/init.d/polipo restart 为终端配置http代理：\nexport http_proxy=\u0026#34;http://127.0.0.1:8123/\u0026#34; export https_proxy=\u0026#34;http://127.0.0.1:8123/\u0026#34; 接着测试下能否翻墙：\nping www.google.com 如果有响应，则全局代理配置成功。\n注意事项\n服务器重启后，下面两句需要重新执行：\nshawdowsocks启动，然后\nexport http_proxy=\u0026#34;http://127.0.0.1:8123/\u0026#34; ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/ubuntu%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/ubuntu-%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDu%E7%9B%98\/": {
        "title": "Ubuntu-手动挂载U盘",
        "tags": ["ubuntu",],
        "content": "1.在插入U盘前和插入U盘后，都输入同一个命令，检查多了哪个盘\ncat /proc/partitions 这里我发现多了\n8 16 7827424 sdb 8 17 7825423 sdb1 sdb是统称，所以新插入的U盘就是/dev/sdb1\n2.用命令检查新的U盘的文件系统格式\nroot@ www.linuxidc.com :/# fdisk -l /dev/sdb Disk /dev/sdb: 8015 MB, 8015282176 bytes 247 heads, 62 sectors/track, 1022 cylinders, total 15654848 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x0001fce0 Device Boot Start End Blocks Id System /dev/sdb1 * 62 15650907 7825423 c W95 FAT32 (LBA) 看到这里是FAT32格式。\n3.mount\nmount -t vfat /dev/sdb1 /media/usb 注意: mount -t 按两次tab键会提示输入什么文件系统类型 /media/usb是我自己创建的目录\n4.umount\numount /media/usb ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/ubuntu-%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDu%E7%9B%98\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos7%E4%B8%8B%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93\/": {
        "title": "centos7下使用yum安装mysql数据库",
        "tags": ["centos","mysql",],
        "content": "CentOS7的yum源中默认好像是没有mysql的。为了解决这个问题，我们要先下载mysql的repo源。\n1 . 下载mysql的repo源\nwget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 2 . 安装mysql-community-release-el7-5.noarch.rpm包\nsudo rpm -ivh mysql-community-release-el7-5.noarch.rpm 安装这个包后，会获得两个mysql的yum repo源：/etc/yum.repos.d/mysql-community.repo，/etc/yum.repos.d/mysql-community-source.repo。\n3 . 安装mysql\nsudo yum install mysql-server 根据步骤安装就可以了，不过安装完成后，没有密码，需要重置密码。\n4 . 重置密码\n重置密码前，首先要登录\nmysql -u root 登录时有可能报这样的错：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户：\nsudo chown -R root:root /var/lib/mysql 然后，重启服务：\nservice mysqld restart 接下来登录重置密码：\nmysql -u root mysql \u0026gt; use mysql; mysql \u0026gt; update user set password=password(\u0026#39;123456\u0026#39;) where user=\u0026#39;root\u0026#39;; mysql \u0026gt; exit; ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos7%E4%B8%8B%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%97%B6%E6%8A%A5%E9%94%99error-1794-hy000-slave\/": {
        "title": "主从复制时报错：ERROR-1794-HY000-Slave……",
        "tags": ["linux","mysql",],
        "content": "centos 6.5\nmysql5.7\n在从库作stop slave时报：\nerror: ERROR 1794 (HY000): Slave is not configured or failed to initialize properly. You must at least set --server-id to enable either a master or a slave. Additional error messages can be found in the MySQL error log. 经分析，需要：\n删除5张表，并重新导入脚本\nuse mysql drop table slave_master_info; drop table slave_relay_log_info; drop table slave_worker_info; drop table innodb_index_stats; drop table innodb_table_stats; source /usr/coolpad/mysql/share/mysql_system_tables.sql (2)重新启动数据库\n注：这一步是必须的，否则无法正常配置双主架构。\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%97%B6%E6%8A%A5%E9%94%99error-1794-hy000-slave\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/virtualbox%E4%B8%8Bcentos%E6%8C%82%E8%BD%BD%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9\/": {
        "title": "virtualbox下centos挂载共享文件夹",
        "tags": ["linux","virtualbox",],
        "content": "PS:要挂载共享文件，需要安装virtualbox增强功能(增强包) 安装virtualbox增强功能(增强包)：安装virtualbox增强功能(增强包)\n设备—\u0026gt;共享文件夹 宿主机 共享路径:E:\\project, 共享文件夹名称project\nmkdir /mnt/share //新建挂载点（mountpoint） mount -t vboxsf project /mnt/share // 挂载共享文件夹 cd /mnt/share 进入共享文件夹 OK 实现 开机挂载:\nvi ~/.bashrc 在最后添加\nmount -t vboxsf sharing /mnt/share 挂载共享文件夹 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/virtualbox%E4%B8%8Bcentos%E6%8C%82%E8%BD%BD%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86\/": {
        "title": "文件权限管理",
        "tags": ["linux",],
        "content": "三种基本权限\nR 读 数值表示为4 W 写 数值表示为2 X 可执行 数值表示为1 如图所示，downloads文件夹的权限为 drwxr-xr-x\ndrwxr-xr-x一共十个字符，分成四段。 第一个字符“d”表示目录；这个位置还可能会出现“l”链接；“-”表示普通文件 第二三四个字符“rwx”表示当前所属用户的权限。 所以用数值表示为4+2+1=7 第五六七个字符“r-x”表示当前所属组的权限。 所以用数值表示为4+1=5 第八九十个字符“r-x”表示其他用户权限。 所以用数值表示为4+1=5 所以操作此文件夹的权限用数值表示为755 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86\/": {
        "title": "linux软件包管理",
        "tags": ["linux",],
        "content": "dpkg (Debian Package)管理工具，软件包名以.deb后缀。这种方法适合系统不能联网的情况下。\n比如安装demo命令的安装包，先将demo.deb传到Linux系统中。再使用如下命令安装。\nsudo dpkg -i demo_1.5.3-1_i386.deb 安装软件 sudo dpkg -r demo 卸载软件 注：将demo.deb传到Linux系统中，有多种方式。VMwareTool，使用挂载方式；使用winSCP工具等；\nAPT（Advanced Packaging Tool）高级软件工具。这种方法适合系统能够连接互联网的情况。\n依然以demo为例\nsudo apt-get install demo 安装demo sudo apt-get remove demo 卸载demo sudo apt-get update 更新软件 sudo apt-get upgrade 将.rpm文件转为.deb文件\n.rpm为RedHat使用的软件格式。在Ubuntu下不能直接使用，所以需要转换一下。\nsudo alien abc.rpm ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/vim\/": {
        "title": "vim",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/vim\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/vim%E4%BD%BF%E7%94%A8\/": {
        "title": "vim使用",
        "tags": ["linux","vim",],
        "content": "vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。\n命令模式下：\n:q 退出 :q! 强制退出 :wq 保存并退出 :set number 显示行号 :set nonumber 隐藏行号 /apache 在文档中查找apache 按n跳到下一个，shift+n上一个 yyp 复制光标所在行，并粘贴 h(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→) 1、复制 1）单行复制 在命令模式下，将光标移动到将要复制的行处，按“yy”进行复制； 2）多行复制 在命令模式下，将光标移动到将要复制的首行处，按“nyy”复制n行；其中n为1、2、3…… 2、粘贴 在命令模式下，将光标移动到将要粘贴的行处，按“p”进行粘贴 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/vim%E4%BD%BF%E7%94%A8\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%89%E8%A3%85virtualbox%E5%A2%9E%E5%BC%BA%E5%8A%9F%E8%83%BD%E5%A2%9E%E5%BC%BA%E5%8C%85%E7%9A%84%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4\/": {
        "title": "在linux系统中安装virtualbox增强功能(增强包)的详细步骤",
        "tags": ["linux","virtualbox",],
        "content": "设置共享文件路径\n点击虚拟机 设置–\u0026gt;选择 共享文件夹\n（图1 设置共享文件夹）\n设置共享文件夹路径\n1 选择路径\n2 填写自定义的共享名称（在后面需要与挂载路径相对应）\n3 设置自动挂载/固定分配\n（图2 设置共享文件路径属性）\n安装VirtualBox增强工具\n先安装必备的包\n执行下面的命令:\nyum install -y gcc gcc-devel gcc-c++ gcc-c++-devel make kernel kernel-devel 安装完后，重启虚拟机：\nshutdown -r now 安装virtualBox增强工具\n点击 设置–\u0026gt;点击 安装增强功能…\n点击菜单栏 设备 –\u0026gt; 分配光驱 –\u0026gt; 选择一个虚拟光盘，找到VirtualBox安装目录下的VBoxGuestAdditions.iso，加载此镜像。 启动Linux系统并用root身份登入系统 执行挂载命令，将虚拟光盘挂在到 /mnt/cdrom，如果没有cdrom目录，则先创建之。\nmkdir /mnt/cdrom mount -t auto /dev/cdrom /mnt/cdrom 复制脚本到/tmp目录下\ncd /mnt/cdrom cp VBoxLinuxAdditions.run /tmp cd /tmp ./VBoxLinuxAddtion.run 得到输出内容\n如果centos是server版本的话就显示\n即安装成功！\n挂载共享文件夹\n切换到root用户输入挂载命令：\nsudo mount -t vboxsf shared_file /home/xingoo/shared 注意格式为\nsudo mount -t vboxsf 共享文件夹名称（在设置页面设置的） 挂载的目录 然后进入/home/xingoo/shared，就可以看到windows中的文件了\nwindows中的文件\n", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%89%E8%A3%85virtualbox%E5%A2%9E%E5%BC%BA%E5%8A%9F%E8%83%BD%E5%A2%9E%E5%BC%BA%E5%8C%85%E7%9A%84%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/yum-%E5%AE%89%E8%A3%85%E6%8A%A5-%E5%85%B3%E4%BA%8Epublic-key-for-.rpm-is-not-installed-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\/": {
        "title": "yum 安装报 关于Public key for .rpm is not installed 的解决方法",
        "tags": ["yum",],
        "content": "此时要导入rpm的签名信息即可\n以root登录，执行下面命令\nrpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release 根据我的Linux版本是CentOS 7\n于是我执行下面命令\nrpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/yum-%E5%AE%89%E8%A3%85%E6%8A%A5-%E5%85%B3%E4%BA%8Epublic-key-for-.rpm-is-not-installed-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/warning-rpmdb-altered-outside-of-yum.%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-\/": {
        "title": "Warning RPMDB altered outside of yum.的解决办法",
        "tags": ["yum",],
        "content": "错误提示： Warning: RPMDB altered outside of yum 解决办法： 删除yum的历史记录\nrm -rf /var/lib/yum/history/*.sqlite ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/warning-rpmdb-altered-outside-of-yum.%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/mysql%E5%AE%9E%E7%8E%B0%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6\/": {
        "title": "mysql实现主从复制",
        "tags": ["linux","mysql",],
        "content": "准备工作：\n1.两个虚拟机：我这里用的是CentOS5.5，IP地址分别是192.168.1.101 和192.168.1.105；\n101做主服务器，105做从服务器（都已经安装相同版本的Mysql）；\n2.本机环境：Nginx+PHP+MySQL\n好了，现在开始吧，来看看这听起来高大上的主从复制是怎么回事。\n原理：mysql要做到主从复制，其实依靠的是二进制日志，即：假设主服务器叫A，从服务器叫B；主从复制就是\nB跟着A学，A做什么，B就做什么。那么B怎么同步A的动作呢？现在A有一个日志功能，把自己所做的增删改查的动作\n全都记录在日志中，B只需要拿到这份日志，照着日志上面的动作施加到自己身上就可以了。这样就实现了主从复制。\n扩展：MYSQL还有一种日志叫做：慢日志\n可以设置一个时间，那么所有执行时间超过这个时间的SQL都会被记录下来。这样就可以通过慢日志快速的找到网站中SQL的瓶颈来进行优化。\n实现步骤：\n1.首先修改mysql的配置文件，使其支持二进制日志功能。\n打开主服务器的mysql配置文件：my.conf\nvim /etc/my.cnf 加入如下三行代码：\n参数解释： log-bin=mysql-bin //将mysql二进制日志取名为mysql-bin\nbinlog_format=mixed //二进制日志的格式，有三种：statement/row/mixed,具体分别不多做解释，这里使用mixed\nserver-id=101 //为服务器设置一个独一无二的id便于区分，这里使用ip地址的最后一位充当server-id\n配置完成，:wq 保存，重启mysql\n重启mysql命令：# service mysqld restart\n同样的，进入从服务器，配置从服务器的my.cnf,重复步骤1即可，\n唯一的区别是，server-id要改成从服务器的ip尾位，即server-id=105;其他两项是一样的，保存，并重启mySQL；\n2.在主服务器上为从服务器分配一个账号，就像一把钥匙，从服务器拿着这个钥匙，才能到主服务器上来共享主服务器的日志文件。\n进入主服务器的mysql界面，\nmysql -u root -p 111111 //我这里mysql账号是root，密码是111111 在mysql操作界面下，输入下面一行命令：\nGRANT replication slave ON *.* TO \u0026#39;slave\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;111111\u0026#39;; 3.查看主服务器BIN日志的信息（执行完之后记录下这两值，然后在配置完从服务器之前不要对主服务器进行任何操作，因为每次操作数据库时这两值会发生改变）.\n4.设置从服务器\n进入从服务器mysql\nmysql -u root -p111111 关闭slave（如果你以前配置过主从的话，一定要先关闭）\nstop slave; 开始配置：\n输入下面代码即可：\n参数解释：\nMASTER_HOST : 设置要连接的主服务器的ip地址\nMASTER_USER : 设置要连接的主服务器的用户名\nMASTER_PASSWORD : 设置要连接的主服务器的密码\nMASTER_LOG_FILE : 设置要连接的主服务器的bin日志的日志名称，即第3步得到的信息\nMASTER_LOG_POS : 设置要连接的主服务器的bin日志的记录位置，即第3步得到的信息，（这里注意，最后一项不需要加引号。否则配置失败）\n先在从服务器配置完成，启动从服务器：\nstart slave; 5.查看是否配置成功：\nshow slave status; 上面两项均为yes，说明配置成功，否则，请重复前面的步骤。\n文章参考：http://www.cnblogs.com/superfat/p/5267449.html ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/mysql%E5%AE%9E%E7%8E%B0%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/%E7%94%A8%E6%88%B7%E5%8F%8A%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86\/": {
        "title": "用户及用户组管理",
        "tags": ["linux",],
        "content": "/etc/passwd 存储用户账号 /etc/group 存储组账号 /etc/shadow 存储用户账号的密码 /etc/gshadow 存储用户组账号的密码 useradd 用户名 userdel 用户名 adduser 用户名 groupadd 组名 groupdel 组名 passwd root 给root设置密码 su root su - root /etc/profile 系统环境变量 bash_profile 用户环境变量 .bashrc 用户环境变量 su user 切换用户，加载配置文件.bashrc su - user 切换用户，加载配置文件/etc/profile ，加载bash_profile 更改文件的用户及用户组 sudo chown [-R] owner[:group] {File|Directory} 例如：还以jdk-7u21-linux-i586.tar.gz为例。属于用户hadoop，组hadoop 要想切换此文件所属的用户及组。可以使用命令。 sudo chown root:root jdk-7u21-linux-i586.tar.gz ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/%E7%94%A8%E6%88%B7%E5%8F%8A%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/centos6.5%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85lnmp\/": {
        "title": "centos6.5编译安装LNMP",
        "tags": ["LNMP","linux",],
        "content": "一、环境准备 1、操作系统安装：CentOS 6.5 64位最小化安装。 2、配置好IP、DNS、网关、主机名 3、配置防火墙，开启80、3306端口 /sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT /etc/rc.d/init.d/iptables save /etc/init.d/iptables restart 这样就搞定了，查看效果\n/etc/init.d/iptables status /etc/init.d/iptables restart #最后重启防火墙使配置生效 PS：\nCentos升级到7之后，发现无法使用iptables控制Linuxs的端口，google之后发现Centos 7使用firewalld代替了原来的iptables。下面记录如何使用firewalld开放Linux端口：\n#开启端口 firewall-cmd --zone=public --add-port=80/tcp --permanent #重启防火墙 firewall-cmd --reload 命令含义： –zone #作用域 –add-port=80/tcp #添加端口，格式为：端口/通讯协议 –permanent #永久生效，没有此参数重启后失效\n4、关闭SELinux 查看selinux状态：\n/usr/sbin/sestatus -v SELinux status: disabled //禁用selinux getenforce Disabled //禁用selinux getenforce Enforcing //启动 关闭selinux方法： setenforce 0 #设置SELinux 成为permissive模式 setenforce 1 #设置SELinux 成为enforcing模式 第二种方法： vim /etc/selinux/config 编辑文件\n# This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. #permissive - SELinux prints warnings instead of enforcing. #disabled - No SELinux policy is loaded. SELINUX=enforcing # SELINUXTYPE= can take one of these two values: # targeted - Targeted processes are protected, # mls - Multi Level Security protection. 将SELINUX=enforceing 改为 SELINUX=disabled 重启机器就ok了\n二、系统约定 硬盘分区：50G(/boot 200M /swap 8192M /)+100G(/opt) 软件源代码包存放位置：/opt/local/src 源码包编译安装位置：/opt/local/软件名 数据库数据文件存储路径/opt/local/mysql/var\n三、软件包下载 将以上软件包上传到/opt/local/src目录\n四、安装编译工具及库文件 使用CentOS yum命令一键安装\nyum install -y make apr* autoconf automake curl curl-devel gcc gcc-c++ gtk+-devel zlib-devel openssl openssl-devel pcre-devel gd kernel keyutils patch perl kernel-headers compat* cpp glibc libgomp libstdc++-devel keyutils-libs-devel libsepol-devel libselinux-devel krb5-devel libXpm* freetype freetype-devel freetype* fontconfig fontconfig-devel libjpeg* libpng* php-common php-gd gettext gettext-devel ncurses* libtool* libxml2 libxml2-devel patch policycoreutils bison 五、软件安装篇 1、安装cmake cd /opt/local/src tar zxvf cmake-2.8.8.tar.gz cd cmake-2.8.8 ./configure --prefix=/opt/local/cmake make #编译 make install #安装 vim /etc/profile 在path路径中增加cmake执行文件路径 export PATH=$PATH:/opt/local/cmake/bin source /etc/profile使配置立即生效 2、安装pcre PS：Pcre版本不能太高，8最好，要不编译不能通过\ncd /opt/local/src mkdir /usr/local/pcre #创建安装目录 tar zxvf pcre-8.34.tar.gz cd pcre-8.34 ./configure --prefix=/opt/local/pcre #配置 make \u0026amp;\u0026amp; make install 3、安装libmcrypt cd /opt/local/src tar zxvf libmcrypt-2.5.8.tar.gz #解压 cd libmcrypt-2.5.8 #进入目录 ./configure #配置 make #编译 make install #安装 4、安装gd库 cd /opt/local/src tar zxvf gd-2.0.36RC1.tar.gz cd gd-2.0.36RC1 ./configure --enable-m4_pattern_allow --prefix=/opt/local/gd --with-jpeg=/usr/lib --with-png=/usr/lib --with-xpm=/usr/lib --with-freetype=/usr/lib --with-fontconfig=/usr/lib #配置 make #编译 make install #安装 5、安装Mysql groupadd mysql #添加mysql组 useradd -g mysql mysql -s /bin/false #创建用户mysql并加入到mysql组，不允许mysql用户直接登录系统 mkdir -p /opt/data/mysql/var #创建MySQL数据库存放目录 chown -R mysql:mysql /opt/data/mysql/var #设置MySQL数据库目录权限 cd /opt/local/src tar zxvf mysql-5.5.35.tar.gz #解压 cd mysql-5.5.35 cmake . -DCMAKE_INSTALL_PREFIX=/opt/local/mysql -DMYSQL_DATADIR=/opt/data/mysql/var -DSYSCONFDIR=/etc #配置 make #编译 make install #安装 cd /opt/local/mysql cp ./support-files/my-huge.cnf /etc/my.cnf #拷贝配置文件（注意：如果/etc目录下面默认有一个my.cnf，直接覆盖即可） vi /etc/my.cnf #编辑配置文件,在 [mysqld] 部分增加 datadir = /opt/data/mysql/var #添加MySQL数据库路径 ./scripts/mysql_install_db --user=mysql #生成mysql系统数据库 cp ./support-files/mysql.server /etc/rc.d/init.d/mysqld #把Mysql加入系统启动 chmod 755 /etc/init.d/mysqld #增加执行权限 chkconfig mysqld on #加入开机启动 vi /etc/rc.d/init.d/mysqld #编辑 basedir = /opt/local/mysql #MySQL程序安装路径 datadir = /opt/local/mysql/var #MySQl数据库存放目录 service mysqld start #启动 vi /etc/profile #把mysql服务加入系统环境变量：在最后添加下面这一行 export PATH=$PATH:/opt/local/cmake/bin:/opt/local/mysql/bin source /etc/profile #使配置立即生效 mkdir /var/lib/mysql #创建目录 ln -s /tmp/mysql.sock /var/lib/mysql/mysql.sock #添加软链接 mysql_secure_installation #设置Mysql密码，根据提示按Y 回车输入2次密码 #执行mysql_secure_installation时可能会报错 #ERROR 2002 (HY000): Can\u0026#39;t connect to local MySQL server through socket \u0026#39;/tmp/mysql.sock\u0026#39; (2) #这时检查 /etc/my.cnf里面 #[mysqld] #socket=/tmp/mysql.sock是否设置正确，这里把这里的目录修改成和报错一样的就可以 /opt/local/mysql/bin/mysqladmin -u root -p password \u0026#34;123456\u0026#34; #或者直接修改密码 到此，mysql安装完成！\n6、安装 nginx cd /opt/local/src groupadd www #添加www组 useradd -g www www -s /bin/false #创建nginx运行账户www并加入到www组，不允许www用户直接登录系统 tar zxvf nginx-1.4.4.tar.gz cd nginx-1.4.4 ./configure --prefix=/opt/local/nginx --without-http_memcached_module --user=www --group=www --with-http_stub_status_module --with-openssl=/usr/ --with-pcre=/opt/local/src/pcre-8.36 make make install /opt/local/nginx/sbin/nginx #启动nginx 注意:–with-pcre=/opt/local/src/pcre-8.64指向的是源码包解压的路径，而不是安装的路径，否则会报错\n设置nginx开启启动 vi /etc/rc.d/init.d/nginx #编辑启动文件添加下面内容\n#!/bin/bash # nginx Startup script for the Nginx HTTP Server # it is v.0.0.2 version. # chkconfig: - 85 15 # description: Nginx is a high-performance web and proxy server. # It has a lot of features, but it\u0026#39;s not for everyone. # processname: nginx # pidfile: /var/run/nginx.pid # config: /usr/local/nginx/conf/nginx.conf nginxd=/opt/local/nginx/sbin/nginx nginx_config=/opt/local/nginx/conf/nginx.conf nginx_pid=/opt/local/nginx/logs/nginx.pid RETVAL=0 prog=\u0026#34;nginx\u0026#34; # Source function library. . /etc/rc.d/init.d/functions # Source networking configuration. . /etc/sysconfig/network # Check that networking is up. [ ${NETWORKING} = \u0026#34;no\u0026#34; ] \u0026amp;\u0026amp; exit 0 [ -x $nginxd ] || exit 0 # Start nginx daemons functions. start() { if [ -e $nginx_pid ];then echo \u0026#34;nginx already running....\u0026#34; exit 1 fi echo -n $\u0026#34;Starting $prog: \u0026#34; daemon $nginxd -c ${nginx_config} RETVAL=$? echo [ $RETVAL = 0 ] \u0026amp;\u0026amp; touch /var/lock/subsys/nginx return $RETVAL } # Stop nginx daemons functions. stop() { echo -n $\u0026#34;Stopping $prog: \u0026#34; killproc $nginxd RETVAL=$? echo [ $RETVAL = 0 ] \u0026amp;\u0026amp; rm -f /var/lock/subsys/nginx /usr/local/nginx/logs/nginx.pid } reload() { echo -n $\u0026#34;Reloading $prog: \u0026#34; #kill -HUP `cat ${nginx_pid}` killproc $nginxd -HUP RETVAL=$? echo } # See how we were called. case \u0026#34;$1\u0026#34; in start) start ;; stop) stop ;; reload) reload ;; restart) stop start ;; status) status $prog RETVAL=$? ;; *) echo $\u0026#34;Usage: $prog {start|stop|restart|reload|status|help}\u0026#34; exit 1 esac exit $RETVAL :wq! #保存退出 chmod 775 /etc/rc.d/init.d/nginx #赋予文件执行权限 chkconfig nginx on #设置开机启动 /etc/rc.d/init.d/nginx restart #重新启动Nginx service nginx restart 7、安装php cd /opt/local/src tar -zvxf php-5.5.7.tar.gz cd php-5.5.7. ./configure --prefix=/opt/local/php --with-config-file-path=/opt/local/php/etc --with-mysql=/opt/local/mysql --with-mysql-sock=/tmp/mysql.sock --with-gd --with-iconv --with-zlib --enable-xml --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-mbregex --enable-fpm --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-mcrypt --with-curl --with-jpeg-dir --with-freetype-dir make #编译 make install #安装 cp php.ini-production /opt/local/php/etc/php.ini #复制php配置文件到安装目录 rm -rf /etc/php.ini #删除系统自带配置文件 ln -s /opt/local/php/etc/php.ini /etc/php.ini #添加软链接 cp /opt/local/php/etc/php-fpm.conf.default /opt/local/php/etc/php-fpm.conf #拷贝模板文件为php-fpm配置文件 vi /opt/local/php/etc/php-fpm.conf #编辑 user = www #设置php-fpm运行账号为www group = www #设置php-fpm运行组为www pid = run/php-fpm.pid #取消前面的分号 设置 php-fpm开机启动 cp /opt/local/src/php-5.5.7/sapi/fpm/init.d.php-fpm /etc/rc.d/init.d/php-fpm #拷贝php-fpm到启动目录 chmod +x /etc/rc.d/init.d/php-fpm #添加执行权限 chkconfig php-fpm on #设置开机启动 vi /opt/local/php/etc/php.ini #编辑配置文件\n修改为：disable_functions= passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,escapeshellcmd,dll,popen,disk_free_space,checkdnsrr,checkdnsrr,getservbyname,getservbyport,disk_total_space,posix_ctermid,posix_get_last_error,posix_getcwd, posix_getegid,posix_geteuid,posix_getgid, posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid, posix_getppid,posix_getpwnam,posix_getpwuid, posix_getrlimit, posix_getsid,posix_getuid,posix_isatty, posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid, posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname #列出PHP可以禁用的函数，如果某些程序需要用到这个函数，可以删除，取消禁用 找到：;date.timezone = 修改为：date.timezone = PRC #设置时区 找到：expose_php = On 修改为：expose_php = OFF #禁止显示php版本的信息 找到：short_open_tag = Off 修改为：short_open_tag = ON #支持php短标签 8、配置nginx支持php vi /opt/local/nginx/conf/nginx.conf 修改/opt/local/nginx/conf/nginx.conf 配置文件,需做如下修改 user www www; #首行user去掉注释,修改Nginx运行组为www www；必须与/opt/local/php/etc/php-fpm.conf中的user,group配置相同，否则php运行出错 user www www; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { root html; index index.php index.html index.htm; } location ~ \\.php$ { root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } } /etc/init.d/nginx restart #重启nginx 六、测试篇 cd /opt/local/nginx/html/ #进入nginx默认网站根目录 rm -rf /opt/local/nginx/html/* #删除默认测试页 vi index.php #新建index.php文件 \u0026lt;?php phpinfo(); ?\u0026gt; :wq! #保存退出 chown www.www /opt/local/nginx/html/ -R #设置目录所有者 chmod 700 /opt/local/nginx/html/ -R #设置目录权限 七、其它说明 服务器相关操作命令 service nginx restart #重启nginx service mysqld restart #重启mysql /usr/local/php/sbin/php-fpm #启动php-fpm /etc/rc.d/init.d/php-fpm restart #重启php-fpm /etc/rc.d/init.d/php-fpm stop #停止php-fpm /etc/rc.d/init.d/php-fpm start #启动php-fpm nginx默认站点目录是：/opt/local/nginx/html/ 权限设置：chown www.www /opt/local/nginx/html/ -R MySQL数据库目录是：/opt/local/mysql/var 权限设置：chown mysql.mysql -R /opt/local/mysql/var 重启nginx cd /lnmp/nginx/sbin ./nginx -s reload ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/centos6.5%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85lnmp\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/ssh%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95\/": {
        "title": "ssh免密码登录",
        "tags": ["ssh","linux",],
        "content": "ssh 无密码登录要使用公钥与私钥。linux下可以用用ssh-keygen生成公钥/私钥对，下面我以CentOS为例。\n有机器A(192.168.3.7)，B(192.168.3.3)。现想A通过ssh免密码登录到B。\n1.在A机下生成公钥/私钥对。\nssh-keygen -t rsa -P \u0026#39;\u0026#39; -P表示密码，-P \u0026rsquo;\u0026rsquo; 就表示空密码，也可以不用-P参数，这样就要三车回车，用-P就一次回车。 它在/home/root下生成.ssh目录，.ssh下有id_rsa和id_rsa.pub。\n2.把A机下的id_rsa.pub复制到B机下，在B机的.ssh/authorized_keys文件里，我用scp复制。\nscp ~/.ssh/id_rsa.pub root@192.168.3.3:/home/root/id_rsa.pub root@192.168.3.3\u0026#39;s password: id_rsa.pub 100% 223 0.2KB/s 00:00 由于还没有免密码登录的，所以要输入密码。\n3.B机把从A机复制的id_rsa.pub添加到.ssh/authorzied_keys 命令如下：\ncat id_rsa.pub \u0026gt;\u0026gt; ~/.ssh/authorized_keys chmod 600 ~/.ssh/authorized_keys authorized_keys的权限要是600。\n4.A机登录B机。\nssh 192.168.3.3 The authenticity of host \u0026#39;192.168.3.3 (192.168.3.3)\u0026#39; can\u0026#39;t be established. RSA key fingerprint is 00:a6:a8:87:eb:c7:40:10:39:cc:a0:eb:50:d9:6a:5b. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added \u0026#39;192.168.3.3\u0026#39; (RSA) to the list of known hosts. Last login: Thu Nov 30 21:03:18 2017 from root [root@B ~]$ 第一次登录是时要你输入yes。\n现在A机可以无密码登录B机了。\n小结：登录的机子可有私钥，被登录的机子要有登录机子的公钥。这个公钥/私钥对一般在私钥宿主机产生。上面是用rsa算法的公钥/私钥对，当然也可以用dsa(对应的文件是id_dsa，id_dsa.pub)\n想让A，B机无密码互登录，那B机以上面同样的方式配置即可。\n转载自：http://chenlb.iteye.com/blog/211809 ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/ssh%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95\/"
    },
    
    "http:\/\/zhaoguibin.me\/tags\/lsyncd\/": {
        "title": "lsyncd",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/tags\/lsyncd\/"
    },
    
    "http:\/\/zhaoguibin.me\/posts\/lsyncd%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85\/": {
        "title": "lsyncd实时同步工具安装",
        "tags": ["lsyncd","linux",],
        "content": "有2种方法可以安装\n1.yum安装，前提是安装了epel更新源。使用命令：\nyum install -y lsyncd 2.github下载，地址为：https://github.com/axkibe/lsyncd\n安装lua软件包以及依赖软件\nyum install -y lua lua-devel cmake rsync 解压下载的压缩包\nunzip lsyncd-master.zip -d /usr/src/ 进入目录\ncd /usr/src/lsyncd-master/ 使用cmake编译，如果没有安装cmake,可以yum安装一下\ncmake -DCMAKE_INSTALL_PREFIX=/usr/local/lsyncd make \u0026amp;\u0026amp; make install 进入安装目录\ncd /usr/local/lsyncd/ 创建配置文件目录和日志目录\nmkdir etc var 进入配置文件目录\ncd etc/ 编译配置文件\nvim lsyncd.conf settings { --pid文件 logfile = \u0026#34;/usr/local/lsyncd/var/lsyncd.log\u0026#34;, --状态文件 statusFile = \u0026#34;/usr/local/lsyncd/var/lsyncd.status\u0026#34;, --同步模式，意思就是有更新就同步 inotifyMode = \u0026#34;CloseWrite or Modify\u0026#34;, --最大8个进程 maxProcesses = 8, } sync { default.rsync, source = \u0026#34;/www\u0026#34;, target = \u0026#34;root@192.168.10.50:/www\u0026#34;, maxDelays = 5, delay = 30, -- init = true, rsync = { binary = \u0026#34;/usr/bin/rsync\u0026#34;, archive = true, compress = true, bwlimit = 2000 -- rsh = \u0026#34;/usr/bin/ssh -p 22 -o StrictHostKeyChecking=no\u0026#34; } } 在远端被同步的服务器上开启ssh无密码登录，请注意用户身份：（用root还是最吼的！！！）\n链接：ssh免密码登录 最后启动\n/usr/local/lsyncd/bin/lsyncd -log Exec /usr/local/lsyncd/etc/lsyncd.conf 关闭\nps -aux | grep lsyncd kill id 编译启动脚本\nvim /etc/init.d/lsyncd #!/bin/bash # # chkconfig: - 85 15 # description: Lightweight inotify based sync daemon # # processname: lsyncd # config: /usr/local/lsyncd/etc/lsyncd.conf # config: /etc/sysconfig/lsyncd # pidfile: /var/run/lsyncd.pid # Source function library . /etc/init.d/functions # Source networking configuration. . /etc/sysconfig/network # Check that networking is up. [ \u0026#34;$NETWORKING\u0026#34; = \u0026#34;no\u0026#34; ] \u0026amp;\u0026amp; exit 0 LSYNCD_OPTIONS=\u0026#34;-pidfile /var/run/lsyncd.pid /usr/local/lsyncd/etc/lsyncd.conf\u0026#34; if [ -e /etc/sysconfig/lsyncd ]; then . /etc/sysconfig/lsyncd fi RETVAL=0 prog=\u0026#34;lsyncd\u0026#34; thelock=/var/lock/subsys/lsyncd start() { [ -f /usr/local/lsyncd/etc/lsyncd.conf ] || exit 6 echo -n $\u0026#34;Starting $prog: \u0026#34; if [ $UID -ne 0 ]; then RETVAL=1 failure else daemon ${LSYNCD_USER:+--user ${LSYNCD_USER}} /usr/local/lsyncd/bin/lsyncd $LSYNCD_OPTIONS RETVAL=$? [ $RETVAL -eq 0 ] \u0026amp;\u0026amp; touch $thelock fi; echo return $RETVAL } stop() { echo -n $\u0026#34;Stopping $prog: \u0026#34; if [ $UID -ne 0 ]; then RETVAL=1 failure else killproc lsyncd RETVAL=$? [ $RETVAL -eq 0 ] \u0026amp;\u0026amp; rm -f $thelock fi; echo return $RETVAL } reload(){ echo -n $\u0026#34;Reloading $prog: \u0026#34; killproc lsyncd -HUP RETVAL=$? echo return $RETVAL } restart(){ stop start } condrestart(){ [ -e $thelock ] \u0026amp;\u0026amp; restart return 0 } case \u0026#34;$1\u0026#34; in start) start ;; stop) stop ;; restart) restart ;; reload) reload ;; condrestart) condrestart ;; status) status lsyncd RETVAL=$? ;; *) echo $\u0026#34;Usage: $0 {start|stop|status|restart|condrestart|reload}\u0026#34; RETVAL=1 esac exit $RETVAL 设置权限\nchmod 755 /etc/init.d/lsyncd 添加到开机自启动文件中\necho \u0026#34;/etc/init.d/lsyncd start\u0026#34; \u0026gt;\u0026gt; /etc/rc.local ", 
        "url": "http:\/\/zhaoguibin.me\/posts\/lsyncd%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85\/"
    },
    
    "http:\/\/zhaoguibin.me\/categories\/": {
        "title": "Categories",
        "tags": [],
        "content": "", 
        "url": "http:\/\/zhaoguibin.me\/categories\/"
    },
    
}
</script>
<script defer src="/js/lunr.js"></script>
<script defer src="/js/search.js"></script>




</footer>

</body>
</html>

